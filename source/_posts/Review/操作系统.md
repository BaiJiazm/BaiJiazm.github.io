---
title: 操作系统
date: 2018/3/23 0:06:47 
tags:
- OS
- Linux
- Review
---

## 操作系统

### Linux进程间通讯方式及编程知识
*   见文档linux-ipc.pdf及相应demo程序

### Linux多线程pthread编程知识
*   [linux多线程pthread](https://blog.csdn.net/ithomer/article/details/5920936)

### 进程线程的区别
*   见文档G-linux-thread.pdf及相应demo程序

### 进程线程面试题总结
*   [进程线程面试题总结](https://blog.csdn.net/wujiafei_njgcxy/article/details/77098977)

### 归纳进程线程的相同点
*   无论是进程还是线程，都是用来实现多任务并发的技术手段；
*   二者都可以独立调度，因此在多任务环境下，功能上并无差异；
*   二者都具有各自的实体，是系统独立管理的对象个体。所以在系统层面，都可以通过技术手段实现二者的控制；
*   二者所具有的状态都非常相似；
*   在多任务程序中，子进程(子线程)的调度一般与父进程(父线程)平等竞争。

### 归纳进程线程的不同点

#### 基本概念角度
*   进程是资源分配的基本单位，线程是调度的基本单位。

#### 系统实现角度
*   进程的实现是调用fork系统调用；线程的实现是调用clone系统调用。

|  进程原语	|线程原语 	      |描述|
|:-|:-|:-|
|  fork	    |pthread_create   |创建新的控制流|
|  exit	    |pthread_exit	  |从现有的控制流退出|
|  waitpid	|pthread_join	  |从控制流中得到退出状态|
|  aexit	|pthread_clean_push|注册在退出控制流时执行的函数|
|  getpid	|pthread_self	  |获得控制流ID|
|  abort	|pthread_cancel	  |请求控制流的非正常退出|

#### 实体间(进程间，线程间，进线程间)通信方式的不同
*   进程间的通信方式有这样几种：A.共享内存 B.消息队列 C.信号量 D.有名管道   E.无名管道 F.信号 G.文件 H.socket
*   线程间的通信方式上述进程间的方式都可沿用，且还有自己独特的几种：A.互斥量      B.自旋锁 C.条件变量  D.读写锁  E.线程信号 G.全局变量
*   值得注意的是，线程间通信用的信号不能采用进程间的信号，因为信号是基于进程为单位的，而线程是共属于同一进程空间的。故而要采用线程信号。综上，进程间通信手段有8种。线程间通信手段有13种。
*   进程间采用的通信方式要么需要切换内核上下文，要么要与外设访问(有名管道，文件)。所以速度会比较慢。而线程采用自己特有的通信方式的话，基本都在自己的进程空间内完成，不存在切换，所以通信速度会较快。也就是说，进程间与线程间分别采用的通信方式，除了种类的区别外，还有速度上的区别。

#### 个体间辈分关系的迥异
*   进程的备份关系森严，在父进程没有结束前，所有的子进程都尊从父子关系，也就是说A创建了B，则A与B是父子关系，B又创建了C，则B与C也是父子关系，A与C构成爷孙关系，也就是说C是A的孙子进程。在系统上使用pstree命令打印进程树，可以清晰看到辈分关系。
*   多线程间的关系没有那么严格，不管是父线程还是子线程创建了新的线程，都是共享父线程的资源，所以，都可以说是父线程的子线程，也就是只存在一个父线程，其余线程都是父线程的子线程。

#### 其他方面
*   可靠性：进程间不会互相影响；一个线程挂掉将导致整个进程挂掉。
*   分布式：进程适应于多核、多机分布式，如果一台机器不够，扩展到多台机器比较简单；线程适应于多核分布式。

### 多个进程同时写共享内存，如何防止内容乱？
*   [Linux 下多线程](http://zhangxiaoya.github.io/2015/05/15/multi-thread-of-c-program-language-on-linux/)

### 多线程访问共享内存的不加锁实现方式
*   [多线程访问共享内存的不加锁实现方式](http://blog.csdn.net/ywh147/article/details/8675532)

### 同步和异步、阻塞与非阻塞
*   [I/O并发编程总结](https://segmentfault.com/a/1190000004909797#articleHeader25)
*   [Linux IO模式及 select、poll、epoll详解](https://segmentfault.com/a/1190000003063859)

### 共享内存两种机制
*   共享内存可以通过 mmap()映射普通文件（特殊情况下还可以采用匿名映射）机制实现， 也可以通过 System V 共享内存机制实现。 
*   mmap 的机制：在磁盘上建立一个文件，每个进程存储器里面，单独开辟一个空间来进 行映射。mmap 保存到实际硬盘。优点：储存量可以很大（多于主存）；缺点：进程间读 取和写入速度要比主存的要慢。
*   shm 的机制：每个进程的共享内存都直接映射到实际物理存储器里面。shm 保存到物理存储器（主存），实际的储存量直接反映到主存上。优点，进程间访问速度（读写）比磁 盘要快；缺点，储存量不能非常大（多于主存） 。 
*   使用上看：如果分配的存储量不大，那么使用 shm；如果存储量大，那么使用 mmap。

### 产生死锁的条件
*   互斥条件（Mutualexclusion）：资源不能被共享，只能由一个进程使用。 
*   请求与保持条件（Hold andwait）：已经得到资源的进程可以再次申请新的资源。 
*   非剥夺条件（Nopre-emption）：已经分配的资源不能从相应的进程中被强制地剥夺。 
*   循环等待条件（ Circularwait ）：系统中若干进程组成环路，该环路中每个进程都在等待相 邻进程正占用的资源。 


### 使用mmap读写文件为什么比普通读写函数要快？
*   [mmap为什么比read/write快](http://blog.csdn.net/kai8wei/article/details/77980201)
