<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="BaiJiazm">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="BaiJiazm">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BaiJiazm">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"right","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>BaiJiazm</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BaiJiazm</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每一段路都是一种领悟:)</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/31/Major/LeetCode 685. Redundant Connection II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/31/Major/LeetCode 685. Redundant Connection II/" itemprop="url">图、树、并查集、DFS综合题目</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-31T14:58:28+08:00">
                2018-08-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3>LeetCode 685. Redundant Connection II</h3>
<p>好久没做Leetcode了，今天突发奇想，看到了一道综合性比较强的题目，花了一点时间自己做出来了，厉害！基本Leetcode题解我都是不会写的，直接在代码里有注释或方法及链接。具体可看<a href="https://github.com/BaiJiazm/DS-Algorithm" target="_blank" rel="external">题解</a></p>
<h3>Leetcode 164. Maximum Gap</h3>
<ul>
<li><a href="https://leetcode.com/problems/redundant-connection-ii/description/" target="_blank" rel="external">题目链接</a></li>
</ul>
<p>这道题目很好的考查了树的性质和图的基本知识，以及运用这些性质结合DFS和并查集解决问题的能力。</p>
<p>一棵树可以看做有向图，n个节点有n-1条边，增加1条边后只有两种情况：</p>
<ul>
<li>有一个节点有两个入度，其中一个必多余
<ul>
<li>如果没有形成环，那么去掉最后一个符合题意</li>
<li>如果此时有环，那么去掉在环中的那一条边即可。从该节点出发DFS即可</li>
</ul>
</li>
<li>所有节点只有一个入度，那么增加的边肯定经过原根节点，必会有环，去掉任何一条边即可。利用并查集找到最后出现的那条边。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;graph;</div><div class="line">		<span class="keyword">int</span> start;</div><div class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</div><div class="line">			graph.clear();</div><div class="line">			graph.resize(edges.size()+<span class="number">1</span>);</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;edges.size(); ++i) &#123;</div><div class="line">				graph[edges[i][<span class="number">0</span>]].push_back(edges[i][<span class="number">1</span>]);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;a: graph[u]) &#123;</div><div class="line">				<span class="keyword">if</span>(a==start) &#123;</div><div class="line">					ans.push_back(u);</div><div class="line">					ans.push_back(a);</div><div class="line">					<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span>(dfs(a))</div><div class="line">					<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findRedundantDirectedConnection(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</div><div class="line">			<span class="keyword">int</span> n=edges.size();</div><div class="line">			<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inDegree(n+<span class="number">1</span>, <span class="number">0</span>);</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</div><div class="line">				<span class="keyword">if</span>(++inDegree[edges[i][<span class="number">1</span>]]&gt;<span class="number">1</span>) &#123;</div><div class="line">					buildGraph(edges);</div><div class="line">					start=edges[i][<span class="number">1</span>];</div><div class="line">					<span class="keyword">if</span>(dfs(start))</div><div class="line">						<span class="keyword">return</span> ans;</div><div class="line">					<span class="keyword">return</span> edges[i];</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			init(n);</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</div><div class="line">				<span class="keyword">int</span> p=edges[i][<span class="number">0</span>];</div><div class="line">				<span class="keyword">int</span> c=edges[i][<span class="number">1</span>];</div><div class="line">				<span class="keyword">int</span> pFa=findFa(p);</div><div class="line">				<span class="keyword">int</span> cFa=findFa(c);</div><div class="line">				<span class="keyword">if</span>(pFa==cFa)</div><div class="line">					<span class="keyword">return</span> edges[i];</div><div class="line">				fa[cFa]=pFa;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;fa;</div><div class="line">		<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">			fa.resize(n+<span class="number">1</span>);</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; ++i) &#123;</div><div class="line">				fa[i]=i;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">int</span> <span class="title">findFa</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</div><div class="line">			<span class="keyword">if</span>(fa[c]==c)</div><div class="line">				<span class="keyword">return</span> c;</div><div class="line">			<span class="keyword">return</span> fa[c]=findFa(fa[c]);</div><div class="line">		&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/30/Major/线性排序算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/30/Major/线性排序算法/" itemprop="url">线性排序算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-30T09:35:09+08:00">
                2018-08-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3>线性排序算法</h3>
<p>复习一下线性排序算法:计数排序、桶排序与基数排序</p>
<ul>
<li><a href="https://www.byvoid.com/zhs/blog/sort-radix" target="_blank" rel="external">三种线性排序算法 计数排序、桶排序与基数排序</a></li>
<li><a href="https://blog.csdn.net/zouliping123/article/details/8934856" target="_blank" rel="external">线性排序算法（计数排序，基数排序，桶排序）分析及实现</a></li>
<li><a href="https://leetcode.com/problems/maximum-gap/description/" target="_blank" rel="external">Leetcode 164. Maximum Gap</a></li>
</ul>
<h3>Leetcode 164. Maximum Gap</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Radix Sort</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (nums.empty() || nums.size() &lt; <span class="number">2</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> maxVal = *max_element(nums.begin(), nums.end());</div><div class="line"></div><div class="line">    <span class="keyword">int</span> <span class="built_in">exp</span> = <span class="number">1</span>;                                 <span class="comment">// 1, 10, 100, 1000 ...</span></div><div class="line">    <span class="keyword">int</span> radix = <span class="number">10</span>;                              <span class="comment">// base 10 system</span></div><div class="line"></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; aux(nums.size());</div><div class="line"></div><div class="line">    <span class="comment">/* LSD Radix Sort */</span></div><div class="line">    <span class="keyword">while</span> (maxVal / <span class="built_in">exp</span> &gt; <span class="number">0</span>) &#123;                   <span class="comment">// Go through all digits from LSD to MSD</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(radix, <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)    <span class="comment">// Counting sort</span></div><div class="line">            count[(nums[i] / <span class="built_in">exp</span>) % <span class="number">10</span>]++;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count.size(); i++)   <span class="comment">// you could also use partial_sum()</span></div><div class="line">            count[i] += count[i - <span class="number">1</span>];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</div><div class="line">            aux[--count[(nums[i] / <span class="built_in">exp</span>) % <span class="number">10</span>]] = nums[i];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</div><div class="line">            nums[i] = aux[i];</div><div class="line"></div><div class="line">        <span class="built_in">exp</span> *= <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> maxGap = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span>; i++)</div><div class="line">        maxGap = max(nums[i + <span class="number">1</span>] - nums[i], maxGap);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> maxGap;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Buckets and The Pigeonhole Principle</span></div><div class="line"><span class="keyword">class</span> Bucket &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">bool</span> used = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">int</span> minval = numeric_limits&lt;<span class="keyword">int</span>&gt;::max();        <span class="comment">// same as INT_MAX</span></div><div class="line">    <span class="keyword">int</span> maxval = numeric_limits&lt;<span class="keyword">int</span>&gt;::min();        <span class="comment">// same as INT_MIN</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (nums.empty() || nums.size() &lt; <span class="number">2</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> mini = *min_element(nums.begin(), nums.end()),</div><div class="line">        maxi = *max_element(nums.begin(), nums.end());</div><div class="line"></div><div class="line">    <span class="keyword">int</span> bucketSize = max(<span class="number">1</span>, (maxi - mini) / ((<span class="keyword">int</span>)nums.size() - <span class="number">1</span>));        <span class="comment">// bucket size or capacity</span></div><div class="line">    <span class="keyword">int</span> bucketNum = (maxi - mini) / bucketSize + <span class="number">1</span>;                         <span class="comment">// number of buckets</span></div><div class="line">    <span class="built_in">vector</span>&lt;Bucket&gt; buckets(bucketNum);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; num : nums) &#123;</div><div class="line">        <span class="keyword">int</span> bucketIdx = (num - mini) / bucketSize;                          <span class="comment">// locating correct bucket</span></div><div class="line">        buckets[bucketIdx].used = <span class="literal">true</span>;</div><div class="line">        buckets[bucketIdx].minval = min(num, buckets[bucketIdx].minval);</div><div class="line">        buckets[bucketIdx].maxval = max(num, buckets[bucketIdx].maxval);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> prevBucketMax = mini, maxGap = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; bucket : buckets) &#123;</div><div class="line">        <span class="keyword">if</span> (!bucket.used)</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">        maxGap = max(maxGap, bucket.minval - prevBucketMax);</div><div class="line">        prevBucketMax = bucket.maxval;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> maxGap;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/26/Major/动态规划集锦/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/26/Major/动态规划集锦/" itemprop="url">动态规划集锦</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-26T20:34:23+08:00">
                2018-08-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3>区间动态规划</h3>
<ul>
<li><a href="https://blog.csdn.net/flushhip/article/details/79416715" target="_blank" rel="external">今日头条2018校园招聘后端开发工程师(第二批)编程题 - 题解</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/25/Major/链表问题集锦/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/25/Major/链表问题集锦/" itemprop="url">链表问题集锦</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-25T23:01:44+08:00">
                2018-08-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3>链表问题集锦</h3>
<ul>
<li><a href="http://wuchong.me/blog/2014/03/25/interview-link-questions/" target="_blank" rel="external">面试精选：链表问题集锦</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/22/Major/单调栈题目算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/22/Major/单调栈题目算法/" itemprop="url">单调栈题目算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-22T21:10:25+08:00">
                2018-08-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3>单调栈题目算法</h3>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/26465701" target="_blank" rel="external">浅谈单调栈</a></li>
<li>Leetcode 84. Largest Rectangle in Histogram.</li>
<li>Leetcode 85. Maximal Rectangle.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/21/Major/检测图存在环算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/21/Major/检测图存在环算法/" itemprop="url">检测图存在环方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-21T19:15:33+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3>检测图存在环方法</h3>
<ul>
<li><a href="https://blog.csdn.net/login_sonata/article/details/78002042" target="_blank" rel="external">判断有向图是否存在环的2种方法（深度遍历，拓扑排序）</a></li>
<li><a href="https://blog.csdn.net/turingwy/article/details/49885927" target="_blank" rel="external">有向图与无向图判断有环</a></li>
<li><a href="https://blog.csdn.net/u014665013/article/details/51351371" target="_blank" rel="external">树边，前向边，后向边，横叉边</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/24/Other/爬虫的基本流程及反爬虫机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/24/Other/爬虫的基本流程及反爬虫机制/" itemprop="url">爬虫的基本流程及反爬虫机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-24T23:47:51+08:00">
                2018-07-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>爬虫的基本流程</h1>
<p><img src="https://i.imgur.com/ye9VvBW.png" alt="爬虫的基本流程"></p>
<ul>
<li>选取一部分精心挑选的种子URL，将种子URL加入待抓取任务队列。</li>
<li>从待抓取URL队列中取出待抓取的URL，DNS解析得到主机的ip，并将URL对应的网页下载存储进已下载网页库中，将该URL放进已抓取URL队列。</li>
<li>分析提取已下载的网页中的URL，将未抓取过的URL放入待抓取URL队列，从而进入下一个循环。</li>
<li>解析已下载的网页，将需要的数据内容解析出来。</li>
<li>数据持久化，以数据库或其它形式存储。</li>
</ul>
<h1>一个URL的请求与响应</h1>
<p>爬虫最主要的任务就是发起请求(Request)，然后获取服务器的响应(Response)，遵循HTTP协议。</p>
<p><img src="https://i.imgur.com/8NCIf48.png" alt="请求与响应"></p>
<p><strong>HTTP之请求消息Request</strong></p>
<p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：</p>
<ul>
<li>请求行（request line）</li>
<li>请求头部（header）</li>
<li>空行</li>
<li>请求数据</li>
</ul>
<p><img src="https://i.imgur.com/LhYgX0L.png" alt="HTTP之请求消息Request"></p>
<p>GET请求样例：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GET</span> <span class="string">https://www.tvmao.com/program/CCTV</span> HTTP/1.1</div><div class="line"><span class="attribute">Host</span>: www.tvmao.com</div><div class="line"><span class="attribute">Connection</span>: keep-alive</div><div class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.26</div><div class="line"><span class="attribute">Upgrade-Insecure-Requests</span>: 1</div><div class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</div><div class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate, br</div><div class="line"><span class="attribute">Accept-Language</span>: zh-CN,zh;q=0.9</div><div class="line"><span class="attribute">Cookie</span>: UM_distinctid=164915db395f1-073fb37f3c265b-4d754111-1fa400-164915db39688f;</div></pre></td></tr></table></figure>
<p><strong>HTTP之响应消息Response</strong></p>
<p>一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。</p>
<p>HTTP响应也由四个部分组成，分别是：</p>
<ul>
<li>状态行</li>
<li>消息报头</li>
<li>空行</li>
<li>响应正文</li>
</ul>
<p><img src="https://i.imgur.com/HepnkrA.jpg" alt="HTTP之响应消息Response"></p>
<p>Response响应样例：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 <span class="number">200</span> OK</div><div class="line"><span class="attribute">Server</span>: Tengine/2.1.0</div><div class="line"><span class="attribute">Date</span>: Mon, 23 Jul 2018 02:43:33 GMT</div><div class="line"><span class="attribute">Content-Type</span>: text/html;charset=UTF-8</div><div class="line"><span class="attribute">Connection</span>: keep-alive</div><div class="line"><span class="attribute">Vary</span>: Accept-Encoding</div><div class="line"><span class="attribute">Set-Cookie</span>: ASCK=; path=/; expires=Mon, 23-Jul-2018 03:13:33 GMT</div><div class="line"><span class="attribute">Strict-Transport-Security</span>: max-age=15768000</div><div class="line"><span class="attribute">Content-Length</span>: 32143</div><div class="line"></div><div class="line"><span class="undefined">&lt;!doctype html&gt;&lt;head&gt;</span></div><div class="line">&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt;</div><div class="line">&lt;title&gt;CCTV-1综合节目表,中央电视台综合频道节目表_电视猫&lt;/title&gt;</div><div class="line">...</div><div class="line"></div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h1>解析网页数据</h1>
<p><a href="http://python.jobbole.com/82633/" target="_blank" rel="external">更多Python爬虫工具</a></p>
<p><strong>Python HTML解析器</strong></p>
<p><img src="https://i.imgur.com/UZL1hn7.png" alt=""></p>
<p><strong>DOM(文档对象模型)树</strong></p>
<p><img src="https://i.imgur.com/hCAK0uj.png" alt=""></p>
<p><strong>重点介绍Beautiful Soup</strong></p>
<p>Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库。它能够通过你喜欢的转换器实现惯用的文档导航，查找，修改文档的方式。Beautiful Soup会帮你节省数小时甚至数天的工作时间。</p>
<p><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="external">Beautiful Soup 4.2.0 文档</a></p>
<p>Beautiful Soup 解析html样例：<a href="https://www.tvmao.com/program/CCTV" target="_blank" rel="external">电视猫</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> urllib.request <span class="keyword">as</span> urllib2</div><div class="line"><span class="keyword">import</span> requests</div><div class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> urllib3</div><div class="line"></div><div class="line"><span class="comment"># 禁用安全请求警告</span></div><div class="line"><span class="keyword">from</span> requests.packages.urllib3.exceptions <span class="keyword">import</span> InsecureRequestWarning</div><div class="line">requests.packages.urllib3.disable_warnings(InsecureRequestWarning)</div><div class="line"></div><div class="line">hrefFile = open(<span class="string">"testHref.txt"</span>, <span class="string">"w"</span>)</div><div class="line">resFile = open(<span class="string">"testRes.txt"</span>, <span class="string">"w"</span>)</div><div class="line"></div><div class="line">proxyHandler = urllib2.ProxyHandler(&#123;</div><div class="line">    <span class="string">'http'</span>: <span class="string">'http://115.225.88.99:8118'</span>,</div><div class="line">    <span class="string">'http'</span>: <span class="string">'http://118.190.95.43:9001'</span>,</div><div class="line">    <span class="string">'http'</span>: <span class="string">'http://111.155.116.207:8123'</span>,</div><div class="line">    <span class="string">'http'</span>: <span class="string">'http://122.114.31.177:808'</span>,</div><div class="line">    <span class="string">'http'</span>: <span class="string">'http://106.56.102.254:8070'</span>,</div><div class="line">    <span class="string">'http'</span>: <span class="string">'http://111.155.116.249:8123'</span>,</div><div class="line">    <span class="string">'http'</span>: <span class="string">'http://180.118.240.8:61234'</span>,</div><div class="line">    <span class="string">'http'</span>: <span class="string">'http://60.177.225.218:18118'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">opener = urllib2.build_opener(proxyHandler)</div><div class="line">urllib2.install_opener(opener)</div><div class="line"></div><div class="line">prefix = <span class="string">'https://www.tvmao.com'</span></div><div class="line"></div><div class="line">todoUrlSet = set()</div><div class="line">doneUrlSet = set()</div><div class="line">channelsSet = set()</div><div class="line"></div><div class="line"><span class="comment"># userAgents是爬虫与反爬虫斗争的第一步</span></div><div class="line">userAgents = [<span class="string">'User-Agent:Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1'</span>,</div><div class="line">              <span class="string">'User-Agent:Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50'</span>,</div><div class="line">              <span class="string">'User-Agent:Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11'</span>,</div><div class="line">              <span class="string">'User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:57.0) Gecko/20100101 Firefox/57.0'</span>,</div><div class="line">              <span class="string">'User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;Trident/4.0;InfoPath.2;.NET4.0C;.NET4.0E;.NETCLR2.0.50727;360SE'</span>,</div><div class="line">              <span class="string">'User-Agent:Mozilla/4.0(compatible;MSIE7.0;WindowsNT5.1;Trident/4.0;SE2.XMetaSr1.0;SE2.XMetaSr1.0;.NETCLR2.0.50727;SE2.XMetaSr1.0)'</span>,</div><div class="line">              <span class="string">'User-Agent:Mozilla/5.0(Macintosh;IntelMacOSX10_7_0)AppleWebKit/535.11(KHTML,likeGecko)Chrome/17.0.963.56Safari/535.11 '</span>,</div><div class="line">              <span class="string">'User-Agent:Mozilla/5.0(Macintosh;U;IntelMacOSX10_6_8;en-us)AppleWebKit/534.50(KHTML,likeGecko)Version/5.1Safari/534.50 '</span>,</div><div class="line">              <span class="string">'User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.26 Safari/537.36 Core/1.63.5514.400 QQBrowser/10.1.1660.400'</span></div><div class="line">              ]</div><div class="line"></div><div class="line">header = &#123;&#125;</div><div class="line">header[<span class="string">'Accept'</span>] = <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8'</span></div><div class="line">header[<span class="string">'Accept-Encoding'</span>] = <span class="string">'gzip, deflate, br'</span></div><div class="line">header[<span class="string">'Accept-Language'</span>] = <span class="string">'zh-CN,zh;q=0.9'</span></div><div class="line">header[<span class="string">'Connection'</span>] = <span class="string">'keep-alive'</span></div><div class="line">header[<span class="string">'Host'</span>] = <span class="string">'www.tvmao.com'</span></div><div class="line">header[<span class="string">'Origin'</span>] = <span class="string">'https://www.tvmao.com'</span></div><div class="line">header[<span class="string">'Referer'</span>] = <span class="string">'https://www.tvmao.com/program/channels'</span></div><div class="line">header[<span class="string">'User-Agent'</span>] = <span class="string">''</span></div><div class="line">header[<span class="string">'Cache-Control'</span>] = <span class="string">'max-age=0'</span></div><div class="line">header[<span class="string">'Upgrade-Insecure-Requests'</span>] = <span class="string">'1'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHeaders</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment"># 随机获取一个headers</span></div><div class="line">    header[<span class="string">'User-Agent'</span>] = random.choice(userAgents)</div><div class="line">    <span class="keyword">return</span> header</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseHtml</span><span class="params">(html)</span>:</span></div><div class="line">    <span class="comment"># print(html)</span></div><div class="line">    div = BeautifulSoup(html,  <span class="string">"lxml"</span>).find_all(<span class="string">'div'</span>, class_=<span class="string">'chlsnav'</span>)</div><div class="line">    divBs = BeautifulSoup(str(div),  <span class="string">"lxml"</span>)</div><div class="line">    <span class="comment"># print(divBs.prettify())</span></div><div class="line"></div><div class="line">    ul = divBs.ul.extract()</div><div class="line">    <span class="comment"># print(BeautifulSoup(str(ul),  "lxml").prettify)</span></div><div class="line">    <span class="comment"># print(BeautifulSoup(str(divBs),  "lxml").prettify)</span></div><div class="line">    <span class="comment"># sys.stdout.flush()</span></div><div class="line">    <span class="comment"># os._exit(0)</span></div><div class="line"></div><div class="line">    <span class="comment"># 寻找可能的新链接页面</span></div><div class="line">    allA = divBs.find_all(<span class="string">'a'</span>)</div><div class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> allA:</div><div class="line">        href = each[<span class="string">'href'</span>]</div><div class="line">        <span class="keyword">if</span> (href <span class="keyword">not</span> <span class="keyword">in</span> doneUrlSet) <span class="keyword">and</span> (href <span class="keyword">not</span> <span class="keyword">in</span> todoUrlSet):</div><div class="line">            print(each.string, href)</div><div class="line">            print(each.string, href, file=hrefFile)</div><div class="line">            todoUrlSet.add(str(href))</div><div class="line"></div><div class="line">    <span class="comment"># 搜集未发现的节目</span></div><div class="line">    <span class="comment"># 查找当前频道仅为了结果的顺序更好一些</span></div><div class="line">    curChn = ul.find_all(<span class="string">'li'</span>, class_=<span class="string">'curchn'</span>)</div><div class="line">    <span class="comment"># print(curChn)</span></div><div class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> curChn:</div><div class="line">        chn = each.string</div><div class="line">        <span class="keyword">if</span> chn <span class="keyword">not</span> <span class="keyword">in</span> channelsSet:</div><div class="line">            print(chn)</div><div class="line">            print(chn, file=resFile)</div><div class="line">            channelsSet.add(chn)</div><div class="line"></div><div class="line">    a = ul.find_all(<span class="string">'a'</span>)</div><div class="line">    <span class="comment"># print(a)</span></div><div class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> a:</div><div class="line">        chn = each.string</div><div class="line">        <span class="keyword">if</span> chn <span class="keyword">not</span> <span class="keyword">in</span> channelsSet:</div><div class="line">            print(chn)</div><div class="line">            print(chn, file=resFile)</div><div class="line">            channelsSet.add(chn)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">spiderGet</span><span class="params">(url)</span>:</span></div><div class="line">    response = requests.get(url=url, headers=getHeaders(), verify=<span class="keyword">False</span>)</div><div class="line">    response.encoding = <span class="string">'utf-8'</span></div><div class="line">    parseHtml(html=response.text)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">spiderOneRoot</span><span class="params">(rootUrl)</span>:</span></div><div class="line">    todoUrlSet.clear()</div><div class="line">    doneUrlSet.clear()</div><div class="line">    todoUrlSet.add(rootUrl)</div><div class="line"></div><div class="line">    failed = <span class="number">0</span></div><div class="line">    <span class="keyword">while</span> len(todoUrlSet) &gt; <span class="number">0</span>:</div><div class="line">        postfix = todoUrlSet.pop()</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            doneUrlSet.add(postfix)</div><div class="line">            url = prefix+postfix</div><div class="line">            spiderGet(url)</div><div class="line">            sys.stdout.flush()</div><div class="line">            hrefFile.flush()</div><div class="line">            resFile.flush()</div><div class="line">            failed = <span class="number">0</span></div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            <span class="comment"># print(err)</span></div><div class="line">            todoUrlSet.add(postfix)</div><div class="line">            <span class="comment"># t = random.randint(0, 30)</span></div><div class="line">            <span class="comment"># print('sleep', t, 'sec')</span></div><div class="line">            time.sleep(<span class="number">10</span>)</div><div class="line">            failed = failed+<span class="number">1</span></div><div class="line">            print(<span class="string">'failed'</span>, failed, <span class="string">'time'</span>)</div><div class="line">            <span class="keyword">if</span> failed &gt; <span class="number">120</span>:</div><div class="line">                print(postfix+<span class="string">'failed too much !'</span>)</div><div class="line">                <span class="keyword">return</span></div><div class="line"></div><div class="line"><span class="comment"># spiderOneRoot('/program/CCTV')</span></div><div class="line"><span class="comment"># os._exit(0)</span></div><div class="line"></div><div class="line"></div><div class="line">entryUrl = [</div><div class="line">    <span class="string">'/program/CCTV'</span>,</div><div class="line">    <span class="string">'/program_satellite/AHTV1-w3.html'</span>,</div><div class="line">    <span class="string">'/program_digital/CCTV3D-w3.html'</span>,</div><div class="line">    <span class="string">'/program/TVB'</span>,</div><div class="line">    <span class="string">'/program/AUMEN'</span>,</div><div class="line">    <span class="string">'/program/STARTV'</span>,</div><div class="line">    <span class="string">'/program/AUSTRALIANETWORK'</span>,</div><div class="line">    <span class="string">'/program/HEBEI-HEBEI1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/XIZANGTV-XIZANGTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/ZJTV-ZJTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/GSTV-GSTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/JXTV-JXTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/LNTV-LNTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/CCQTV-CCQTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/SDTV-SDTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/HAINANTV'</span>,</div><div class="line">    <span class="string">'/program/YNTV-YNTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/GUIZOUTV-GUIZOUTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/AHTV-AHTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/AHTV-AHTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/JILIN-JILIN1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/QHTV-QHTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/SCTV-SCTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/NMGTV-NMGTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/HUBEI-HUBEI1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/NXTV-NXTV2-w1.html'</span>,</div><div class="line">    <span class="string">'/program/GUANXI-GUANXI2-w1.html'</span>,</div><div class="line">    <span class="string">'/program/XJTV-XJTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/SHHAI'</span>,</div><div class="line">    <span class="string">'/program/HLJTV-HLJTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/HNTV-HNTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/HNTV-HNTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/SXTV-SXTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/BTV-BTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/GDTV-GDTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/JSTV-JSTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/TJTV-TJTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/HUNANTV-HUNANTV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/SHXITV-SHXITV1-w1.html'</span>,</div><div class="line">    <span class="string">'/program/FJTV-FJTV2-w1.html'</span></div><div class="line">]</div><div class="line"></div><div class="line"><span class="keyword">for</span> url <span class="keyword">in</span> entryUrl:</div><div class="line">    spiderOneRoot(url)</div></pre></td></tr></table></figure>
<h1>存储数据</h1>
<p><img src="https://i.imgur.com/v4t2tBA.png" alt=""></p>
<h1>爬虫的抓取策略</h1>
<p>在爬虫系统中，待抓取URL队列是很重要的一部分。待抓取URL队列中的URL以什么样的顺序排列也是一个很重要的问题，因为这涉及到先抓取那个页面，后抓取哪个页面。而决定这些URL排列顺序的方法，叫做抓取策略。下面重点介绍几种常见的抓取策略：</p>
<p><img src="https://i.imgur.com/SUAH4bX.jpg" alt=""></p>
<p><strong>深度优先策略(DFS)</strong></p>
<p>深度优先策略是指爬虫从某个URL开始，一个链接一个链接的爬取下去，直到处理完了某个链接所在的所有线路，才切换到其它的线路。 此时抓取顺序为：<code>A -&gt; B -&gt; C -&gt; D -&gt; E -&gt; F -&gt; G -&gt; H -&gt; I -&gt; J</code></p>
<p><strong>广度优先策略(BFS)</strong></p>
<p>宽度优先遍历策略的基本思路是，将新下载网页中发现的链接直接插入待抓取URL队列的末尾。也就是指网络爬虫会先抓取起始网页中链接的所有网页，然后再选择其中的一个链接网页，继续抓取在此网页中链接的所有网页。 此时抓取顺序为：<code>A -&gt; B -&gt; E -&gt; G -&gt; H -&gt; I -&gt; C -&gt; F -&gt; J -&gt; D</code></p>
<h1>高效抓取数据（多线程/多进程/分布式爬虫）</h1>
<p>分布式爬取，针对大型爬虫系统的，实现一个分布式的爬虫，主要为以下几个步骤：</p>
<ul>
<li>1、基本的http抓取工具，如scrapy；</li>
<li>2、避免重复抓取网页，如Bloom Filter；</li>
<li>3、维护一个所有集群机器能够有效分享的分布式队列；</li>
<li>4、将分布式队列和Scrapy的结合；</li>
<li>5、后续处理，网页析取(如python-goose)，存储(如Mongodb)。</li>
</ul>
<h1>反爬虫机制与应对策略</h1>
<p>爬虫：使用任何技术手段，批量获取网站信息的一种方式。
反爬虫：使用任何技术手段，阻止别人批量获取自己网站信息的一种方式。</p>
<p>**常见的反爬虫机制：**一般网站从三个方面反爬虫，即请求网站访问时的请求头Headers，用户行为，目标网站的目录和数据加载方式。前两个方面可以说是反爬虫策略中最为常见的，而第三个则是应用ajax（异步加载）的方式加载页面目录或者内容，增大爬虫在对目标网站形成访问之后获取数据的难度。</p>
<h3>0x01 通过Headers反爬虫</h3>
<ul>
<li>
<p><strong>通过Headers中的User-Agent识别爬虫</strong>
从用户请求的Headers反爬虫是最常见的反爬虫策略。由于正常用户访问网站时是通过浏览器访问的，所以目标网站通常会在收到请求时校验Headers中的User-Agent字段，如果不是携带正常的User-Agent信息的请求便无法通过请求。</p>
</li>
<li>
<p><strong>通过Headers中的Refer防止盗链</strong>
盗链是指服务提供商自己不提供服务的内容，利用别人网站的链接去获取别人网站里面的图片或者视频等资源，一部分网站为了防盗链，还会校验请求Headers中的Referer字段。</p>
</li>
</ul>
<h3>0x01 应对策略</h3>
<ul>
<li><strong>构造Headers</strong>
针对这类反爬虫机制，可以直接在自己写的爬虫中添加Headers，将浏览器的User-Agent复制到爬虫的Headers中，或使用User-Agent池。也就是每次发送的时候随机从池中选择不一样的浏览器头信息，防止暴露爬虫身份；另外通过对请求的抓包分析，将Referer值修改为目标网站域名，就能很好的绕过。</li>
</ul>
<h3>0x02 基于用户行为反爬虫</h3>
<ul>
<li>
<p><strong>设置IP访问频率，如果超过一定频率，弹出验证码</strong>
如果输入正确的验证码，则放行，如果没有输入，则拉入禁止一段时间，如果超过禁爬时间，再次出发验证码，则拉入黑名单。当然根据具体的业务，为不同场景设置不同阈值，比如登陆用户和非登陆用户，请求是否含有refer。</p>
</li>
<li>
<p><strong>通过并发识别爬虫</strong>
有些爬虫的并发是很高的，统计并发最高的IP，加入黑名单（或者直接封掉爬虫IP所在C段）</p>
</li>
<li>
<p><strong>请求的时间窗口过滤统计</strong>
爬虫爬取网页的频率都是比较固定的，不像人去访问网页，中间的间隔时间比较无规则，所以我们可以给每个IP地址建立一个时间窗口，记录IP地址最近12次访问时间，每记录一次就滑动一次窗口，比较最近访问时间和当前时间，如果间隔时间很长判断不是爬虫，清除时间窗口，如果间隔不长，就回溯计算指定时间段的访问频率，如果访问频率超过阀值，就转向验证码页面让用户填写验证码。</p>
</li>
<li>
<p><strong>限制单个ip/api token的访问量</strong>
比如15分钟限制访问页面180次，具体标准可参考一些大型网站的公开api，如twitter api，对于抓取用户公开信息的爬虫要格外敏感</p>
</li>
</ul>
<h3>0x02 应对策略</h3>
<ul>
<li>
<p><strong>降低请求频率</strong>
例如每隔一个时间段请求一次或者请求若干次之后sleep一段时间，也可以每次请求后随机间隔几秒再进行下一次请求。由于网站获取到的ip是一个区域网的ip，该ip被区域内的所有人共享，因此这个间隔时间并不需要特别长。</p>
</li>
<li>
<p><strong>使用代理IP池</strong>
使用代理IP池需要大量的IP资源。可以专门写一个在网上抓取可用代理ip的脚本，然后将抓取到的代理ip维护到代理池中供爬虫使用，当然，实际上抓取的ip不论是免费的还是付费的，通常的使用效果都极为一般，如果需要抓取高价值数据的话也可以考虑购买宽带adsl拨号的VPS，如果ip被目标网站被封掉，重新拨号即可。</p>
</li>
</ul>
<h3>0x03 动态页面的反爬虫</h3>
<ul>
<li>
<p><strong>数据通过ajax请求得到或JavaScript生成</strong>
上述的几种情况大多都是出现在静态页面，但是对于动态网页，我们需要爬取的数据是通过ajax请求得到，或者通过JavaScript生成的。</p>
</li>
<li>
<p><strong>ajax请求的所有参数全部加密</strong>
网站把ajax请求的所有参数全部加密了。我们根本没办法构造自己所需要的数据的请求。还有一些严防死守的网站，除了加密ajax参数，它还把一些基本的功能都封装了，全部都是在调用自己的接口，而接口参数都是加密的。</p>
</li>
</ul>
<h3>0x03 应对策略</h3>
<ul>
<li>
<p><strong>模拟ajax请求获取数据</strong>
首先用Firebug或者HttpFox对网络请求进行分析。如果能够找到ajax请求，也能分析出具体的参数和响应的具体含义，我们就能采用上面的方法，直接利用requests或者urllib2模拟ajax请求，对响应的json进行分析得到需要的数据。</p>
</li>
<li>
<p><strong>调用浏览器内核模拟正常人的交互</strong>
通过selenium+phantomJS框架，调用浏览器内核，并利用phantomJS执行js来模拟人为操作以及触发页面中的js脚本。从填写表单到点击按钮再到滚动页面，全部都可以模拟，不考虑具体的请求和响应过程，只是完完整整的把人浏览页面获取数据的过程模拟一遍。用这套框架几乎能绕过大多数的反爬虫，因为它不是在伪装成浏览器来获取数据（上述的通过添加Headers一定程度上就是为了伪装成浏览器），它本身就是浏览器，phantomJS就是一个没有界面的浏览器，只是操控这个浏览器的不是人。</p>
</li>
</ul>
<h3>0x04 其它反爬虫机制-Cookie限制</h3>
<ul>
<li><strong>Cookie限制</strong>
和Headers校验的反爬虫机制类似，当用户向目标网站发送请求时，会再请求数据中携带Cookie，网站通过校验请求信息是否存在Cookie，以及校验Cookie的值来判定发起访问请求的到底是真实的用户还是爬虫，第一次打开网页会生成一个随机cookie，如果再次打开网页这个Cookie不存在，那么再次设置，第三次打开仍然不存在，这就非常有可能是爬虫在工作了。</li>
<li><strong>Cookie校验和Headers的区别</strong>
用户发送的Headers的内容形式是固定的可以被轻易伪造的，Cookie则不然。原因是由于浏览器请求网站访问的过程中所分析得到的Cookie往往都是经过相关的js等过程已经改变了domain的Cookie，假如直接手动修改爬虫携带的Cookie去访问对应的网页，由于携带的Cookie已经是访问之后的domain而不是访问之前的domain，所以是无法成功模拟整个流程的，这种情况必然导致爬虫访问页面失败。</li>
</ul>
<h3>0x04 应对策略</h3>
<ul>
<li><strong>分析Cookie</strong>
分析Cookie，可能会携带大量的随机哈希字符串，或者不同时间戳组合的字符串，并且会根据每次访问更新domain的值。分析过程：首先要在对目标网站抓包分析时，必须先清空浏览器的Cookie，然后在初次访问时，观察浏览器在完成访问的过程中的请求细节（通常会在这一过程中发生若干次301/302转跳，每次转跳网站返回不同的Cookie给浏览器然后在最后一次转跳中请求成功）。在抓包完成对请求细节的分析之后，再在爬虫上模拟这一转跳过程，然后截取Cookie作为爬虫自身携带的Cookie，这样就能够绕过Cookie的限制完成对目标网站的访问了。</li>
</ul>
<h3>0x05 其它反爬虫机制-验证码限制</h3>
<ul>
<li>
<p>验证码（CAPTCHA）是“Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分计算机和人类的图灵测试）的缩写，是一种区分用户是计算机还是人的公共全自动程序。人类有着一种天赋，可以很轻松的从一段图片中识别出文字和数字，而机器却不能。</p>
</li>
<li>
<p><strong>数字字母验证码</strong>
这类验证码优点是生成简单，大部分语言都自带图形库，在加入一点扭曲和噪点，基本可以解决掉初级爬虫工程师和暴力破解的脚本小子。缺点当然也显而易见，对于cnn代码只用写10行的今天，这些验证码只要有足够的标注数据，破解起来简直是轻而易举。</p>
</li>
<li>
<p><strong>中文验证码</strong>
比如知乎采用过的验证码选择倒立的中文以及网易邮箱类的验证码（标记文字位置）。这类验证码一般来很少有公用的代码，因此编写起来麻烦。不过也正因为每一家采用的都不一样，在加上中文庞大的汉字库，确实给机器识别带来的比较大的挑战，如果配合好字体和扭曲，确实可以有不错的效果。</p>
</li>
<li>
<p><strong>极验验证</strong>
极验的v2版验证体系破解难度甚至比不过数字字母验证码来的复杂，唯一的优势就是现在大部分打码平台不支持。图片识别上直接对比像素就可以识别位置，唯一难点的移动轨迹，但用轨迹做分类人类和机器间的特征并不那么明显，加上网页中采集轨迹的准确性较差，因此做一些简单的模拟就可以轻松躲过轨迹识别。</p>
</li>
<li>
<p><strong>其它验证类型</strong>
比如12306这类图片验证，这种反爬虫要求较高，需要强大的图片库。其它还有算术验证、成语验证等等，发爬虫通过难度不是很高。</p>
</li>
</ul>
<h3>0x05 应对策略</h3>
<ul>
<li>
<p><strong>打码平台</strong>
最常用，最简单的识别，一般字母文字1分一次，中文识别略贵，计算题可能5分，不支持极验这类。</p>
</li>
<li>
<p><strong>OCR库</strong>
传统的ocr采用先切割再识别的方案，对于新型的验证码已经很难做了。</p>
</li>
<li>
<p><strong>机器学习</strong>
端到端数字字母识别神器，根据识别难度和长度不同，对标注数据的需求量不一样，当然图片预处理也稍微有些区别。一般简单常见的识别可以直接从网上找代码。</p>
</li>
</ul>
<h1>参考文档</h1>
<ul>
<li><a href="https://www.jianshu.com/p/80e25cb1d81a" target="_blank" rel="external">关于HTTP协议，一篇就够了</a></li>
<li><a href="https://blog.csdn.net/u012662731/article/details/78537432" target="_blank" rel="external">Python3网络爬虫快速入门实战解析</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1032918" target="_blank" rel="external">反爬虫机制和破解方法汇总</a></li>
<li><a href="http://bigsec.com/bigsec-news/anan-16825-Antireptile-zonghe" target="_blank" rel="external">反爬虫思路与解决办法</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/21/Other/并行计算 cuda/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/21/Other/并行计算 cuda/" itemprop="url">并行计算 cuda</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-21T20:46:53+08:00">
                2018-06-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3>并行计算 cuda</h3>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/34587739" target="_blank" rel="external">CUDA编程入门极简教程</a></li>
<li><a href="https://blog.csdn.net/dcrmg/article/details/54867507" target="_blank" rel="external">CUDA软件架构</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/21/Other/并行计算 openmp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/21/Other/并行计算 openmp/" itemprop="url">并行计算 OpenMP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-21T00:19:16+08:00">
                2018-06-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3>并行计算 OpenMP</h3>
<ul>
<li><a href="https://wdxtub.com/2016/03/20/openmp-guide/" target="_blank" rel="external">OpenMP 入门指南</a></li>
<li><a href="http://www.rswiki.org/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/openmp/openmp%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B" target="_blank" rel="external">openmp简明教程</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/15/C++/C++ STL equal_range lower_bound upper_bound函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/15/C++/C++ STL equal_range lower_bound upper_bound函数/" itemprop="url">C++ STL equal_range lower_bound upper_bound函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-15T11:03:07+08:00">
                2018-06-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>//所有容器适用<code>(O(log(n)))</code>    已序区间查找算法</p>
<p><code>lower_bound()</code>        //找第一个符合的元素，返回位置迭代器,返回val出现的第一个位置</p>
<p><code>upper_bound()</code>        //找最后一个符合的元素，返回位置迭代器，返回Val出现的最后一个位置的下一个位置</p>
<p><code>equal_range()</code>       //找一对迭代器pair(&lt;&gt;,&lt;&gt;)，等效于lower_bound()和upper_bound().关联式容器有等效的成员函数，性能更佳</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span>  </span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </div><div class="line">  </div><div class="line"><span class="comment">/************************************************************************************* </span></div><div class="line">std::lower_bound                 所有排序容器适用                           algorithm </div><div class="line">-------------------------------------------------------------------------------------- </div><div class="line">template &lt;class ForwardIterator, class T&gt; </div><div class="line">  ForwardIterator lower_bound ( ForwardIterator first, ForwardIterator last, </div><div class="line">                                const T&amp; value ); </div><div class="line"> </div><div class="line">template &lt;class ForwardIterator, class T, class Compare&gt; </div><div class="line">  ForwardIterator lower_bound ( ForwardIterator first, ForwardIterator last, </div><div class="line">                                const T&amp; value, Compare comp ); </div><div class="line"> </div><div class="line">//eg： </div><div class="line">template &lt;class ForwardIterator, class T&gt; </div><div class="line">  ForwardIterator lower_bound ( ForwardIterator first, ForwardIterator last, const T&amp; value ) </div><div class="line">&#123; </div><div class="line">  ForwardIterator it; </div><div class="line">  iterator_traits&lt;ForwardIterator&gt;::difference_type count, step; </div><div class="line">  count = distance(first,last); </div><div class="line">  while (count&gt;0) </div><div class="line">  &#123; </div><div class="line">    it = first; step=count/2; advance (it,step); </div><div class="line">    if (*it&lt;value)          // or: if (comp(*it,value)), for the comp version </div><div class="line">      &#123; first=++it; count-=step+1;  &#125; </div><div class="line">    else count=step; </div><div class="line">  &#125; </div><div class="line">  return first; </div><div class="line">&#125; </div><div class="line">*************************************************************************************/  </div><div class="line">  </div><div class="line">  </div><div class="line"><span class="comment">/************************************************************************************* </span></div><div class="line">std::upper_bound                  所有排序容器适用                           algorithm </div><div class="line">-------------------------------------------------------------------------------------- </div><div class="line">template &lt;class ForwardIterator, class T&gt; </div><div class="line">  ForwardIterator upper_bound ( ForwardIterator first, ForwardIterator last, </div><div class="line">                                const T&amp; value ); </div><div class="line"> </div><div class="line">template &lt;class ForwardIterator, class T, class Compare&gt; </div><div class="line">  ForwardIterator upper_bound ( ForwardIterator first, ForwardIterator last, </div><div class="line">                                const T&amp; value, Compare comp ); </div><div class="line"> </div><div class="line">//eg： </div><div class="line">template &lt;class ForwardIterator, class T&gt; </div><div class="line">  ForwardIterator upper_bound ( ForwardIterator first, ForwardIterator last, const T&amp; value ) </div><div class="line">&#123; </div><div class="line">  ForwardIterator it; </div><div class="line">  iterator_traits&lt;ForwardIterator&gt;::difference_type count, step; </div><div class="line">  count = distance(first,last); </div><div class="line">  while (count&gt;0) </div><div class="line">  &#123; </div><div class="line">    it = first; step=count/2; advance (it,step); </div><div class="line">    if (!(value&lt;*it))                 // or: if (!comp(value,*it)), for the comp version </div><div class="line">      &#123; first=++it; count-=step+1;  &#125; </div><div class="line">    else count=step; </div><div class="line">  &#125; </div><div class="line">  return first; </div><div class="line">&#125; </div><div class="line">*************************************************************************************/  </div><div class="line">  </div><div class="line"><span class="comment">/************************************************************************************* </span></div><div class="line">std::equal_range                  所有排序容器适用                           algorithm </div><div class="line">-------------------------------------------------------------------------------------- </div><div class="line">template &lt;class ForwardIterator, class T&gt; </div><div class="line">  pair&lt;ForwardIterator,ForwardIterator&gt; </div><div class="line">    equal_range ( ForwardIterator first, ForwardIterator last, const T&amp; value ); </div><div class="line"> </div><div class="line">template &lt;class ForwardIterator, class T, class Compare&gt; </div><div class="line">  pair&lt;ForwardIterator,ForwardIterator&gt; </div><div class="line">    equal_range ( ForwardIterator first, ForwardIterator last, const T&amp; value, </div><div class="line">                  Compare comp ); </div><div class="line"> </div><div class="line">//eg： </div><div class="line">template &lt;class ForwardIterator, class T&gt; </div><div class="line">  pair&lt;ForwardIterator,ForwardIterator&gt; </div><div class="line">    equal_range ( ForwardIterator first, ForwardIterator last, const T&amp; value ) </div><div class="line">&#123; </div><div class="line">  ForwardIterator it = lower_bound (first,last,value); </div><div class="line">  return make_pair ( it, upper_bound(it,last,value) ); </div><div class="line">&#125; </div><div class="line">*************************************************************************************/  </div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mygreater</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123; <span class="keyword">return</span> (i&gt;j); &#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> myints[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">20</span>&#125;;  </div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(myints,myints+<span class="number">8</span>);           <span class="comment">// 10 20 30 30 20 10 10 20  </span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator low,up;  </div><div class="line">  </div><div class="line">    sort (v.begin(), v.end());                <span class="comment">// 10 10 10 20 20 20 30 30  </span></div><div class="line">  </div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"10 10 10 20 20 20 30 30\n"</span>;  </div><div class="line">  </div><div class="line">    low=lower_bound (v.begin(), v.end(), <span class="number">20</span>); <span class="comment">//          ^  </span></div><div class="line">    up= upper_bound (v.begin(), v.end(), <span class="number">20</span>); <span class="comment">//                   ^  </span></div><div class="line">  </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"20 lower_bound at position "</span> &lt;&lt; <span class="keyword">int</span>(low- v.begin()) + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;  </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"20 upper_bound at position "</span> &lt;&lt; <span class="keyword">int</span>(up - v.begin()) + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;  </div><div class="line">  </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </div><div class="line">  </div><div class="line">    <span class="comment">/**-------------------------------------------------------------------------------**/</span>  </div><div class="line">  </div><div class="line">    pair&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator&gt; bounds;  </div><div class="line">  </div><div class="line">    <span class="comment">// using default comparison:  </span></div><div class="line"><span class="comment">//  sort (v.begin(), v.end());                              // 10 10 10 20 20 20 30 30  </span></div><div class="line">    bounds=equal_range (v.begin(), v.end(), <span class="number">20</span>);            <span class="comment">//          ^        ^  </span></div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"10 10 10 20 20 20 30 30\n"</span>;  </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"20 bounds at positions "</span> &lt;&lt; <span class="keyword">int</span>(bounds.first - v.begin());  </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" and "</span> &lt;&lt; <span class="keyword">int</span>(bounds.second - v.begin()) &lt;&lt; <span class="built_in">endl</span>;  </div><div class="line">  </div><div class="line">    <span class="comment">// using "mygreater" as comp:  </span></div><div class="line">    sort (v.begin(), v.end(), mygreater);                   <span class="comment">// 30 30 20 20 20 10 10 10  </span></div><div class="line">    bounds=equal_range (v.begin(), v.end(), <span class="number">20</span>, mygreater); <span class="comment">//       ^        ^  </span></div><div class="line">  </div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"30 30 20 20 20 10 10 10"</span>&lt;&lt;<span class="built_in">endl</span>;  </div><div class="line">  </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"20 bounds at positions "</span> &lt;&lt; <span class="keyword">int</span>(bounds.first - v.begin());  </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" and "</span> &lt;&lt; <span class="keyword">int</span>(bounds.second - v.begin()) &lt;&lt; <span class="built_in">endl</span>;  </div><div class="line">  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="comment">/****** </span></div><div class="line">Output: </div><div class="line">    10 10 10 20 20 20 30 30 </div><div class="line">    20 lower_bound at position 4 </div><div class="line">    20 upper_bound at position 7 </div><div class="line"> </div><div class="line">    10 10 10 20 20 20 30 30 </div><div class="line">    bounds at positions 3 and 6 </div><div class="line"> </div><div class="line">    30 30 20 20 20 10 10 10 </div><div class="line">    bounds at positions 2 and 5 </div><div class="line"> </div><div class="line">*/</div></pre></td></tr></table></figure>
<p>比较好的代码样例：</p>
<ul>
<li><a href="https://blog.csdn.net/flushhip/article/details/79416715" target="_blank" rel="external">今日头条2018校园招聘后端开发工程师(第二批)编程题 - 题解</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sort_cmp</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;A, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;B)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> A.first == B.first ? A.second &lt; B.second :</div><div class="line">        A.first &lt; B.first;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> find_first_cmp &#123;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;P, <span class="keyword">int</span> k)</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> P.first &lt; k;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;P)</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> k &lt; P.first;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> find_second_cmp &#123;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;P, <span class="keyword">int</span> k)</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> P.second &lt; k;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;P)</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> k &lt; P.second;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n, q;</div><div class="line">    <span class="keyword">while</span> (EOF != <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; arr;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; n; <span class="built_in">cin</span> &gt;&gt; x, arr.emplace_back(x, ++i)) &#123;&#125;</div><div class="line">        sort(arr.begin(), arr.end(), sort_cmp);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q); q--;) &#123;</div><div class="line">            <span class="keyword">int</span> L, R, k;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;L, &amp;R, &amp;k);</div><div class="line">            pair&lt;<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;::iterator, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;::iterator&gt; sd =</div><div class="line">                equal_range(arr.begin(), arr.end(), k, find_first_cmp&#123;&#125;);</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, upper_bound(sd.first, sd.second, R, find_second_cmp&#123;&#125;) -</div><div class="line">                lower_bound(sd.first, sd.second, L, find_second_cmp&#123;&#125;));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/20/Major/进程线程异同点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/20/Major/进程线程异同点/" itemprop="url">进程线程异同点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-20T11:05:39+08:00">
                2018-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3>归纳进程线程的相同点</h3>
<ul>
<li>无论是进程还是线程，都是用来实现多任务并发的技术手段；</li>
<li>二者都可以独立调度，因此在多任务环境下，功能上并无差异；</li>
<li>二者都具有各自的实体，是系统独立管理的对象个体。所以在系统层面，都可以通过技术手段实现二者的控制；</li>
<li>二者所具有的状态都非常相似；</li>
<li>在多任务程序中，子进程(子线程)的调度一般与父进程(父线程)平等竞争。</li>
</ul>
<h3>归纳进程线程的不同点</h3>
<h4>基本概念角度</h4>
<ul>
<li>进程是资源分配的基本单位，线程是调度的基本单位。</li>
</ul>
<h4>系统实现角度</h4>
<ul>
<li>进程的实现是调用fork系统调用；线程的实现是调用clone系统调用。</li>
</ul>
<p>|  进程原语	|线程原语 	      |描述|
|:-|:-|:-|
|  fork	    |pthread_create   |创建新的控制流|
|  exit	    |pthread_exit	  |从现有的控制流退出|
|  waitpid	|pthread_join	  |从控制流中得到退出状态|
|  aexit	|pthread_clean_push|注册在退出控制流时执行的函数|
|  getpid	|pthread_self	  |获得控制流ID|
|  abort	|pthread_cancel	  |请求控制流的非正常退出|</p>
<h4>实体间(进程间，线程间，进线程间)通信方式的不同</h4>
<ul>
<li>进程间的通信方式有这样几种：A.共享内存 B.消息队列 C.信号量 D.有名管道   E.无名管道 F.信号 G.文件 H.socket</li>
<li>线程间的通信方式上述进程间的方式都可沿用，且还有自己独特的几种：A.互斥量      B.自旋锁 C.条件变量  D.读写锁  E.线程信号 G.全局变量</li>
<li>值得注意的是，线程间通信用的信号不能采用进程间的信号，因为信号是基于进程为单位的，而线程是共属于同一进程空间的。故而要采用线程信号。综上，进程间通信手段有8种。线程间通信手段有13种。</li>
<li>进程间采用的通信方式要么需要切换内核上下文，要么要与外设访问(有名管道，文件)。所以速度会比较慢。而线程采用自己特有的通信方式的话，基本都在自己的进程空间内完成，不存在切换，所以通信速度会较快。也就是说，进程间与线程间分别采用的通信方式，除了种类的区别外，还有速度上的区别。</li>
</ul>
<h4>个体间辈分关系的迥异</h4>
<ul>
<li>进程的备份关系森严，在父进程没有结束前，所有的子进程都尊从父子关系，也就是说A创建了B，则A与B是父子关系，B又创建了C，则B与C也是父子关系，A与C构成爷孙关系，也就是说C是A的孙子进程。在系统上使用pstree命令打印进程树，可以清晰看到辈分关系。</li>
<li>多线程间的关系没有那么严格，不管是父线程还是子线程创建了新的线程，都是共享父线程的资源，所以，都可以说是父线程的子线程，也就是只存在一个父线程，其余线程都是父线程的子线程。</li>
</ul>
<h4>其他方面</h4>
<ul>
<li>可靠性：进程间不会互相影响；一个线程挂掉将导致整个进程挂掉。</li>
<li>分布式：进程适应于多核、多机分布式，如果一台机器不够，扩展到多台机器比较简单；线程适应于多核分布式。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/29/C++/C++ STL emplace_back 和 push_back 的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/29/C++/C++ STL emplace_back 和 push_back 的区别/" itemprop="url">C++ STL emplace_back 和 push_back 的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-29T19:44:38+08:00">
                2018-03-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3>emplace_back 和 push_back 的区别</h3>
<ul>
<li><a href="https://blog.csdn.net/xiaolewennofollow/article/details/52559364" target="_blank" rel="external">emplace_back 和 push_back 的区别</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/29/C++/C++ 奇奇怪怪的题目之构造析构顺序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/29/C++/C++ 奇奇怪怪的题目之构造析构顺序/" itemprop="url">C++ 奇奇怪怪的题目之构造析构顺序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-29T19:44:38+08:00">
                2018-03-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3>C++ 奇奇怪怪的题目之构造析构顺序</h3>
<ul>
<li><a href="http://gaocegege.com/Blog/cpp/cppclass" target="_blank" rel="external">C++ 奇奇怪怪的题目之构造析构顺序</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/29/C++/C++ 11 左值，右值，左值引用，右值引用，std move, std foward/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/29/C++/C++ 11 左值，右值，左值引用，右值引用，std move, std foward/" itemprop="url">C++ 11 左值，右值，左值引用，右值引用，std::move, std::foward</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-29T19:44:38+08:00">
                2018-03-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3>C++ 11 左值，右值，左值引用，右值引用，std::move, std::foward</h3>
<ul>
<li><a href="https://blog.csdn.net/xiaolewennofollow/article/details/52559306" target="_blank" rel="external">C++ 11 左值，右值，左值引用，右值引用，std::move, std::foward</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/29/C++/C++ STL源码学习 lower_bound和upper_bound算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/29/C++/C++ STL源码学习 lower_bound和upper_bound算法/" itemprop="url">C++ STL源码学习 lower_bound和upper_bound算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-29T19:44:38+08:00">
                2018-03-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3>C++ STL源码学习 lower_bound和upper_bound算法</h3>
<ul>
<li><a href="https://www.cnblogs.com/cobbliu/archive/2012/05/21/2512249.html" target="_blank" rel="external">C++ STL源码学习 lower_bound和upper_bound算法</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/23/Review/其它知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/23/Review/其它知识/" itemprop="url">其它知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-23T00:07:24+08:00">
                2018-03-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>其它知识</h2>
<h3>怎么实现多服务器负载均衡</h3>
<ul>
<li><a href="http://lobert.iteye.com/blog/2159970" target="_blank" rel="external">六大Web负载均衡原理与实现</a></li>
<li><a href="http://blog.jobbole.com/97957/" target="_blank" rel="external">负载均衡详解</a></li>
<li><a href="https://juejin.im/entry/5aac6ae55188252c321970e5" target="_blank" rel="external">分布式面试题（含解答）</a></li>
<li><a href="https://blog.csdn.net/FlushHip/article/details/79562199" target="_blank" rel="external">今日头条2018校招测试开发方向(第一、二、三、四批)编程题汇总</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/23/Review/数据库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/23/Review/数据库/" itemprop="url">数据库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-23T00:07:20+08:00">
                2018-03-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>数据库</h2>
<h3>count(*)，count(1)与count(column)区别</h3>
<ul>
<li><a href="http://blog.csdn.net/lzm18064126848/article/details/50491956" target="_blank" rel="external">count(*)，count(1)与count(column)区别</a></li>
<li><a href="https://www.jianshu.com/p/394f8aa724f4" target="_blank" rel="external">SQL的主键和外键的作用</a></li>
<li><a href="http://blog.csdn.net/wushuang5566110/article/details/8069997" target="_blank" rel="external">主键约束和唯一性约束的区别</a></li>
<li><a href="http://blog.csdn.net/suifeng3051/article/details/52669644" target="_blank" rel="external">数据库索引原理及优化</a></li>
<li><a href="http://www.runoob.com/mysql/mysql-index.html" target="_blank" rel="external">MySQL 索引</a></li>
</ul>
<p>数据库的引擎以及区别</p>
<p>数据库事务的特性、4个隔离级别</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/23/Review/设计实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/23/Review/设计实现/" itemprop="url">设计实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-23T00:07:14+08:00">
                2018-03-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>设计实现</h2>
<h3>设计并实现一个LRU Cache</h3>
<ul>
<li><a href="https://songlee24.github.io/2015/05/10/design-LRU-Cache/" target="_blank" rel="external">设计并实现一个LRU Cache</a></li>
</ul>
<h3>请简述智能指针原理，并实现一个简单的智能指针</h3>
<ul>
<li><a href="https://www.nowcoder.com/ta/nine-chapter/review?page=6" target="_blank" rel="external">参考答案</a></li>
<li><a href="http://www.cnblogs.com/QG-whz/p/4777312.html" target="_blank" rel="external">C++ 引用计数技术及智能指针的简单实现</a></li>
<li><a href="http://www.cnblogs.com/lanxuezaipiao/p/4132096.html" target="_blank" rel="external">C++智能指针简单剖析</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> SmartPointer;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> Counter &#123;</div><div class="line">		<span class="keyword">friend</span> <span class="keyword">class</span> SmartPointer&lt;T&gt;;</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		T* ptr;</div><div class="line">		<span class="keyword">int</span> cnt;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		Counter() &#123;</div><div class="line">			ptr = <span class="literal">NULL</span>;</div><div class="line">			cnt = <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		Counter(T* p) &#123;</div><div class="line">			ptr = p;</div><div class="line">			cnt = <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		~Counter() &#123;</div><div class="line">			<span class="keyword">delete</span> ptr;</div><div class="line">		&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> SmartPointer &#123;</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		Counter* ptr_counter;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		SmartPointer(T* p) &#123;</div><div class="line">			ptr_counter = <span class="keyword">new</span> Counter(p);</div><div class="line">		&#125;</div><div class="line">		SmartPointer(<span class="keyword">const</span> SmartPointer &amp;sp) &#123;</div><div class="line">			ptr_counter = sp.ptr_counter;</div><div class="line">			++ptr_count-&gt;cnt;</div><div class="line">		&#125;</div><div class="line">		SmartPointer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPointer &amp;sp) &#123;</div><div class="line">			++sp.ptr_counter-&gt;cnt;</div><div class="line">			--ptr_counter-&gt;cnt;</div><div class="line">			<span class="keyword">if</span> (ptr_counter-&gt;cnt == <span class="number">0</span>) &#123;</div><div class="line">				<span class="keyword">delete</span> ptr_counter;</div><div class="line">			&#125;</div><div class="line">			ptr_counter = sp.ptr_counter;</div><div class="line">		&#125;</div><div class="line">		~SmartPointer() &#123;</div><div class="line">			--ptr_counter-&gt;cnt;</div><div class="line">			<span class="keyword">if</span> (ptr_counter-&gt;cnt == <span class="number">0</span>) &#123;</div><div class="line">				<span class="keyword">delete</span> ptr_counter;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3>实现一个Memcpy函数</h3>
<ul>
<li><a href="https://my.oschina.net/renhc/blog/36345" target="_blank" rel="external">实现memcpy函数</a>（代码较好，基本正确）</li>
<li><a href="https://www.nowcoder.com/questionTerminal/9602083ec8d749999d86adf8a725b4f7" target="_blank" rel="external">实现一个Memcpy函数</a>（评论中有一个按照int 字节拷贝，效率提升，值得借鉴。）</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/23/Review/海量数据处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/23/Review/海量数据处理/" itemprop="url">海量数据处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-23T00:07:02+08:00">
                2018-03-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>海量数据处理</h2>
<h3>海量数据处理</h3>
<ul>
<li><a href="https://github.com/nonstriater/Learn-Algorithms/blob/master/Algorithms%20Job%20Interview/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.md" target="_blank" rel="external">海量数据处理</a></li>
<li><a href="http://blog.csdn.net/v_july_v/article/details/6279498" target="_blank" rel="external">海量数据处理方法总结</a></li>
<li><a href="https://segmentfault.com/a/1190000000510258" target="_blank" rel="external">海量数据处理之经典实例分析</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/23/Review/网络编程及知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/23/Review/网络编程及知识/" itemprop="url">网络编程及知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-23T00:06:58+08:00">
                2018-03-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>网络编程</h2>
<h3>select、poll和epoll编程</h3>
<ul>
<li>linux内核源码分析epoll的实现</li>
<li><a href="https://segmentfault.com/a/1190000004909797#articleHeader25" target="_blank" rel="external">I/O并发编程总结</a></li>
<li><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="external">Linux IO模式及 select、poll、epoll详解</a></li>
</ul>
<h3>select、poll和epoll问题</h3>
<ol>
<li>阻塞读数据（不用epoll），你说读到一半有新消息又来了怎么办？</li>
<li>非阻塞读数据（不用epoll），你说读到一半有新消息又来了怎么办？</li>
<li>epoll的ET模式时,如果数据只读了一半,也就是缓冲区的数据只读了一点,然后又来新事件了怎么办？</li>
</ol>
<ul>
<li><a href="https://blog.csdn.net/PROGRAM_anywhere/article/details/71408708" target="_blank" rel="external">epoll读到一半又有新事件来了怎么办？</a></li>
<li><a href="http://www.voidcn.com/article/p-kxwjnibc-bmd.html" target="_blank" rel="external">EPOLLONESHOT事件</a></li>
</ul>
<h3>socket编程对应三次握手四次挥手</h3>
<h3>Linux相关cpu内存网络相关指令</h3>
<hr>
<h2>网络知识</h2>
<h3>TCP三次握手与四次挥手</h3>
<ul>
<li><a href="http://www.cnblogs.com/kesal/p/3285415.html" target="_blank" rel="external">TCP\IP三次握手连接，四次握手断开分析</a></li>
<li><a href="http://www.cnblogs.com/tonyluis/p/5729531.html" target="_blank" rel="external">TCP三次握手与四次挥手</a></li>
<li><a href="http://www.cnblogs.com/newwy/p/3234536.html" target="_blank" rel="external">TCP连接的建立与终止</a></li>
</ul>
<h3>TCP三次握手，最后一次ACK包可以携带数据吗？有什么东西控制吗？什么时候携带数据？</h3>
<ul>
<li>RFC793文档里带有SYN标志的过程包是不可以携带数据的，也就是说三次握手的前两次是不可以携带数据的（逻辑上看，连接还没建立，携带数据好像也有点说不过去）。TCP协议建立连接的三次握手过程中的第三次握手允许携带数据。</li>
<li><a href="http://0xffffff.org/2015/04/15/36-The-TCP-three-way-handshake-with-data/" target="_blank" rel="external">TCP连接建立的三次握手过程可以携带数据吗？</a></li>
</ul>
<h3>TCP四次挥手，为什么要有TIME_WAIT？如果有大量的TIME_WAIT怎么解决？</h3>
<ul>
<li>原因一：保证TCP协议的全双工连接能够可靠关闭</li>
<li>原因二：保证这次连接的重复数据段从网络中消失</li>
<li>第一点，如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。</li>
<li>第二点，如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</li>
<li><a href="http://www.cnblogs.com/Jessy/p/3535612.html" target="_blank" rel="external">更多了解</a></li>
</ul>
<h3>http状态码及报文格式</h3>
<ul>
<li><a href="http://www.runoob.com/http/http-status-codes.html" target="_blank" rel="external">HTTP 教程</a></li>
</ul>
<h3>http和https的区别</h3>
<ul>
<li><a href="https://juejin.im/entry/58d7635e5c497d0057fae036" target="_blank" rel="external">详细解析 HTTP 与 HTTPS 的区别</a></li>
</ul>
<h3>微信扫一扫登录电脑界面的机制</h3>
<ul>
<li><a href="http://blog.csdn.net/qq_25827845/article/details/78823861" target="_blank" rel="external">微信扫码登录原理解析</a></li>
</ul>
<h3>断点续传</h3>
<ul>
<li><a href="https://my.oschina.net/ososchina/blog/371468" target="_blank" rel="external">Http 206 文件断点续传下载原理</a></li>
<li><a href="http://blog.csdn.net/liang19890820/article/details/53215087" target="_blank" rel="external">HTTP 断点续传（分块传输）</a></li>
</ul>
<h3>TCP和UDP的区别</h3>
<ul>
<li><a href="https://blog.csdn.net/lzuacm/article/details/50945225" target="_blank" rel="external">网络面试题：TCP和UDP的9个区别是什么</a></li>
<li><a href="https://blog.csdn.net/qq_18425655/article/details/51955674" target="_blank" rel="external">面试题：TCP协议与UDP协议的区别</a></li>
</ul>
<h3>TCP和UDP应用协议范围</h3>
<p><img src="https://i.imgur.com/AUHCePc.png" alt="TCP和UDP应用协议范围"></p>
<h3>运行在TCP协议上的协议：</h3>
<ul>
<li>HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。</li>
<li>HTTPS（Hypertext Transfer Protocol over Secure Socket Layer, or HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。</li>
<li>FTP（File Transfer Protocol，文件传输协议），由名知义，用于文件传输。</li>
<li>POP3（Post Office Protocol, version 3，邮局协议），收邮件用。</li>
<li>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。</li>
<li>TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。</li>
<li>SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。</li>
</ul>
<h3>运行在UDP协议上的协议：</h3>
<ul>
<li>BOOTP（Boot Protocol，启动协议），应用于无盘设备。</li>
<li>NTP（Network Time Protocol，网络时间协议），用于网络同步。</li>
<li>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。</li>
<li>其他：</li>
<li>DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作（运行在TCP和UDP协议上）。</li>
<li>ECHO（Echo Protocol，回绕协议），用于查错及测量应答时间（运行在TCP和UDP协议上）。</li>
<li>SNMP（Simple Network Management Protocol，简单网络管理协议），用于网络信息的收集和网络管理。</li>
<li>ARP（Address Resolution Protocol，地址解析协议），用于动态解析以太网硬件的地址。</li>
</ul>
<h3>TCP/IP协议栈中协议的层级：</h3>
<p>|层次|层名|name|协议|
|:-|:-|:-|:-|
|7	|应用层   |application layer	|例如HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP|
|6	|表示层   |presentation layer	|例如XDR、ASN.1、SMB、AFP、NCP|
|5	|会话层   |session layer	|例如ASAP、SSH、ISO 8327 / CCITT X.225、RPC、NetBIOS、ASP、IGMP、Winsock、BSD sockets|
|4	|传输层   |transport layer	|例如TCP、UDP、TLS、RTP、SCTP、SPX、ATP、IL|
|3	|网络层   |network layer	|例如IP、ICMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、X.25|
|2	|数据链路层 |data link layer	|例如以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP|
|1	|物理层   |physical layer	|例如线路、无线电、光纤|</p>
<h3>流量控制原理</h3>
<ul>
<li>目的是接收方通过TCP头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。</li>
<li>TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。</li>
<li>发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。</li>
<li>接收窗：用来标记可以接收的数据大小。</li>
<li>TCP是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中发送窗 = 已发送未确认部分 + 未发但可发送部分。接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 = 未接收但准备接收部分。</li>
<li>发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口。</li>
</ul>
<h3>拥塞控制原理</h3>
<ul>
<li>拥塞控制目的是防止数据被过多注网络中导致网络资源（路由器、交换机等）过载。因为拥塞控制涉及网络链路全局，所以属于全局控制。控制拥塞使用拥塞窗口。</li>
<li>TCP拥塞控制算法：</li>
<li>慢开始 &amp; 拥塞避免：先试探网络拥塞程度再逐渐增大拥塞窗口。每次收到确认后拥塞窗口翻倍，直到达到阀值ssthresh，这部分是慢开始过程。达到阀值后每次以一个MSS为单位增长拥塞窗口大小，当发生拥塞（超时未收到确认），将阀值减为原先一半，继续执行线性增加，这个过程为拥塞避免。</li>
<li>快速重传 &amp; 快速恢复：略。</li>
<li>最终拥塞窗口会收敛于稳定值。</li>
</ul>
<h3>如何区分流量控制和拥塞控制</h3>
<ul>
<li>流量控制属于通信双方协商；拥塞控制涉及通信链路全局。</li>
<li>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。</li>
<li>实际最终发送窗口 = min{流控发送窗口，拥塞窗口}。</li>
</ul>
<h3>TCP如何提供可靠数据传输</h3>
<ul>
<li>建立连接（标志位）：通信前确认通信实体存在。</li>
<li>序号机制（序号、确认号）：确保了数据是按序、完整到达。</li>
<li>数据校验（校验和）：CRC校验全部数据。</li>
<li>超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。</li>
<li>窗口机制（窗口）：提供流量控制，避免过量发送。</li>
<li>拥塞控制：同上。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/23/Review/数据结构和算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/23/Review/数据结构和算法/" itemprop="url">数据结构和算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-23T00:06:53+08:00">
                2018-03-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>数据结构和算法</h2>
<h3>完美二叉树、完全二叉树、完满二叉树</h3>
<ul>
<li><a href="http://www.cnblogs.com/idorax/p/6441043.html" target="_blank" rel="external">完美二叉树、完全二叉树、完满二叉树</a></li>
</ul>
<h3>平衡二叉树、B树、B+树、B*树基本概念</h3>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/27700617" target="_blank" rel="external">平衡二叉树、B树、B+树、B*树</a></li>
<li><a href="https://blog.csdn.net/v_JULY_v/article/details/6530142/" target="_blank" rel="external">从B树、B+树、B*树谈到R 树</a></li>
</ul>
<h3>红黑树概念</h3>
<ul>
<li><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md" target="_blank" rel="external">教你透彻了解红黑树</a></li>
</ul>
<h3>二叉查找树，红黑树，AVL树，B/B+树，伸展树——优缺点及比较</h3>
<ul>
<li><a href="https://blog.csdn.net/bytxl/article/details/40920165" target="_blank" rel="external">二叉查找树，红黑树，AVL树，B/B+树，伸展树——优缺点及比较</a></li>
</ul>
<h3>AVL树，红黑树，B树，B+树，Trie树应用场景</h3>
<ul>
<li><a href="https://www.zhihu.com/question/30527705" target="_blank" rel="external">AVL树，红黑树，B树，B+树，Trie树应用场景</a></li>
</ul>
<h3>B树和B+树区别？</h3>
<p>一颗m阶的B+树和m阶的B_树的差异在于：</p>
<ol>
<li>有n棵子树的结点中含有n个关键字；(而B树是n棵子树有n-1个关键字)</li>
<li>所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。(而B树的叶子节点并没有包括全部需要查找的信息)</li>
<li>所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B树的非终节点也包含需要查找的有效信息)</li>
</ol>
<h3>为什么说B+树比B树更适合操作系统的文件索引和数据库索引？</h3>
<ol>
<li>
<p>B+-tree的磁盘读写代价更低
B+-tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。
也可以考虑直接将非叶子节点索引结构读入内存，速度快很多。</p>
</li>
<li>
<p>B+-tree的查询效率更加稳定
由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。</p>
</li>
</ol>
<h3>100亿个整数，内存足够，如何找到中位数？内存不足，如何找到中位数？</h3>
<ul>
<li><a href="https://www.nowcoder.com/ta/nine-chapter/review?page=5" target="_blank" rel="external">参考答案</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/23/Review/操作系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/23/Review/操作系统/" itemprop="url">操作系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-23T00:06:47+08:00">
                2018-03-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>进程线程</h2>
<h3>Linux进程间通讯方式及编程知识</h3>
<ul>
<li>见文档linux-ipc.pdf及相应demo程序</li>
</ul>
<h3>进程线程异同点</h3>
<ul>
<li>见文档G-linux-thread.pdf及相应demo程序</li>
<li><a href="https://baijiazm.github.io/2018/05/20/Major/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%BC%82%E5%90%8C%E7%82%B9/" target="_blank" rel="external">进程线程异同点</a></li>
</ul>
<h3>Linux多线程pthread编程知识</h3>
<ul>
<li><a href="https://blog.csdn.net/ithomer/article/details/5920936" target="_blank" rel="external">linux多线程pthread</a></li>
</ul>
<h3>进程线程面试题总结</h3>
<ul>
<li><a href="https://blog.csdn.net/wujiafei_njgcxy/article/details/77098977" target="_blank" rel="external">进程线程面试题总结</a></li>
</ul>
<h3>多个进程同时写共享内存，如何防止内容乱？</h3>
<ul>
<li><a href="http://zhangxiaoya.github.io/2015/05/15/multi-thread-of-c-program-language-on-linux/" target="_blank" rel="external">Linux 下多线程</a></li>
</ul>
<h3>多线程访问共享内存的不加锁实现方式</h3>
<ul>
<li><a href="http://blog.csdn.net/ywh147/article/details/8675532" target="_blank" rel="external">多线程访问共享内存的不加锁实现方式</a></li>
</ul>
<hr>
<h2>IO/磁盘/内存</h2>
<h3>同步和异步、阻塞与非阻塞</h3>
<ul>
<li><a href="https://segmentfault.com/a/1190000004909797#articleHeader25" target="_blank" rel="external">I/O并发编程总结</a></li>
<li><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="external">Linux IO模式及 select、poll、epoll详解</a></li>
</ul>
<h3>共享内存两种机制</h3>
<ul>
<li>共享内存可以通过 mmap()映射普通文件（特殊情况下还可以采用匿名映射）机制实现， 也可以通过 System V 共享内存机制实现。</li>
<li>mmap 的机制：在磁盘上建立一个文件，每个进程存储器里面，单独开辟一个空间来进行映射。mmap 保存到实际硬盘。优点：储存量可以很大（多于主存）；缺点：进程间读 取和写入速度要比主存的要慢。</li>
<li>shm 的机制：每个进程的共享内存都直接映射到实际物理存储器里面。shm 保存到物理存储器（主存），实际的储存量直接反映到主存上。优点，进程间访问速度（读写）比磁 盘要快；缺点，储存量不能非常大（多于主存） 。</li>
<li>使用上看：如果分配的存储量不大，那么使用 shm；如果存储量大，那么使用 mmap。</li>
</ul>
<h3>使用mmap读写文件为什么比普通读写函数要快？</h3>
<ul>
<li><a href="http://blog.csdn.net/kai8wei/article/details/77980201" target="_blank" rel="external">mmap为什么比read/write快</a></li>
</ul>
<h3>Linux共享内存实现及具体步骤</h3>
<h3>Linux的磁盘管理</h3>
<hr>
<h2>调度及死锁</h2>
<h3>产生死锁的条件</h3>
<ul>
<li>互斥条件（Mutualexclusion）：资源不能被共享，只能由一个进程使用。</li>
<li>请求与保持条件（Hold andwait）：已经得到资源的进程可以再次申请新的资源。</li>
<li>非剥夺条件（Nopre-emption）：已经分配的资源不能从相应的进程中被强制地剥夺。</li>
<li>循环等待条件（ Circularwait ）：系统中若干进程组成环路，该环路中每个进程都在等待相 邻进程正占用的资源。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/23/Review/编程语言C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/23/Review/编程语言C++/" itemprop="url">编程语言C++</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-23T00:06:43+08:00">
                2018-03-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>编程语言C++</h2>
<h3>类的大小</h3>
<ul>
<li><a href="http://glgjing.github.io/blog/2015/03/23/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:lei-de-da-xiao/" target="_blank" rel="external">深度探索C++对象模型：类的大小</a></li>
<li><a href="http://blog.csdn.net/u010921682/article/details/43529305" target="_blank" rel="external">C++ 空类的大小及相关继承类的大小</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//以下测试环境为GCC 32bit-Release模式</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A &#123;&#125;;</div><div class="line"><span class="keyword">class</span> B &#123;&#125;;</div><div class="line"><span class="keyword">class</span> C : <span class="keyword">public</span> A &#123;</div><div class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">c_fun</span><span class="params">()</span></span>=<span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(A):"</span>&lt;&lt;<span class="keyword">sizeof</span>(A)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(B):"</span>&lt;&lt;<span class="keyword">sizeof</span>(B)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(C):"</span>&lt;&lt;<span class="keyword">sizeof</span>(C)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(D):"</span>&lt;&lt;<span class="keyword">sizeof</span>(D)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 结果为： 1	1	4	4</div><div class="line"> * 最后一个可能与编译器有关，可能8</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		<span class="keyword">int</span> data;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B &#123;</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		<span class="keyword">int</span> data;</div><div class="line">		<span class="keyword">static</span> <span class="keyword">int</span> data1;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">int</span> B::data1=<span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">//注：void main()会编译报错</span></div><div class="line">main() &#123;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(A) = "</span>&lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(B) = "</span>&lt;&lt; <span class="keyword">sizeof</span>(B) &lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 结果为： 4	4</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		A(<span class="keyword">int</span> a) &#123;</div><div class="line">			a=x;</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">		~A() &#123;&#125;</div><div class="line"></div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		<span class="keyword">int</span> x;</div><div class="line">		<span class="keyword">int</span> g;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> B &#123;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		<span class="keyword">int</span> data;</div><div class="line">		<span class="keyword">int</span> data2;</div><div class="line">		<span class="keyword">static</span> <span class="keyword">int</span> xs;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">int</span> B::xs=<span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="function">A <span class="title">s</span><span class="params">(<span class="number">10</span>)</span></span>;</div><div class="line">	s.f(<span class="number">10</span>);</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(a): "</span>&lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(b): "</span>&lt;&lt; <span class="keyword">sizeof</span>(B) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 结果为： 8	8</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> X &#123;&#125;;</div><div class="line"><span class="keyword">class</span> Y : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;</div><div class="line"><span class="keyword">class</span> Z : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;</div><div class="line"><span class="keyword">class</span> A : <span class="keyword">public</span> Y, <span class="keyword">public</span> Z &#123;&#125;;</div><div class="line"><span class="comment">// 上述为经典的钻石继承</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(X): "</span> &lt;&lt; <span class="keyword">sizeof</span>(X) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Y): "</span> &lt;&lt; <span class="keyword">sizeof</span>(Y) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Z): "</span> &lt;&lt; <span class="keyword">sizeof</span>(Z) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(A): "</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 结果为： 1	4	4	8</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> X &#123;</div><div class="line">		<span class="keyword">int</span> a;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> Y : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;</div><div class="line"><span class="keyword">class</span> Z : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;</div><div class="line"><span class="keyword">class</span> A : <span class="keyword">public</span> Y, <span class="keyword">public</span> Z &#123;&#125;;</div><div class="line"><span class="comment">// 上述为经典的钻石继承</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(X): "</span> &lt;&lt; <span class="keyword">sizeof</span>(X) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Y): "</span> &lt;&lt; <span class="keyword">sizeof</span>(Y) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Z): "</span> &lt;&lt; <span class="keyword">sizeof</span>(Z) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(A): "</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 结果为： 4	8	8	12</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> X &#123;</div><div class="line">		<span class="keyword">int</span> a;</div><div class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>=<span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> Y : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;</div><div class="line"><span class="keyword">class</span> Z : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;</div><div class="line"><span class="keyword">class</span> A : <span class="keyword">public</span> Y, <span class="keyword">public</span> Z &#123;&#125;;</div><div class="line"><span class="comment">// 上述为经典的钻石继承</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(X): "</span> &lt;&lt; <span class="keyword">sizeof</span>(X) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Y): "</span> &lt;&lt; <span class="keyword">sizeof</span>(Y) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Z): "</span> &lt;&lt; <span class="keyword">sizeof</span>(Z) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(A): "</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 结果为： 8	12	12	16</div><div class="line"> */</div></pre></td></tr></table></figure>
<h3>C/C++内存对齐</h3>
<ul>
<li><a href="https://songlee24.github.io/2014/09/20/memory-alignment/" target="_blank" rel="external">C/C++内存对齐</a></li>
<li><a href="http://blog.csdn.net/yusiguyuan/article/details/44564333" target="_blank" rel="external">C语言的字节对齐</a></li>
</ul>
<h3>C++空类占用一字节</h3>
<ul>
<li><a href="http://blog.csdn.net/xiong452980729/article/details/71077144" target="_blank" rel="external">C++中空类占一字节原因详解</a></li>
</ul>
<h3>结构体大小</h3>
<ul>
<li><a href="https://baijiazm.github.io/2018/03/05/Review/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/" target="_blank" rel="external">C语言的字节对齐</a></li>
</ul>
<p>注意：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> A &#123;</div><div class="line">	<span class="keyword">char</span> a;</div><div class="line">	<span class="keyword">char</span> b;</div><div class="line">	<span class="keyword">char</span> c;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>A的大小是3,结构体中每个成员的起始地址是<code>min(成员类型大小,pack)</code>的整数倍，整个结构体大小是最大成员大小的整数倍。</p>
<h3>C++虚函数作用及底层实现原理</h3>
<ul>
<li><a href="https://www.cnblogs.com/malecrab/p/5572730.html" target="_blank" rel="external">C/C++杂记：虚函数的实现的基本原理</a></li>
<li><a href="https://www.cnblogs.com/jiayayao/p/6279483.html" target="_blank" rel="external">C++虚函数实现多态原理</a></li>
</ul>
<h3>C++中虚继承的作用及底层实现原理</h3>
<ul>
<li>虚继承用于解决多继承条件下的菱形继承问题，底层实现原理与编译器相关，一般通过虚基类指针实现，即各对象中只保存一份父类的对象，多继承时通过虚基类指针引用该公共对象，从而避免菱形继承中的二义性问题。</li>
<li><a href="http://www.oschina.net/translate/cpp-virtual-inheritance" target="_blank" rel="external">C++ 多继承和虚继承的内存布局</a></li>
</ul>
<h3>Struct和Class的区别</h3>
<ul>
<li><a href="http://blog.csdn.net/yuliu0552/article/details/6717915" target="_blank" rel="external">Struct和Class的区别</a></li>
</ul>
<h3>C++中包含哪几种强制类型转换？他们有什么区别和联系？</h3>
<p><a href="https://www.nowcoder.com/ta/nine-chapter/review?page=19" target="_blank" rel="external">牛客网链接</a>
<a href="http://blog.jobbole.com/107033/" target="_blank" rel="external">C++ 的强制类型转换</a></p>
<h3>请简述智能指针原理，并实现一个简单的智能指针</h3>
<ul>
<li><a href="https://www.nowcoder.com/ta/nine-chapter/review?page=6" target="_blank" rel="external">参考答案</a></li>
<li><a href="http://www.cnblogs.com/QG-whz/p/4777312.html" target="_blank" rel="external">C++ 引用计数技术及智能指针的简单实现</a></li>
<li><a href="http://www.cnblogs.com/lanxuezaipiao/p/4132096.html" target="_blank" rel="external">C++智能指针简单剖析</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> SmartPointer;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> Counter &#123;</div><div class="line">		<span class="keyword">friend</span> <span class="keyword">class</span> SmartPointer&lt;T&gt;;</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		T* ptr;</div><div class="line">		<span class="keyword">int</span> cnt;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		Counter() &#123;</div><div class="line">			ptr = <span class="literal">NULL</span>;</div><div class="line">			cnt = <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		Counter(T* p) &#123;</div><div class="line">			ptr = p;</div><div class="line">			cnt = <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		~Counter() &#123;</div><div class="line">			<span class="keyword">delete</span> ptr;</div><div class="line">		&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> SmartPointer &#123;</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		Counter* ptr_counter;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		SmartPointer(T* p) &#123;</div><div class="line">			ptr_counter = <span class="keyword">new</span> Counter(p);</div><div class="line">		&#125;</div><div class="line">		SmartPointer(<span class="keyword">const</span> SmartPointer &amp;sp) &#123;</div><div class="line">			ptr_counter = sp.ptr_counter;</div><div class="line">			++ptr_count-&gt;cnt;</div><div class="line">		&#125;</div><div class="line">		SmartPointer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPointer &amp;sp) &#123;</div><div class="line">			++sp.ptr_counter-&gt;cnt;</div><div class="line">			--ptr_counter-&gt;cnt;</div><div class="line">			<span class="keyword">if</span> (ptr_counter-&gt;cnt == <span class="number">0</span>) &#123;</div><div class="line">				<span class="keyword">delete</span> ptr_counter;</div><div class="line">			&#125;</div><div class="line">			ptr_counter = sp.ptr_counter;</div><div class="line">		&#125;</div><div class="line">		~SmartPointer() &#123;</div><div class="line">			--ptr_counter-&gt;cnt;</div><div class="line">			<span class="keyword">if</span> (ptr_counter-&gt;cnt == <span class="number">0</span>) &#123;</div><div class="line">				<span class="keyword">delete</span> ptr_counter;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<hr>
<h2>Part2</h2>
<h3>内联函数、构造函数、静态成员函数可以是虚函数吗？</h3>
<ul>
<li>都不可以。内联函数需要在编译阶段展开，而虚函数是运行时动态绑定的，编译时无法展开； 构造函数在进行调用时还不存在父类和子类的概念，父类只会调用父类的构造函数，子类调用子类的，因此不存在动态绑定的概念；静态成员函数是以类为单位的函数，与具体对象无关，虚函数是与对象动态绑定的，因此是两个不冲突的概念；</li>
</ul>
<h3>构造函数中可以调用虚函数吗？</h3>
<ul>
<li>可以，但是没有动态绑定的效果，父类构造函数中调用的仍然是父类版本的函数，子类中调用的仍然是子类版本的函数</li>
<li>样例错题5</li>
</ul>
<h3>虚函数不能是内联函数</h3>
<ul>
<li>虚函数不能是内联函数（编译时展开，必须有实体），不能是静态函数（属于自身类，不属于对象，而虚函数要求有实体），不能是构造函数（尚未建立虚函数表）。</li>
</ul>
<h3>C++中成员函数能够同时用static和const进行修饰？</h3>
<ul>
<li>否，因为static表⽰示该函数为静态成员函数，为类所有；而const是用于修饰成员函数的，两者相矛盾。<code>[Error] static member function 'static void Test::fun()' cannot have cv-qualifier</code></li>
</ul>
<h3>C++ 内联函数</h3>
<ul>
<li><a href="http://www.cnblogs.com/QG-whz/p/4641479.html" target="_blank" rel="external">C++ 内联函数</a></li>
</ul>
<h3>C/C++参数传递顺序</h3>
<ul>
<li><a href="http://blog.sina.com.cn/s/blog_5ed3e6210100ceiu.html" target="_blank" rel="external">C或C++为什么被设计成是从右向左处理参数?</a></li>
</ul>
<h3>volatile有什么作用？</h3>
<ul>
<li>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。</li>
<li>多线程中被几个任务共享的变量需要定义为volatile类型。</li>
</ul>
<h3>delete和delete[]区别？</h3>
<ul>
<li>delete只会调用一次析构函数。</li>
<li>delete[]会调用数组中每个元素的析构函数。</li>
</ul>
<h3>面向对象三大特性？</h3>
<ul>
<li>封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问。</li>
<li>继承性：让某种类型对象获得另一个类型对象的属性和方法。</li>
<li>多态性：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）。</li>
</ul>
<h3>构造函数能否为虚函数，析构函数呢？</h3>
<ul>
<li>析构函数：
<ul>
<li>析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。</li>
<li>只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。</li>
<li>析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。</li>
</ul>
</li>
<li>构造函数：
<ul>
<li>构造函数不能定义为虚函数，不仅如此，构造函数中还不能调用虚函数。因为那样实际执行的是父类对应的函数，因为自己还没有构造好（构造顺序先基类再派生类）。</li>
</ul>
</li>
</ul>
<h3>C语言0长度数组(可变数组/柔性数组)</h3>
<ul>
<li><a href="https://blog.csdn.net/gatieme/article/details/64131322" target="_blank" rel="external">C语言0长度数组(可变数组/柔性数组)详解</a></li>
</ul>
<h3>有哪几种情况只能用intialization list而不能用assignment？</h3>
<ul>
<li>当类中含有const成员变量；基类无默认构造函数时，有参的构造函数都需要初始化表；当类中含有reference成员变量。</li>
</ul>
<h3>关于const int* 和int const *及int * const</h3>
<ul>
<li><a href="https://blog.csdn.net/Eric_Jo/article/details/4138548" target="_blank" rel="external">关于C++ const 的全面总结</a></li>
</ul>
<hr>
<h2>Part3</h2>
<h3>static作用是什么？在C和C++中有何区别？</h3>
<ul>
<li>static可以修饰局部变量（静态局部变量）、全局变量（静态全局变量）和函数，被修饰的变量存储位置在静态区。对于静态局部变量，相对于一般局部变量其生命周期长，直到程序运行结束而非函数调用结束，且只在第一次被调用时定义；对于静态全局变量，相对于全局变量其可见范围被缩小，只能在本文件中可见；修饰函数时作用和修饰全局变量相同，都是为了限定访问域。</li>
<li>C++的static除了上述两种用途，还可以修饰类成员（静态成员变量和静态成员函数），静态成员变量和静态成员函数不属于任何一个对象，是所有类实例所共有。</li>
<li>static的数据记忆性可以满足函数在不同调用期的通信，也可以满足同一个类的多个实例间的通信。</li>
<li>未初始化时，static变量默认值为0。</li>
</ul>
<h3>malloc和new的区别？</h3>
<ul>
<li>malloc和free是标准库函数，支持覆盖；new和delete是运算符，并且支持重载。</li>
<li>malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。</li>
<li>malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。</li>
</ul>
<h3>指针和引用区别？</h3>
<ul>
<li>引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，需要占用存储空间。</li>
<li>引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &amp;varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。</li>
<li>引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。</li>
<li>不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。</li>
</ul>
<h3>构造函数调用顺序，析构函数呢？</h3>
<ul>
<li>基类的构造函数：如果有多个基类，先调用纵向上最上层基类构造函数，如果横向继承了多个类，调用顺序为派生表从左到右顺序。</li>
<li>成员类对象的构造函数：如果类的变量中包含其他类（类的组合），需要在调用本类构造函数前先调用成员类对象的构造函数，调用顺序遵照在类中被声明的顺序。</li>
<li>派生类的构造函数。</li>
<li>析构函数与之相反。</li>
</ul>
<h3>虚函数和纯虚函数区别？</h3>
<ul>
<li>虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。</li>
<li>纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。</li>
</ul>
<h3>覆盖、重载和隐藏的区别？</h3>
<ul>
<li>覆盖是派生类中重新定义的函数，其函数名、参数列表（个数、类型和顺序）、返回值类型和父类完全相同，只有函数体有区别。派生类虽然继承了基类的同名函数，但用派生类对象调用该函数时会根据对象类型调用相应的函数。覆盖只能发生在类的成员函数中。</li>
<li>隐藏是指派生类函数屏蔽了与其同名的函数，这里仅要求基类和派生类函数同名即可。其他状态同覆盖。可以说隐藏比覆盖涵盖的范围更宽泛，毕竟参数不加限定。</li>
<li>重载是具有相同函数名但参数列表不同（个数、类型或顺序）的两个函数（不关心返回值），当调用函数时根据传递的参数列表来确定具体调用哪个函数。重载可以是同一个类的成员函数也可以是类外函数。</li>
</ul>
<h3>在main执行之前执行的代码可能是什么？</h3>
<ul>
<li>全局对象的构造函数。</li>
</ul>
<h3>构造函数和析构函数调用时机？</h3>
<ul>
<li>全局范围中的对象：构造函数在所有函数调用之前执行，在主函数执行完调用析构函数。</li>
<li>局部自动对象：建立对象时调用构造函数，函数结束时调用析构函数。</li>
<li>动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数。</li>
<li>静态局部变量对象：建立时调用一次构造函数，主函数结束时调用析构函数。</li>
</ul>
<hr>
<h3>错题1</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">题目：</div><div class="line">    在C++中，</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> *j = (<span class="keyword">int</span> *) &amp;i;</div><div class="line">    *j = <span class="number">1</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %d"</span>, i, *j);</div><div class="line">    输出是多少？</div><div class="line"></div><div class="line">答案:</div><div class="line">    <span class="number">0</span></div><div class="line">    <span class="number">1</span></div><div class="line"></div><div class="line">解答:</div><div class="line">    考察C++常量折叠。</div><div class="line">    <span class="number">1.</span> <span class="keyword">const</span>变量放在编译器的符号表中，计算时编译器直接从表中取值，省去了访问内存的时间，从而达到了优化。</div><div class="line">    <span class="number">2.</span> 结论，<span class="keyword">const</span>变量通过取地址方式可以修改该地址存储的数据值，但不能修改常量的值。</div></pre></td></tr></table></figure>
<h3>错题2</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">题目：</div><div class="line">    假设在一个<span class="number">32</span>位little endian的机器上运行下面的程序，结果是多少？</div><div class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a, b, c);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">答案:</div><div class="line">    <span class="number">1</span></div><div class="line">    <span class="number">0</span></div><div class="line">    <span class="number">2</span></div><div class="line"></div><div class="line">解答:</div><div class="line">    考察小端法及<span class="built_in">printf</span>输出控制符。</div><div class="line">    <span class="number">1.</span> <span class="keyword">long</span> <span class="keyword">long</span>占<span class="number">8</span>字节。</div><div class="line">    <span class="number">2.</span> 小端表示，低字节在低位，最低<span class="number">4</span>字节为<span class="number">1</span>，接下来四字节为高位部分的<span class="number">0</span>，再接下来<span class="number">4</span>字节为第二个数低位的<span class="number">2</span>。</div><div class="line">    <span class="number">3.</span> <span class="built_in">printf</span>的控制符相当于分配好待打印容器大小，这里<span class="string">"%d %d %d"</span>就分配了<span class="number">12</span>字节，分别装入三个<span class="number">8</span>字节元素，只装入一半。</div><div class="line">    <span class="number">4.</span> 换为<span class="built_in">cout</span>为<span class="number">1</span> <span class="number">2</span> <span class="number">3</span></div></pre></td></tr></table></figure>
<h3>错题3</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">题目：</div><div class="line">    请选择下列程序的运行结果:</div><div class="line">    <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line">    <span class="keyword">class</span> B0&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"B0::display0"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">class</span> B1:<span class="keyword">public</span> B0&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"B1::display0"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">class</span> D1: <span class="keyword">public</span> B1&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"D1::display0"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(B0 ptr)</span></span>&#123;</div><div class="line">        ptr.display();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">        B0 b0;</div><div class="line">        B1 b1;</div><div class="line">        D1 d1;</div><div class="line">        fun(b0);</div><div class="line">        fun(b1);</div><div class="line">        fun(d1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">答案:</div><div class="line">    B0::display0</div><div class="line">    B0::display0</div><div class="line">    B0::display0</div><div class="line">解答:</div><div class="line">    <span class="number">1.</span> 这里传递的是对象本身而非指针，对象被直接转为基类对象，调用基类的函数。</div><div class="line">    <span class="number">2.</span> 如果要实现虚函数动态绑定需要将B0 ptr改为B0* ptr，ptr-&gt;display()。</div><div class="line">    <span class="number">3.</span> 对象的形参传递需要先使用拷贝构造函数（默认）生成B0类型的临时变量，只拷贝基类部分数据（只有指向基类虚函数表的虚函数指针，赋值兼容规则）。</div></pre></td></tr></table></figure>
<h3>错题4</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">题目：</div><div class="line">    下面代码输出什么：</div><div class="line">    <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span>&#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> a = <span class="number">6</span>;</div><div class="line">        <span class="keyword">int</span> b = <span class="number">-20</span>;</div><div class="line">        (a + b &gt; <span class="number">6</span>) ? <span class="built_in">printf</span>(<span class="string">"&gt;6"</span>) : <span class="built_in">printf</span>(<span class="string">"&lt;=6"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">答案:</div><div class="line">    &gt;<span class="number">6</span></div><div class="line"></div><div class="line">解答:</div><div class="line">    考察强制类型转换。</div><div class="line">    <span class="number">1.</span> 必须先明确：<span class="keyword">int</span>与<span class="keyword">unsigned</span>相加，<span class="keyword">int</span> -&gt; <span class="keyword">unsigned</span> <span class="keyword">int</span>。</div><div class="line">    <span class="number">2.</span> <span class="keyword">int</span> b = <span class="number">-20</span>，首位位<span class="string">"1"</span>，用无符号型表示是非常大的正整数。</div></pre></td></tr></table></figure>
<h3>错题5</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">题目：</div><div class="line">    <span class="keyword">class</span> Base&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        Base()&#123;</div><div class="line">            Init();</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"Base Init\n"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"Base func\n"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">class</span> Derived: <span class="keyword">public</span> Base&#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"Derived Init\n"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"Derived func\n"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">        Derived d;</div><div class="line">        ((Base *)&amp;d)-&gt;func();</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">答案：</div><div class="line">    Base Init</div><div class="line">    Base func</div><div class="line"></div><div class="line">解答：</div><div class="line">    考察虚函数。</div><div class="line">    <span class="number">1.</span> 类Derived继承自Base，先调用基类构造函数Base()，再调用基类的init()，输出Base Init。</div><div class="line">        构造子类对象，基类中不会调用子类的虚函数：</div><div class="line">            基类构造函数 -&gt; 子类构造函数</div><div class="line">            子类还没有构造，还没有初始化，属于未初始化对象</div><div class="line">            基类不会去调用子类虚函数（哪怕子类中确实声明为虚函数）</div><div class="line">    <span class="number">2.</span> 虽然 ((Base *)&amp;d)-&gt;func()是虚函数调用的样子，但func()跟本没有被定义为虚函数，基类指针访问基类的func()。</div></pre></td></tr></table></figure>
<hr>
<h2>STL部分</h2>
<h3>STL中的迭代器失效问题</h3>
<ul>
<li><a href="https://blog.csdn.net/tian_110/article/details/43190627" target="_blank" rel="external">STL迭代器及迭代器失效问题</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/20/Linux/Linux RedHat 7.4 安装Docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/20/Linux/Linux RedHat 7.4 安装Docker/" itemprop="url">Linux RedHat 7.4 安装Docker</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-20T23:51:46+08:00">
                2018-03-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本来Linux下安装就比较简单，奈何在Linux RedHat 7.4下安装Docer去遇到了小小麻烦，记录一下，希望对以后遇到此问题的人有帮助。</p>
<h3>需要订阅时遇到问题</h3>
<p>[root@RHEL74-SVR ~]# yum -y install docker<br>
已加载插件：langpacks, product-id, search-disabled-repos, subscription-manager
This system is not registered with an entitlement server. You can use subscription-manager to register.<br>
没有可用软件包 docker。<br>
错误：无须任何处理</p>
<h3>Linux RedHat 7.4 安装Docker</h3>
<h4>操作系统版本：</h4>
<p>Red Hat Enterprise Linux Server release 7.4 (Maipo)</p>
<h4>添加yum源：</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">vi /etc/yum.repos.d/docker.repo</div><div class="line"></div><div class="line">[dockerrepo]</div><div class="line">name=Docker Repository</div><div class="line">baseurl=http://yum.dockerproject.org/repo/main/centos/7/</div><div class="line">enabled=1</div><div class="line">gpgcheck=0</div></pre></td></tr></table></figure>
<h4>安装：</h4>
<pre><code>yum install docker-engine -y
</code></pre>
<h4>启动Docker服务：</h4>
<pre><code>systemctl start docker
</code></pre>
<h4>检查是否安装成功：</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[root@RHEL74-SVR ~]# docker version</div><div class="line">Client:</div><div class="line"> Version:      17.05.0-ce</div><div class="line"> API version:  1.29</div><div class="line"> Go version:   go1.7.5</div><div class="line"> Git commit:   89658be</div><div class="line"> Built:        Thu May  4 22:06:25 2017</div><div class="line"> OS/Arch:      linux/amd64</div><div class="line"></div><div class="line">Server:</div><div class="line"> Version:      17.05.0-ce</div><div class="line"> API version:  1.29 (minimum version 1.12)</div><div class="line"> Go version:   go1.7.5</div><div class="line"> Git commit:   89658be</div><div class="line"> Built:        Thu May  4 22:06:25 2017</div><div class="line"> OS/Arch:      linux/amd64</div><div class="line"> Experimental: false</div></pre></td></tr></table></figure>
<h4>查看Docker容器总体状况：</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">[root@RHEL74-SVR ~]# docker info</div><div class="line">Containers: 0</div><div class="line"> Running: 0</div><div class="line"> Paused: 0</div><div class="line"> Stopped: 0</div><div class="line">Images: 0</div><div class="line">Server Version: 17.05.0-ce</div><div class="line">Storage Driver: overlay</div><div class="line"> Backing Filesystem: xfs</div><div class="line"> Supports d_type: true</div><div class="line">Logging Driver: json-file</div><div class="line">Cgroup Driver: cgroupfs</div><div class="line">Plugins: </div><div class="line"> Volume: local</div><div class="line"> Network: bridge host macvlan null overlay</div><div class="line">Swarm: inactive</div><div class="line">Runtimes: runc</div><div class="line">Default Runtime: runc</div><div class="line">Init Binary: docker-init</div><div class="line">containerd version: 9048e5e50717ea4497b757314bad98ea3763c145</div><div class="line">runc version: 9c2d8d184e5da67c95d601382adf14862e4f2228</div><div class="line">init version: 949e6fa</div><div class="line">Security Options:</div><div class="line"> seccomp</div><div class="line">  Profile: default</div><div class="line">Kernel Version: 3.10.0-693.el7.x86_64</div><div class="line">Operating System: Red Hat Enterprise Linux Server 7.4 (Maipo)</div><div class="line">OSType: linux</div><div class="line">Architecture: x86_64</div><div class="line">CPUs: 4</div><div class="line">Total Memory: 976.3MiB</div><div class="line">Name: RHEL74-SVR</div><div class="line">ID: F3ES:DCYT:B6HM:Z5DG:GEWD:PJ2O:2GPW:K44O:M2OU:GOXQ:NYLY:YEVM</div><div class="line">Docker Root Dir: /var/lib/docker</div><div class="line">Debug Mode (client): false</div><div class="line">Debug Mode (server): false</div><div class="line">Registry: https://index.docker.io/v1/</div><div class="line">Experimental: false</div><div class="line">Insecure Registries:</div><div class="line"> 127.0.0.0/8</div><div class="line">Live Restore Enabled: false</div></pre></td></tr></table></figure>
<h4>设置开机自动启动：</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#默认是非开机自启的</div><div class="line">systemctl disabled docker</div><div class="line"></div><div class="line">#设置开机启动</div><div class="line">systemctl enable docker</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/16/Linux/Linux 常用命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/16/Linux/Linux 常用命令/" itemprop="url">Linux 常用命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-16T16:08:00+08:00">
                2018-03-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/base/index.html" target="_blank" rel="external">Linux基础</a></li>
<li><a href="http://blog.csdn.net/a724888/article/details/68937153" target="_blank" rel="external">Linux面试常用命令</a></li>
<li><a href="http://blog.csdn.net/wuxinliulei/article/details/9158101" target="_blank" rel="external">linux常用命令</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/16/Linux/Linux 多线程 pthread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/16/Linux/Linux 多线程 pthread/" itemprop="url">Linux 多线程 pthread</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-16T10:24:52+08:00">
                2018-03-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><a href="http://www.runoob.com/cplusplus/cpp-multithreading.html" target="_blank" rel="external">C++ 多线程</a></li>
<li><a href="http://blog.csdn.net/ithomer/article/details/5920936" target="_blank" rel="external">linux多线程pthread</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/08/Review/BAT经典面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/08/Review/BAT经典面试题/" itemprop="url">BAT经典面试题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-08T19:33:08+08:00">
                2018-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5>简述C++虚函数作用及底层实现原理</h5>
<ul>
<li><a href="https://www.cnblogs.com/malecrab/p/5572730.html" target="_blank" rel="external">C/C++杂记：虚函数的实现的基本原理</a></li>
<li><a href="https://www.cnblogs.com/jiayayao/p/6279483.html" target="_blank" rel="external">C++虚函数实现多态原理</a></li>
</ul>
<h5>内联函数、构造函数、静态成员函数可以是虚函数吗？</h5>
<ul>
<li>都不可以。内联函数需要在编译阶段展开，而虚函数是运行时动态绑定的，编译时无法展开； 构造函数在进行调用时还不存在父类和子类的概念，父类只会调用父类的构造函数，子类调用子类的，因此不存在动态绑定的概念；静态成员函数是以类为单位的函数，与具体对象无关，虚函数是与对象动态绑定的，因此是两个不冲突的概念；</li>
</ul>
<h5>构造函数中可以调用虚函数吗？</h5>
<ul>
<li>可以，但是没有动态绑定的效果，父类构造函数中调用的仍然是父类版本的函数，子类中调用的仍然是子类版本的函数</li>
</ul>
<h5>简述C++中虚继承的作用及底层实现原理?</h5>
<ul>
<li>虚继承用于解决多继承条件下的菱形继承问题，底层实现原理与编译器相关，一般通过虚基类指针实现，即各对象中只保存一份父类的对象，多继承时通过虚基类指针引用该公共对象，从而避免菱形继承中的二义性问题。</li>
<li><a href="http://www.oschina.net/translate/cpp-virtual-inheritance" target="_blank" rel="external">C++ 多继承和虚继承的内存布局</a></li>
</ul>
<h5>C++空类占用一字节</h5>
<ul>
<li><a href="http://blog.csdn.net/xiong452980729/article/details/71077144" target="_blank" rel="external">C++中空类占一字节原因详解</a></li>
</ul>
<h5>结构体大小</h5>
<ul>
<li><a href="https://baijiazm.github.io/2018/03/05/Review/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/" target="_blank" rel="external">C语言的字节对齐</a></li>
</ul>
<p>注意：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> A &#123;</div><div class="line">	<span class="keyword">char</span> a;</div><div class="line">	<span class="keyword">char</span> b;</div><div class="line">	<span class="keyword">char</span> c;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>A的大小是3,结构体中每个成员的起始地址是<code>min(成员类型大小,pack)</code>的整数倍，整个结构体大小是最大成员大小的整数倍。</p>
<h5>Struct和Class的区别</h5>
<ul>
<li><a href="http://blog.csdn.net/yuliu0552/article/details/6717915" target="_blank" rel="external">Struct和Class的区别</a></li>
</ul>
<h5>C++中成员函数能够同时用static和const进行修饰？</h5>
<ul>
<li>否，因为static表⽰示该函数为静态成员函数，为类所有；而const是用于修饰成员函数的，两者相矛盾。<code>[Error] static member function 'static void Test::fun()' cannot have cv-qualifier</code></li>
</ul>
<h5>C++中包含哪几种强制类型转换？他们有什么区别和联系？</h5>
<p><a href="https://www.nowcoder.com/ta/nine-chapter/review?page=19" target="_blank" rel="external">参考答案</a>
<a href="http://blog.jobbole.com/107033/" target="_blank" rel="external">C++ 的强制类型转换</a></p>
<h5>简述Linux内存分配--伙伴系统 原理</h5>
<p>参考答案：伙伴系统，其思想是：把内存块分成不同的组(1,2,4,8,16,32....)；分配内存时找到能够满足条件 的最小的块；如果找不到，就找大的块，然后一分为2，分配一块，留一块；回收时：如果有相邻的同样大小的块，则合并</p>
<h5>使用mmap读写文件为什么比普通读写函数要快？</h5>
<ul>
<li><a href="http://blog.csdn.net/kai8wei/article/details/77980201" target="_blank" rel="external">mmap为什么比read/write快</a></li>
</ul>
<h5>实现一个Memcpy函数</h5>
<ul>
<li><a href="https://my.oschina.net/renhc/blog/36345" target="_blank" rel="external">实现memcpy函数</a>（代码较好，基本正确）</li>
<li><a href="https://www.nowcoder.com/questionTerminal/9602083ec8d749999d86adf8a725b4f7" target="_blank" rel="external">实现一个Memcpy函数</a>（评论中有一个按照int 字节拷贝，效率提升，值得借鉴。）</li>
</ul>
<h5>100亿个整数，内存足够，如何找到中位数？内存不足，如何找到中位数？</h5>
<ul>
<li><a href="https://www.nowcoder.com/ta/nine-chapter/review?page=5" target="_blank" rel="external">参考答案</a></li>
</ul>
<h5>设计并实现一个LRU Cache</h5>
<ul>
<li><a href="https://songlee24.github.io/2015/05/10/design-LRU-Cache/" target="_blank" rel="external">设计并实现一个LRU Cache</a></li>
</ul>
<h5>请简述智能指针原理，并实现一个简单的智能指针</h5>
<ul>
<li><a href="https://www.nowcoder.com/ta/nine-chapter/review?page=6" target="_blank" rel="external">参考答案</a></li>
<li><a href="http://www.cnblogs.com/QG-whz/p/4777312.html" target="_blank" rel="external">C++ 引用计数技术及智能指针的简单实现</a></li>
<li><a href="http://www.cnblogs.com/lanxuezaipiao/p/4132096.html" target="_blank" rel="external">C++智能指针简单剖析</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> SmartPointer;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> Counter &#123;</div><div class="line">		<span class="keyword">friend</span> <span class="keyword">class</span> SmartPointer&lt;T&gt;;</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		T* ptr;</div><div class="line">		<span class="keyword">int</span> cnt;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		Counter() &#123;</div><div class="line">			ptr = <span class="literal">NULL</span>;</div><div class="line">			cnt = <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		Counter(T* p) &#123;</div><div class="line">			ptr = p;</div><div class="line">			cnt = <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		~Counter() &#123;</div><div class="line">			<span class="keyword">delete</span> ptr;</div><div class="line">		&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> SmartPointer &#123;</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		Counter* ptr_counter;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		SmartPointer(T* p) &#123;</div><div class="line">			ptr_counter = <span class="keyword">new</span> Counter(p);</div><div class="line">		&#125;</div><div class="line">		SmartPointer(<span class="keyword">const</span> SmartPointer &amp;sp) &#123;</div><div class="line">			ptr_counter = sp.ptr_counter;</div><div class="line">			++ptr_count-&gt;cnt;</div><div class="line">		&#125;</div><div class="line">		SmartPointer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPointer &amp;sp) &#123;</div><div class="line">			++sp.ptr_counter-&gt;cnt;</div><div class="line">			--ptr_counter-&gt;cnt;</div><div class="line">			<span class="keyword">if</span> (ptr_counter-&gt;cnt == <span class="number">0</span>) &#123;</div><div class="line">				<span class="keyword">delete</span> ptr_counter;</div><div class="line">			&#125;</div><div class="line">			ptr_counter = sp.ptr_counter;</div><div class="line">		&#125;</div><div class="line">		~SmartPointer() &#123;</div><div class="line">			--ptr_counter-&gt;cnt;</div><div class="line">			<span class="keyword">if</span> (ptr_counter-&gt;cnt == <span class="number">0</span>) &#123;</div><div class="line">				<span class="keyword">delete</span> ptr_counter;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/07/C++/C++ STL优先队列 priority_queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/07/C++/C++ STL优先队列 priority_queue/" itemprop="url">C++ STL优先队列 priority_queue</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-07T11:25:52+08:00">
                2018-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>priority_queue模板声明带有三个参数:
<code>priority_queue&lt;Type, Container, Functional&gt;</code>
<code>Type</code> 为数据类型，
<code>Container</code> 为保存数据的容器，
<code>Functional</code> 为元素比较方式。
<code>Container</code> 必须是用数组实现的容器，比如 vector, deque 但不能用 list.
STL里面默认用的是 vector. 比较方式默认用 <code>operator&lt;</code> , 后面俩个参数缺省的话，优先队列就是大顶堆，队头元素最大。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;</div><div class="line">    <span class="keyword">class</span> T,</div><div class="line">    <span class="keyword">class</span> Container = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;,</div><div class="line">    <span class="keyword">class</span> Compare = <span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> Container::value_type&gt;</div><div class="line">&gt; <span class="keyword">class</span> priority_queue;</div></pre></td></tr></table></figure>
<p>可参考<a href="https://blog.csdn.net/maverick1990/article/details/22413441" target="_blank" rel="external">priority_queue的用法</a></p>
<h5>方法一</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//********************************方法一</span></div><div class="line"><span class="keyword">struct</span> Node &#123;</div><div class="line">	<span class="keyword">int</span> x,y;</div><div class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(Node a) <span class="keyword">const</span>  &#123;	<span class="comment">//必须加const</span></div><div class="line">		<span class="keyword">return</span> y &lt; a.y;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &gt;(Node a) <span class="keyword">const</span>  &#123;	<span class="comment">//必须加const</span></div><div class="line">		<span class="keyword">return</span> y &gt; a.y;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//	priority_queue&lt;Node&gt; A;   //默认	大根堆</span></div><div class="line">priority_queue&lt;Node, <span class="built_in">vector</span>&lt;Node&gt;, less&lt;Node&gt;&gt;A;	<span class="comment">//大根堆</span></div><div class="line">priority_queue&lt;Node, <span class="built_in">vector</span>&lt;Node&gt;, greater&lt;Node&gt; &gt; B;    <span class="comment">//小根堆</span></div></pre></td></tr></table></figure>
<h5>方法二</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//********************************方法二：</span></div><div class="line"><span class="keyword">struct</span> Node &#123;</div><div class="line">	<span class="keyword">int</span> x;</div><div class="line">	<span class="keyword">int</span> y;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b) &#123;</div><div class="line">	<span class="keyword">return</span> a.x&lt;b.x;			 <span class="comment">//大顶堆</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b) &#123;</div><div class="line">	<span class="keyword">return</span> a.x&gt;b.x;			<span class="comment">//小顶堆</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,less&lt;Node&gt; &gt; A;   	<span class="comment">//大根堆</span></div><div class="line">priority_queue&lt;Node, <span class="built_in">vector</span>&lt;Node&gt;, greater&lt;Node&gt; &gt; B;    <span class="comment">//小根堆</span></div></pre></td></tr></table></figure>
<h5>方法三（节点是指针时只能是此方法）</h5>
<p>非指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//********************************方法三：</span></div><div class="line"><span class="keyword">struct</span> Node &#123;</div><div class="line">	<span class="keyword">int</span> x;</div><div class="line">	<span class="keyword">int</span> y;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> cmp &#123;</div><div class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node a,Node b)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span>  a.x &gt; b.x;	<span class="comment">//小顶堆</span></div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> cmp1 &#123;</div><div class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node a,Node b)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span>  a.x &lt; b.x;	<span class="comment">//大顶堆</span></div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp1 &gt; A;   	<span class="comment">//大根堆</span></div><div class="line">priority_queue&lt;Node, <span class="built_in">vector</span>&lt;Node&gt;, cmp &gt; B;    <span class="comment">//小根堆</span></div></pre></td></tr></table></figure>
<p>指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Node &#123;</div><div class="line">	<span class="keyword">int</span> x;</div><div class="line">	<span class="keyword">int</span> y;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> cmp &#123;</div><div class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> Node*n1, <span class="keyword">const</span> Node *n2)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> n1-&gt;x&lt;n2-&gt;x;		<span class="comment">//大顶推</span></div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">struct</span> cmp1 &#123;</div><div class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> Node *n1, <span class="keyword">const</span> Node *n2)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> n1-&gt;x&gt;n2-&gt;x;		<span class="comment">//小顶推</span></div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">priority_queue&lt;Node*, <span class="built_in">vector</span>&lt;Node*&gt;, cmp &gt; A;	<span class="comment">//大根堆</span></div><div class="line">priority_queue&lt;Node*, <span class="built_in">vector</span>&lt;Node*&gt;, cmp1 &gt; B;  <span class="comment">//小根堆</span></div></pre></td></tr></table></figure>
<h5>统一测试</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">ostream &amp; <span class="keyword">operator</span> &lt;&lt;(ostream &amp;out,<span class="keyword">const</span> <span class="keyword">struct</span> Node&amp; n) &#123;</div><div class="line">	out&lt;&lt;<span class="string">"n.x="</span>&lt;&lt;n.x&lt;&lt;<span class="string">"    n.y="</span>&lt;&lt;n.y&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> out;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;Node&gt;tn= &#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">5</span>&#125;&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a:tn) &#123;</div><div class="line">		A.push(a);</div><div class="line">		B.push(a);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"A:"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">while</span>(!A.empty()) &#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;A.top();</div><div class="line">		A.pop();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"B:"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">while</span>(!B.empty()) &#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;B.top();</div><div class="line">		B.pop();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	test();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/06/C++/C++ inline 内联函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/06/C++/C++ inline 内联函数/" itemprop="url">C++ inline 内联函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-06T23:21:55+08:00">
                2018-03-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4>参考以下博文：</h4>
<ul>
<li><a href="http://www.cnblogs.com/QG-whz/p/4641479.html" target="_blank" rel="external">C++ 内联函数</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/05/C++/C、C++从右向左处理参数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/05/C++/C、C++从右向左处理参数/" itemprop="url">C、C++从右向左处理参数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-05T23:07:45+08:00">
                2018-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4>参考以下博文：</h4>
<ul>
<li><a href="http://blog.sina.com.cn/s/blog_5ed3e6210100ceiu.html" target="_blank" rel="external">C或C++为什么被设计成是从右向左处理参数?</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/05/C++/C语言的字节对齐/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/05/C++/C语言的字节对齐/" itemprop="url">C语言的字节对齐</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-05T11:00:19+08:00">
                2018-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4>参考以下博文：</h4>
<ul>
<li><a href="http://blog.csdn.net/yusiguyuan/article/details/44564333" target="_blank" rel="external">C语言的字节对齐</a></li>
<li><a href="https://songlee24.github.io/2014/09/20/memory-alignment/" target="_blank" rel="external">C/C++内存对齐</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/05/Major/TCP和UDP应用协议范围/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/05/Major/TCP和UDP应用协议范围/" itemprop="url">TCP和UDP应用协议范围</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-05T10:36:54+08:00">
                2018-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://i.imgur.com/AUHCePc.png" alt="TCP和UDP应用协议范围"></p>
<h4>运行在TCP协议上的协议：</h4>
<ul>
<li>HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。</li>
<li>HTTPS（Hypertext Transfer Protocol over Secure Socket Layer, or HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。</li>
<li>FTP（File Transfer Protocol，文件传输协议），由名知义，用于文件传输。</li>
<li>POP3（Post Office Protocol, version 3，邮局协议），收邮件用。</li>
<li>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。</li>
<li>TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。</li>
<li>SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。</li>
</ul>
<h4>运行在UDP协议上的协议：</h4>
<ul>
<li>BOOTP（Boot Protocol，启动协议），应用于无盘设备。</li>
<li>NTP（Network Time Protocol，网络时间协议），用于网络同步。</li>
<li>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。</li>
<li>其他：</li>
<li>DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作（运行在TCP和UDP协议上）。</li>
<li>ECHO（Echo Protocol，回绕协议），用于查错及测量应答时间（运行在TCP和UDP协议上）。</li>
<li>SNMP（Simple Network Management Protocol，简单网络管理协议），用于网络信息的收集和网络管理。</li>
<li>ARP（Address Resolution Protocol，地址解析协议），用于动态解析以太网硬件的地址。</li>
</ul>
<h4>TCP/IP协议栈中协议的层级：</h4>
<pre><code>7	应用层   application layer	例如HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP
6	表示层   presentation layer	例如XDR、ASN.1、SMB、AFP、NCP
5	会话层   session layer	例如ASAP、SSH、ISO 8327 / CCITT X.225、RPC、NetBIOS、ASP、IGMP、Winsock、BSD sockets
4	传输层   transport layer	例如TCP、UDP、TLS、RTP、SCTP、SPX、ATP、IL
3	网络层   network layer	例如IP、ICMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、X.25
2	数据链路层 data link layer	例如以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP
1	物理层   physical layer	例如线路、无线电、光纤</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/05/Major/mysql count 函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/05/Major/mysql count 函数/" itemprop="url">count(*)，count(1)与count(column)区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-05T10:11:25+08:00">
                2018-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4>参考以下博文：</h4>
<ul>
<li><a href="http://blog.csdn.net/lzm18064126848/article/details/50491956" target="_blank" rel="external">count(*)，count(1)与count(column)区别</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/05/C++/C++对象模型：类的大小/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/05/C++/C++对象模型：类的大小/" itemprop="url">C++对象模型：类的大小</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-05T09:23:49+08:00">
                2018-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4>参考以下博文：</h4>
<ul>
<li><a href="http://glgjing.github.io/blog/2015/03/23/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:lei-de-da-xiao/" target="_blank" rel="external">深度探索C++对象模型：类的大小</a></li>
<li><a href="http://blog.csdn.net/u010921682/article/details/43529305" target="_blank" rel="external">C++ 空类的大小及相关继承类的大小</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//以下测试环境为GCC 32bit-Release模式</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A &#123;&#125;;</div><div class="line"><span class="keyword">class</span> B &#123;&#125;;</div><div class="line"><span class="keyword">class</span> C : <span class="keyword">public</span> A &#123;</div><div class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">c_fun</span><span class="params">()</span></span>=<span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(A):"</span>&lt;&lt;<span class="keyword">sizeof</span>(A)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(B):"</span>&lt;&lt;<span class="keyword">sizeof</span>(B)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(C):"</span>&lt;&lt;<span class="keyword">sizeof</span>(C)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(D):"</span>&lt;&lt;<span class="keyword">sizeof</span>(D)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 结果为： 1	1	4	4</div><div class="line"> * 最后一个可能与编译器有关，可能8</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		<span class="keyword">int</span> data;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B &#123;</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		<span class="keyword">int</span> data;</div><div class="line">		<span class="keyword">static</span> <span class="keyword">int</span> data1;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">int</span> B::data1=<span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">//注：void main()会编译报错</span></div><div class="line">main() &#123;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(A) = "</span>&lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(B) = "</span>&lt;&lt; <span class="keyword">sizeof</span>(B) &lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 结果为： 4	4</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		A(<span class="keyword">int</span> a) &#123;</div><div class="line">			a=x;</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">		~A() &#123;&#125;</div><div class="line"></div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		<span class="keyword">int</span> x;</div><div class="line">		<span class="keyword">int</span> g;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> B &#123;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		<span class="keyword">int</span> data;</div><div class="line">		<span class="keyword">int</span> data2;</div><div class="line">		<span class="keyword">static</span> <span class="keyword">int</span> xs;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">int</span> B::xs=<span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="function">A <span class="title">s</span><span class="params">(<span class="number">10</span>)</span></span>;</div><div class="line">	s.f(<span class="number">10</span>);</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(a): "</span>&lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(b): "</span>&lt;&lt; <span class="keyword">sizeof</span>(B) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 结果为： 8	8</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> X &#123;&#125;;</div><div class="line"><span class="keyword">class</span> Y : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;</div><div class="line"><span class="keyword">class</span> Z : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;</div><div class="line"><span class="keyword">class</span> A : <span class="keyword">public</span> Y, <span class="keyword">public</span> Z &#123;&#125;;</div><div class="line"><span class="comment">// 上述为经典的钻石继承</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(X): "</span> &lt;&lt; <span class="keyword">sizeof</span>(X) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Y): "</span> &lt;&lt; <span class="keyword">sizeof</span>(Y) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Z): "</span> &lt;&lt; <span class="keyword">sizeof</span>(Z) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(A): "</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 结果为： 1	4	4	8</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> X &#123;</div><div class="line">		<span class="keyword">int</span> a;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> Y : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;</div><div class="line"><span class="keyword">class</span> Z : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;</div><div class="line"><span class="keyword">class</span> A : <span class="keyword">public</span> Y, <span class="keyword">public</span> Z &#123;&#125;;</div><div class="line"><span class="comment">// 上述为经典的钻石继承</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(X): "</span> &lt;&lt; <span class="keyword">sizeof</span>(X) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Y): "</span> &lt;&lt; <span class="keyword">sizeof</span>(Y) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Z): "</span> &lt;&lt; <span class="keyword">sizeof</span>(Z) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(A): "</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 结果为： 4	8	8	12</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> X &#123;</div><div class="line">		<span class="keyword">int</span> a;</div><div class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>=<span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> Y : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;</div><div class="line"><span class="keyword">class</span> Z : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;</div><div class="line"><span class="keyword">class</span> A : <span class="keyword">public</span> Y, <span class="keyword">public</span> Z &#123;&#125;;</div><div class="line"><span class="comment">// 上述为经典的钻石继承</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(X): "</span> &lt;&lt; <span class="keyword">sizeof</span>(X) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Y): "</span> &lt;&lt; <span class="keyword">sizeof</span>(Y) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Z): "</span> &lt;&lt; <span class="keyword">sizeof</span>(Z) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(A): "</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 结果为： 8	12	12	16</div><div class="line"> */</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/05/C++/C语言中的main写法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/05/C++/C语言中的main写法/" itemprop="url">C语言中的main写法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-05T09:08:10+08:00">
                2018-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4>参考以下博文：</h4>
<ul>
<li><a href="http://blog.csdn.net/kangjianwei101/article/details/50363359" target="_blank" rel="external">探寻main函数的标准写法，以及获取main函数的参数、返回值</a></li>
<li><a href="http://blog.csdn.net/piaojun_pj/article/details/5986516" target="_blank" rel="external">细谈C语言中的main返回值</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/04/Major/数据库索引、主键、约束/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/04/Major/数据库索引、主键、约束/" itemprop="url">数据库索引、主键、约束</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-04T14:50:17+08:00">
                2018-03-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4>参考以下博文：</h4>
<ul>
<li><a href="https://www.jianshu.com/p/394f8aa724f4" target="_blank" rel="external">SQL的主键和外键的作用</a></li>
<li><a href="http://blog.csdn.net/wushuang5566110/article/details/8069997" target="_blank" rel="external">主键约束和唯一性约束的区别</a></li>
<li><a href="http://blog.csdn.net/suifeng3051/article/details/52669644" target="_blank" rel="external">数据库索引原理及优化</a></li>
<li><a href="http://www.runoob.com/mysql/mysql-index.html" target="_blank" rel="external">MySQL 索引</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/04/Major/TCP三次握手与四次挥手分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/04/Major/TCP三次握手与四次挥手分析/" itemprop="url">TCP三次握手与四次挥手分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-04T14:50:17+08:00">
                2018-03-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4>参考以下博文：</h4>
<ul>
<li><a href="http://www.cnblogs.com/kesal/p/3285415.html" target="_blank" rel="external">TCP\IP三次握手连接，四次握手断开分析</a></li>
<li><a href="http://www.cnblogs.com/tonyluis/p/5729531.html" target="_blank" rel="external">TCP三次握手与四次挥手</a></li>
<li><a href="http://www.cnblogs.com/newwy/p/3234536.html" target="_blank" rel="external">TCP连接的建立与终止</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/22/C++/C++ 常见语法错误：cannot have cv-qualifier/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/22/C++/C++ 常见语法错误：cannot have cv-qualifier/" itemprop="url">C++ 常见语法错误：cannot have cv-qualifier</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-22T19:22:39+08:00">
                2018-02-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在C++中CV指const和volatile</p>
<ol>
<li>
<p>非成员函数不能有CV限定，友元函数不是类的成员函数声明友元函数不能用const限定。
friend voin fun(classname &amp;ref)const;
//编译器会给错误error: non-member function ‘xxxxxxxxx’ cannot have cv-qualifier</p>
</li>
<li>
<p>静态成员函数不能有CV限定</p>
</li>
</ol>
<h4>在C++中，非成员函数不能含有CV限定，即const和volatile限定</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">0.0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> arg,<span class="keyword">char</span> *argv[])</span> </span>&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; getArea() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译产生错误:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">test.cpp	[Error] non-member function 'double getArea()'</div><div class="line">cannot have cv-qualifier//不能有CV限定，非成员函数不能有cv限定符。</div></pre></td></tr></table></figure>
<h4>在C++中，静态成员函数不能有CV限定，即const和volatile限定</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> CStatic &#123;</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		<span class="keyword">static</span> <span class="keyword">int</span> static_value;</div><div class="line"></div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_static_value</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">		<span class="comment">//当不是static方法时，可以用const进行限定。</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> CStatic::get_static_value() <span class="keyword">const</span> &#123;</div><div class="line">	<span class="keyword">return</span> static_value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> CStatic::static_value = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> </span>&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; CStatic::get_static_value()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译出现的错误:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[Error] static member function 'static int CStatic::get_static_value()' </div><div class="line">cannot have cv-qualifier</div></pre></td></tr></table></figure>
<h4>友元函数同普通函数一样</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Animal &#123;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">showRes</span><span class="params">(Animal &amp;ref)</span><span class="keyword">const</span></span>;</div><div class="line">		<span class="comment">//这行编译器会给错误non-member function ‘void showRes(Animal&amp;)’</span></div><div class="line">		<span class="comment">//cannot have cv-qualifier</span></div><div class="line"></div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		<span class="keyword">int</span> age;</div><div class="line">		<span class="built_in">string</span> name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">showRes</span><span class="params">(Animal &amp;ref)</span> </span>&#123;</div><div class="line">	ref.age=<span class="number">15</span>;</div><div class="line">	ref.name=<span class="string">"panda"</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; ref.age &lt;&lt; ref.name &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译出现的错误:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[Error] non-member function 'void showRes(Animal&amp;)' cannot have cv-qualifier</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/10/Other/正则表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/10/Other/正则表达式/" itemprop="url">正则表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-10T23:55:41+08:00">
                2018-02-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>参考文档：</strong></p>
<ul>
<li><a href="http://www.regexlab.com/zh/regref.htm" target="_blank" rel="external">揭开正则表达式的神秘面纱</a></li>
</ul>
<h3>1. 正则表达式规则</h3>
<h4>1.1 普通字符</h4>
<p>字母、数字、汉字、下划线、以及后边章节中没有特殊定义的标点符号，都是&quot;普通字符&quot;。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。</p>
<p>举例1：表达式 &quot;c&quot;，在匹配字符串 &quot;abcde&quot; 时，匹配结果是：成功；匹配到的内容是：&quot;c&quot;；匹配到的位置是：开始于2，结束于3。（注：下标从0开始还是从1开始，因当前编程语言的不同而可能不同）</p>
<p>举例2：表达式 &quot;bcd&quot;，在匹配字符串 &quot;abcde&quot; 时，匹配结果是：成功；匹配到的内容是：&quot;bcd&quot;；匹配到的位置是：开始于1，结束于4。</p>
<h4>1.2 简单的转义字符</h4>
<p>一些不便书写的字符，采用在前面加 &quot;&quot; 的方法。这些字符其实我们都已经熟知了。</p>
<p>表达式 可匹配</p>
<p>\r, \n  代表回车和换行符</p>
<p>\t  制表符</p>
<p>\  代表 &quot;&quot; 本身</p>
<p>还有其他一些在后边章节中有特殊用处的标点符号，在前面加 &quot;&quot; 后，就代表该符号本身。比如：^, $ 都有特殊意义，如果要想匹配字符串中 &quot;^&quot; 和 &quot;$&quot; 字符，则表达式就需要写成 &quot;^&quot; 和 &quot;$&quot;。</p>
<p>表达式 可匹配</p>
<p>^  匹配 ^ 符号本身</p>
<p>$  匹配 $ 符号本身</p>
<p>.  匹配小数点（.）本身</p>
<p>这些转义字符的匹配方法与 &quot;普通字符&quot; 是类似的。也是匹配与之相同的一个字符。</p>
<p>举例1：表达式 &quot;$d&quot;，在匹配字符串 &quot;abc$de&quot; 时，匹配结果是：成功；匹配到的内容是：&quot;$d&quot;；匹配到的位置是：开始于3，结束于5。</p>
<h4>1.3 能够与 '多种字符' 匹配的表达式</h4>
<p>正则表达式中的一些表示方法，可以匹配 '多种字符' 其中的任意一个字符。比如，表达式 &quot;\d&quot; 可以匹配任意一个数字。虽然可以匹配其中任意字符，但是只能是一个，不是多个。这就好比玩扑克牌时候，大小王可以代替任意一张牌，但是只能代替一张牌。</p>
<p>表达式 可匹配</p>
<p>\d  任意一个数字，0~9 中的任意一个</p>
<p>\w  任意一个字母或数字或下划线，也就是 A~Z,a~z,0~9,_ 中任意一个</p>
<p>\s  包括空格、制表符、换页符等空白字符的其中任意一个</p>
<p>.   小数点可以匹配除了换行符（\n）以外的任意一个字符</p>
<p>举例1：表达式 &quot;\d\d&quot;，在匹配 &quot;abc123&quot; 时，匹配的结果是：成功；匹配到的内容是：&quot;12&quot;；匹配到的位置是：开始于3，结束于5。</p>
<p>举例2：表达式 &quot;a.\d&quot;，在匹配 &quot;aaa100&quot; 时，匹配的结果是：成功；匹配到的内容是：&quot;aa1&quot;；匹配到的位置是：开始于1，结束于4。</p>
<h4>1.4 自定义能够匹配 '多种字符' 的表达式</h4>
<p>使用方括号 [ ] 包含一系列字符，能够匹配其中任意一个字符。用 [^ ] 包含一系列字符，则能够匹配其中字符之外的任意一个字符。同样的道理，虽然可以匹配其中任意一个，但是只能是一个，不是多个。</p>
<p>表达式 可匹配</p>
<p>[ab5@]  匹配 &quot;a&quot; 或 &quot;b&quot; 或 &quot;5&quot; 或 &quot;@&quot;</p>
<p>[^abc]  匹配 &quot;a&quot;,&quot;b&quot;,&quot;c&quot; 之外的任意一个字符</p>
<p>[f-k]   匹配 &quot;f&quot;~&quot;k&quot; 之间的任意一个字母</p>
<p>[^A-F0-3] 匹配 &quot;A&quot;~&quot;F&quot;,&quot;0&quot;~&quot;3&quot; 之外的任意一个字符</p>
<p>举例1：表达式 &quot;[bcd][bcd]&quot; 匹配 &quot;abc123&quot; 时，匹配的结果是：成功；匹配到的内容是：&quot;bc&quot;；匹配到的位置是：开始于1，结束于3。</p>
<p>举例2：表达式 &quot;[^abc]&quot; 匹配 &quot;abc123&quot; 时，匹配的结果是：成功；匹配到的内容是：&quot;1&quot;；匹配到的位置是：开始于3，结束于4。</p>
<h4>1.5 修饰匹配次数的特殊符号</h4>
<p>前面章节中讲到的表达式，无论是只能匹配一种字符的表达式，还是可以匹配多种字符其中任意一个的表达式，都只能匹配一次。如果使用表达式再加上修饰匹配次数的特殊符号，那么不用重复书写表达式就可以重复匹配。</p>
<p>使用方法是：&quot;次数修饰&quot;放在&quot;被修饰的表达式&quot;后边。比如：&quot;[bcd][bcd]&quot; 可以写成 &quot;[bcd]{2}&quot;。</p>
<p>表达式 作用</p>
<p>{n}   表达式重复n次，比如：&quot;\w{2}&quot; 相当于 &quot;\w\w&quot;；&quot;a{5}&quot; 相当于 &quot;aaaaa&quot;</p>
<p>{m,n} 表达式至少重复m次，最多重复n次，比如：&quot;ba{1,3}&quot;可以匹配 &quot;ba&quot;或&quot;baa&quot;或&quot;baaa&quot;</p>
<p>{m,}  表达式至少重复m次，比如：&quot;\w\d{2,}&quot;可以匹配 &quot;a12&quot;,&quot;_456&quot;,&quot;M12344&quot;...</p>
<p>?   匹配表达式0次或者1次，相当于 {0,1}，比如：&quot;a[cd]?&quot;可以匹配 &quot;a&quot;,&quot;ac&quot;,&quot;ad&quot;</p>
<p>+  表达式至少出现1次，相当于 {1,}，比如：&quot;a+b&quot;可以匹配 &quot;ab&quot;,&quot;aab&quot;,&quot;aaab&quot;...</p>
<p>*  表达式不出现或出现任意次，相当于 {0,}，比如：&quot;^*b&quot;可以匹配 &quot;b&quot;,&quot;^^^b&quot;...</p>
<p>举例1：表达式 &quot;\d+.?\d*&quot; 在匹配 &quot;It costs $12.5&quot; 时，匹配的结果是：成功；匹配到的内容是：&quot;12.5&quot;；匹配到的位置是：开始于10，结束于14。</p>
<p>举例2：表达式 &quot;go{2,8}gle&quot; 在匹配 &quot;Ads by goooooogle&quot; 时，匹配的结果是：成功；匹配到的内容是：&quot;goooooogle&quot;；匹配到的位置是：开始于7，结束于17。</p>
<h4>1.6 其他一些代表抽象意义的特殊符号</h4>
<p>一些符号在表达式中代表抽象的特殊意义：</p>
<p>表达式   作用</p>
<p>^   与字符串开始的地方匹配，不匹配任何字符</p>
<p>$   与字符串结束的地方匹配，不匹配任何字符</p>
<p>\b  匹配一个单词边界，也就是单词和空格之间的位置，不匹配任何字符</p>
<p>进一步的文字说明仍然比较抽象，因此，举例帮助大家理解。</p>
<p>举例1：表达式 &quot;^aaa&quot; 在匹配 &quot;xxx aaa xxx&quot; 时，匹配结果是：失败。因为 &quot;^&quot; 要求与字符串开始的地方匹配，因此，只有当 &quot;aaa&quot; 位于字符串的开头的时候，&quot;^aaa&quot; 才能匹配，比如：&quot;aaa xxx xxx&quot;。</p>
<p>举例2：表达式 &quot;aaa$&quot; 在匹配 &quot;xxx aaa xxx&quot; 时，匹配结果是：失败。因为 &quot;$&quot; 要求与字符串结束的地方匹配，因此，只有当 &quot;aaa&quot; 位于字符串的结尾的时候，&quot;aaa$&quot; 才能匹配，比如：&quot;xxx xxx aaa&quot;。</p>
<p>举例3：表达式 &quot;.\b.&quot; 在匹配 &quot;@@@abc&quot; 时，匹配结果是：成功；匹配到的内容是：&quot;@a&quot;；匹配到的位置是：开始于2，结束于4。
进一步说明：&quot;\b&quot; 与 &quot;^&quot; 和 &quot;$&quot; 类似，本身不匹配任何字符，但是它要求它在匹配结果中所处位置的左右两边，其中一边是 &quot;\w&quot; 范围，另一边是 非&quot;\w&quot; 的范围。</p>
<p>举例4：表达式 &quot;\bend\b&quot; 在匹配 &quot;weekend,endfor,end&quot; 时，匹配结果是：成功；匹配到的内容是：&quot;end&quot;；匹配到的位置是：开始于15，结束于18。</p>
<p>一些符号可以影响表达式内部的子表达式之间的关系：</p>
<p>表达式   作用</p>
<p>|   左右两边表达式之间 &quot;或&quot; 关系，匹配左边或者右边</p>
<p>( ) (1). 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰   (2). 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到</p>
<p>举例5：表达式 &quot;Tom|Jack&quot; 在匹配字符串 &quot;I'm Tom, he is Jack&quot; 时，匹配结果是：成功；匹配到的内容是：&quot;Tom&quot;；匹配到的位置是：开始于4，结束于7。匹配下一个时，匹配结果是：成功；匹配到的内容是：&quot;Jack&quot;；匹配到的位置时：开始于15，结束于19。</p>
<p>举例6：表达式 &quot;(go\s*)+&quot; 在匹配 &quot;Let's go go go!&quot; 时，匹配结果是：成功；匹配到内容是：&quot;go go go&quot;；匹配到的位置是：开始于6，结束于14。</p>
<p>举例7：表达式 &quot;￥(\d+.?\d*)&quot; 在匹配 &quot;＄10.9,￥20.5&quot; 时，匹配的结果是：成功；匹配到的内容是：&quot;￥20.5&quot;；匹配到的位置是：开始于6，结束于10。单独获取括号范围匹配到的内容是：&quot;20.5&quot;。</p>
<h3>2. 正则表达式中的一些高级规则</h3>
<h4>2.1 匹配次数中的贪婪与非贪婪</h4>
<p>在使用修饰匹配次数的特殊符号时，有几种表示方法可以使同一个表达式能够匹配不同的次数，比如：&quot;{m,n}&quot;, &quot;{m,}&quot;, &quot;?&quot;, &quot;*&quot;, &quot;+&quot;，具体匹配的次数随被匹配的字符串而定。这种重复匹配不定次数的表达式在匹配过程中，总是尽可能多的匹配。比如，针对文本 &quot;dxxxdxxxd&quot;，举例如下：</p>
<p>表达式   匹配结果</p>
<p>(d)(\w+)  &quot;\w+&quot; 将匹配第一个 &quot;d&quot; 之后的所有字符 &quot;xxxdxxxd&quot;</p>
<p>(d)(\w+)(d)   &quot;\w+&quot; 将匹配第一个 &quot;d&quot; 和最后一个 &quot;d&quot; 之间的所有字符 &quot;xxxdxxx&quot;。虽然 &quot;\w+&quot; 也能够匹配上最后一个 &quot;d&quot;，但是为了使整个表达式匹配成功，&quot;\w+&quot; 可以 &quot;让出&quot; 它本来能够匹配的最后一个 &quot;d&quot;</p>
<p>由此可见，&quot;\w+&quot; 在匹配的时候，总是尽可能多的匹配符合它规则的字符。虽然第二个举例中，它没有匹配最后一个 &quot;d&quot;，但那也是为了让整个表达式能够匹配成功。同理，带 &quot;*&quot; 和 &quot;{m,n}&quot; 的表达式都是尽可能地多匹配，带 &quot;?&quot; 的表达式在可匹配可不匹配的时候，也是尽可能的 &quot;要匹配&quot;。这 种匹配原则就叫作 &quot;贪婪&quot; 模式 。</p>
<p>非贪婪模式：</p>
<p>在修饰匹配次数的特殊符号后再加上一个 &quot;?&quot; 号，则可以使匹配次数不定的表达式尽可能少的匹配，使可匹配可不匹配的表达式，尽可能的 &quot;不匹配&quot;。这种匹配原则叫作 &quot;非贪婪&quot; 模式，也叫作 &quot;勉强&quot; 模式。如果少匹配就会导致整个表达式匹配失败的时候，与贪婪模式类似，非贪婪模式会最小限度的再匹配一些，以使整个表达式匹配成功。举例如下，针对文本 &quot;dxxxdxxxd&quot; 举例：</p>
<p>表达式   匹配结果</p>
<p>(d)(\w+?)   &quot;\w+?&quot; 将尽可能少的匹配第一个 &quot;d&quot; 之后的字符，结果是：&quot;\w+?&quot; 只匹配了一个 &quot;x&quot;</p>
<p>(d)(\w+?)(d)  为了让整个表达式匹配成功，&quot;\w+?&quot; 不得不匹配 &quot;xxx&quot; 才可以让后边的 &quot;d&quot; 匹配，从而使整个表达式匹配成功。因此，结果是：&quot;\w+?&quot; 匹配 &quot;xxx&quot;</p>
<p>更多的情况，举例如下：</p>
<p>举例1：表达式 &quot;<td>(.*)</td>&quot; 与字符串 &quot;<td><p>aa</p></td> <td><p>bb</p></td>&quot; 匹配时，匹配的结果是：成功；匹配到的内容是 &quot;<td><p>aa</p></td> <td><p>bb</p></td>&quot; 整个字符串， 表达式中的 &quot;&quot; 将与字符串中最后一个 &quot;&quot; 匹配。</p>
<p>举例2：相比之下，表达式 &quot;<td>(.*?)</td>&quot; 匹配举例1中同样的字符串时，将只得到 &quot;<td><p>aa</p></td>&quot;， 再次匹配下一个时，可以得到第二个 &quot;<td><p>bb</p></td>&quot;。</p>
<h4>2.2 反向引用 \1, \2...</h4>
<p>表达式在匹配时，表达式引擎会将小括号 &quot;( )&quot; 包含的表达式所匹配到的字符串记录下来。在获取匹配结果的时候，小括号包含的表达式所匹配到的字符串可以单独获取。这一点，在前面的举例中，已经多次展示了。在实际应用场合中，当用某种边界来查找，而所要获取的内容又不包含边界时，必须使用小括号来指定所要的范围。比如前面的 &quot;<td>(.*?)</td>&quot;。</p>
<p>其实，&quot;小括号包含的表达式所匹配到的字符串&quot; 不仅是在匹配结束后才可以使用，在匹配过程中也可以使用。表达式后边的部分，可以引用前面 &quot;括号内的子匹配已经匹配到的字符串&quot;。引用方法是 &quot;&quot; 加上一个数字。&quot;\1&quot; 引用第1对括号内匹配到的字符串，&quot;\2&quot; 引用第2对括号内匹配到的字符串……以此类推，如果一对括号内包含另一对括号，则外层的括号先排序号。换句话说，哪一对的左括号 &quot;(&quot; 在前，那这一对就先排序号。</p>
<p>举例如下：</p>
<p>举例1：表达式 &quot;('|&quot;)(.*?)(\1)&quot; 在匹配 &quot; 'Hello', &quot;World&quot; &quot; 时，匹配结果是：成功；匹配到的内容是：&quot; 'Hello' &quot;。再次匹配下一个时，可以匹配到 &quot; &quot;World&quot; &quot;。</p>
<p>举例2：表达式 &quot;(\w)\1{4,}&quot; 在匹配 &quot;aa bbbb abcdefg ccccc 111121111 999999999&quot; 时，匹配结果是：成功；匹配到的内容是 &quot;ccccc&quot;。再次匹配下一个时，将得到 999999999。这个表达式要求 &quot;\w&quot; 范围的字符至少重复5次，注意与 &quot;\w{5,}&quot; 之间的区别。</p>
<p>举例3：表达式 &quot;&lt;(\w+)\s*(\w+(=('|&quot;).<em>?\4)?\s</em>)<em>&gt;.</em>?&lt;/\1&gt;&quot; 在匹配 &quot;<td id="td1" style="bgcolor:white"></td>&quot; 时，匹配结果是成功。如果 &quot;<td>&quot; 与 &quot;</td>&quot; 不配对，则会匹配失败；如果改成其他配对，也可以匹配成功。</p>
<h4>2.3 预搜索，不匹配；反向预搜索，不匹配</h4>
<p>前面的章节中，我讲到了几个代表抽象意义的特殊符号：&quot;^&quot;，&quot;$&quot;，&quot;\b&quot;。它们都有一个共同点，那就是：它们本身不匹配任何字符，只是对 &quot;字符串的两头&quot; 或者 &quot;字符之间的缝隙&quot; 附加了一个条件。理解到这个概念以后，本节将继续介绍另外一种对 &quot;两头&quot; 或者 &quot;缝隙&quot; 附加条件的，更加灵活的表示方法。</p>
<p>正向预搜索：&quot;(?=xxxxx)&quot;，&quot;(?!xxxxx)&quot;</p>
<p>格式：&quot;(?=xxxxx)&quot;，在被匹配的字符串中，它对所处的 &quot;缝隙&quot; 或者 &quot;两头&quot; 附加的条件是：所在缝隙的右侧，必须能够匹配上 xxxxx 这部分的表达式。因为它只是在此作为这个缝隙上附加的条件，所以它并不影响后边的表达式去真正匹配这个缝隙之后的字符。这就类似 &quot;\b&quot;，本身不匹配任何字符。&quot;\b&quot; 只是将所在缝隙之前、之后的字符取来进行了一下判断，不会影响后边的表达式来真正的匹配。</p>
<p>举例1：表达式 &quot;Windows (?=NT|XP)&quot; 在匹配 &quot;Windows 98, Windows NT, Windows 2000&quot; 时，将只匹配 &quot;Windows NT&quot; 中的 &quot;Windows &quot;，其他的 &quot;Windows &quot; 字样则不被匹配。</p>
<p>举例2：表达式 &quot;(\w)((?=\1\1\1)(\1))+&quot; 在匹配字符串 &quot;aaa ffffff 999999999&quot; 时，将可以匹配6个&quot;f&quot;的前4个，可以匹配9个&quot;9&quot;的前7个。这个表达式可以读解成：重复4次以上的字母数字，则匹配其剩下最后2位之前的部分。当然，这个表达式可以不这样写，在此的目的是作为演示之用。</p>
<p>格式：&quot;(?!xxxxx)&quot;，所在缝隙的右侧，必须不能匹配 xxxxx 这部分表达式。</p>
<p>举例3：表达式 &quot;((?!\bstop\b).)+&quot; 在匹配 &quot;fdjka ljfdl stop fjdsla fdj&quot; 时，将从头一直匹配到 &quot;stop&quot; 之前的位置，如果字符串中没有 &quot;stop&quot;，则匹配整个字符串。</p>
<p>举例4：表达式 &quot;do(?!\w)&quot; 在匹配字符串 &quot;done, do, dog&quot; 时，只能匹配 &quot;do&quot;。在本条举例中，&quot;do&quot; 后边使用 &quot;(?!\w)&quot; 和使用 &quot;\b&quot; 效果是一样的。</p>
<p>反向预搜索：&quot;(?&lt;=xxxxx)&quot;，&quot;(?&lt;!xxxxx)&quot;</p>
<p>这两种格式的概念和正向预搜索是类似的，反向预搜索要求的条件是：所在缝隙的 &quot;左侧&quot;，两种格式分别要求必须能够匹配和必须不能够匹配指定表达式，而不是去判断右侧。与 &quot;正向预搜索&quot; 一样的是：它们都是对所在缝隙的一种附加条件，本身都不匹配任何字符。</p>
<p>举例5：表达式 &quot;(?&lt;=\d{4})\d+(?=\d{4})&quot; 在匹配 &quot;1234567890123456&quot; 时，将匹配除了前4个数字和后4个数字之外的中间8个数字。由于 JScript.RegExp 不支持反向预搜索，因此，本条举例不能够进行演示。很多其他的引擎可以支持反向预搜索，比如：Java 1.4 以上的 java.util.regex 包，.NET 中System.Text.RegularExpressions 命名空间，以及本站推荐的最简单易用的 DEELX 正则引擎。</p>
<h3>3. 其他通用规则</h3>
<p>还有一些在各个正则表达式引擎之间比较通用的规则，在前面的讲解过程中没有提到。</p>
<h4>3.1 表达式中，可以使用 &quot;\xXX&quot; 和 &quot;\uXXXX&quot; 表示一个字符（&quot;X&quot; 表示一个十六进制数）</h4>
<p>形式    字符范围</p>
<p>\xXX  编号在  ~ 255 范围的字符，比如：空格可以使用 &quot;\x20&quot; 表示</p>
<p>\uXXXX  任何字符可以使用 &quot;\u&quot; 再加上其编号的4位十六进制数表示，比如：&quot;\u4E2D&quot;</p>
<h4>3.2 在表达式 &quot;\s&quot;，&quot;\d&quot;，&quot;\w&quot;，&quot;\b&quot; 表示特殊意义的同时，对应的大写字母表示相反的意义</h4>
<p>表达式   可匹配</p>
<p>\S    匹配所有非空白字符（&quot;\s&quot; 可匹配各个空白字符）</p>
<p>\D    匹配所有的非数字字符</p>
<p>\W    匹配所有的字母、数字、下划线以外的字符</p>
<p>\B    匹配非单词边界，即左右两边都是 &quot;\w&quot; 范围或者左右两边都不是 &quot;\w&quot; 范围时的字符缝隙</p>
<h4>3.3 在表达式中有特殊意义，需要添加 &quot;&quot; 才能匹配该字符本身的字符汇总</h4>
<p>字符  说明</p>
<p>^   匹配输入字符串的开始位置。要匹配 &quot;^&quot; 字符本身，请使用 &quot;^&quot;</p>
<p>$   匹配输入字符串的结尾位置。要匹配 &quot;$&quot; 字符本身，请使用 &quot;$&quot;</p>
<p>( ) 标记一个子表达式的开始和结束位置。要匹配小括号，请使用 &quot;(&quot; 和 &quot;)&quot;</p>
<p>[ ] 用来自定义能够匹配 '多种字符' 的表达式。要匹配中括号，请使用 &quot;[&quot; 和 &quot;]&quot;</p>
<p>{ } 修饰匹配次数的符号。要匹配大括号，请使用 &quot;{&quot; 和 &quot;}&quot;</p>
<p>.   匹配除了换行符（\n）以外的任意一个字符。要匹配小数点本身，请使用 &quot;.&quot;</p>
<p>?   修饰匹配次数为 0 次或 1 次。要匹配 &quot;?&quot; 字符本身，请使用 &quot;?&quot;</p>
<p>+  修饰匹配次数为至少 1 次。要匹配 &quot;+&quot; 字符本身，请使用 &quot;+&quot;</p>
<p>*  修饰匹配次数为 0 次或任意次。要匹配 &quot;*&quot; 字符本身，请使用 &quot;*&quot;</p>
<p>|   左右两边表达式之间 &quot;或&quot; 关系。匹配 &quot;|&quot; 本身，请使用 &quot;|&quot;</p>
<h4>3.4 括号 &quot;( )&quot; 内的子表达式，如果希望匹配结果不进行记录供以后使用，可以使用 &quot;(?:xxxxx)&quot; 格式</h4>
<p>举例1：表达式 &quot;(?:(\w)\1)+&quot; 匹配 &quot;a bbccdd efg&quot; 时，结果是 &quot;bbccdd&quot;。括号 &quot;(?:)&quot; 范围的匹配结果不进行记录，因此 &quot;(\w)&quot; 使用 &quot;\1&quot; 来引用。</p>
<h4>3.5 常用的表达式属性设置简介：Ignorecase，Singleline，Multiline，Global</h4>
<p>表达式属性   说明</p>
<p>Ignorecase  默认情况下，表达式中的字母是要区分大小写的。配置为 Ignorecase 可使匹配时不区分大小写。有的表达式引擎，把 &quot;大小写&quot; 概念延伸至 UNICODE 范围的大小写。</p>
<p>Singleline  默认情况下，小数点 &quot;.&quot; 匹配除了换行符（\n）以外的字符。配置为 Singleline 可使小数点可匹配包括换行符在内的所有字符。</p>
<p>Multiline   默认情况下，表达式 &quot;^&quot; 和 &quot;$&quot; 只匹配字符串的开始 ① 和结尾 ④ 位置。如：</p>
<p>①xxxxxxxxx②\n
③xxxxxxxxx④ 配置为 Multiline 可以使 &quot;^&quot; 匹配 ① 外，还可以匹配换行符之后，下一行开始前 ③ 的位置，使 &quot;$&quot; 匹配 ④ 外，还可以匹配换行符之前，一行结束 ② 的位置。</p>
<p>Global  主要在将表达式用来替换时起作用，配置为 Global 表示替换所有的匹配。</p>
<h3>4. 其他提示</h3>
<h4>4.1 如果想要了解高级的正则引擎还支持那些复杂的正则语法，可参见本站 DEELX 正则引擎的说明文档。</h4>
<h4>4.2 如果要要求表达式所匹配的内容是整个字符串，而不是从字符串中找一部分，那么可以在表达式的首尾使用 &quot;^&quot; 和 &quot;$&quot;，比如：&quot;^\d+$&quot; 要求整个字符串只有数字。</h4>
<h4>4.3 如果要求匹配的内容是一个完整的单词，而不会是单词的一部分，那么在表达式首尾使用 &quot;\b&quot;，比如：使用 &quot;\b(if|while|else|void|int……)\b&quot; 来匹配程序中的关键字。</h4>
<h4>4.4 表达式不要匹配空字符串。否则会一直得到匹配成功，而结果什么都没有匹配到。比如：准备写一个匹配 &quot;123&quot;、&quot;123.&quot;、&quot;123.5&quot;、&quot;.5&quot; 这几种形式的表达式时，整数、小数点、小数数字都可以省略，但是不要将表达式写成：&quot;\d*.?\d*&quot;，因为如果什么都没有，这个表达式也可以匹配成功。更好的写法是：&quot;\d+.?\d*|.\d+&quot;。</h4>
<h4>4.5 能匹配空字符串的子匹配不要循环无限次。如果括号内的子表达式中的每一部分都可以匹配 0 次，而这个括号整体又可以匹配无限次，那么情况可能比上一条所说的更严重，匹配过程中可能死循环。虽然现在有些正则表达式引擎已经通过办法避免了这种情况出现死循环了，比如 .NET 的正则表达式，但是我们仍然应该尽量避免出现这种情况。如果我们在写表达式时遇到了死循环，也可以从这一点入手，查找一下是否是本条所说的原因。</h4>
<h4>4.6 合理选择贪婪模式与非贪婪模式，参见话题讨论。</h4>
<h4>4.7 或 &quot;|&quot; 的左右两边，对某个字符最好只有一边可以匹配，这样，不会因为 &quot;|&quot; 两边的表达式因为交换位置而有所不同。</h4>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/08/Github/Github新建本地仓库并同步远程仓库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/08/Github/Github新建本地仓库并同步远程仓库/" itemprop="url">Github新建本地仓库并同步远程仓库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-08T21:09:20+08:00">
                2018-02-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3>如何直接在本地创建仓库并提交到远程仓库?</h3>
<p>前提：在github上手动创建仓库gitRepo，且没有其它任何提交，包括readme.md。</p>
<p><strong>步骤如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mkdir gitRepo #如果是已存在的工程项目，则直接cd到项目根目录下，不需要新建。</div><div class="line">cd gitRepo</div><div class="line">git init #初始化本地仓库</div><div class="line">git add xxx #添加要push到远程仓库的文件或文件夹</div><div class="line">git commit -m ‘first commit’</div><div class="line">git remote add origin https://github.com/yourgithubID/gitRepo.git #建立远程仓库</div><div class="line">git push -u origin master #将本地仓库push到远程仓库</div></pre></td></tr></table></figure>
<p><strong>有关问题：</strong></p>
<ul>
<li>
<p>如果没有创建gitRepo，则会报以下错误: <code>ERROR:Repository not found.</code></p>
</li>
<li>
<p>由于在github上手动创建的仓库包括：README.md文件，本地仓库没有此文件，则在执行git push -u origin master命令时报如下的错误: <code>ERROR:failed to push some refs to ...</code>
解决方法为：
第一步：可以通过如下命令进行代码合并[注：pull=fetch+merge]
<code>git pull --rebase origin master</code>
执行上面代码后可以看到本地代码库中多了README.md文件
第二步：此时再执行语句 <code>git push -u origin master</code>即可完成代码上传到github</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/07/Java/Spring MVC 常用注解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/Java/Spring MVC 常用注解/" itemprop="url">Spring MVC 常用注解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T15:13:41+08:00">
                2018-02-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3>@Controller</h3>
<p>在SpringMVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在SpringMVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。</p>
<p>@Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。</p>
<hr>
<h3>@RequestMapping</h3>
<p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<p>RequestMapping注解有六个属性，分成三类进行说明（下面有相应示例）。</p>
<p>1、 value， method；
value：     指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；
method：  指定请求的method类型， GET、POST、PUT、DELETE等；</p>
<p>2、consumes，produces
consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;
produces:    指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</p>
<p>3、params，headers
params： 指定request中必须包含某些参数值是，才让该方法处理。
headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p>
<h4>使用 @RequestMapping 来映射 Request 请求与处理器</h4>
<p>方式一、通过常见的类路径和方法路径结合访问controller方法
方式二、使用url模板</p>
<pre><code>@Controller
@RequestMapping ( &quot;/test/{variable1}&quot; )
public class MyController {

    @RequestMapping ( &quot;/showView/{variable2}&quot; )
    public ModelAndView showView( @PathVariable String variable1, @PathVariable ( &quot;variable2&quot; ) int variable2) {
       ModelAndView modelAndView = new ModelAndView();
       modelAndView.setViewName( &quot;viewName&quot; );
       modelAndView.addObject( &quot; 需要放到 model 中的属性名称 &quot; , &quot; 对应的属性值，它是一个对象 &quot; );
       return modelAndView;
    }
} 
</code></pre>
<p>URI 模板就是在URI 中给定一个变量，然后在映射的时候动态的给该变量赋值。如URI 模板http://localhost/app/{variable1}/index.html ，这个模板里面包含一个变量variable1 ，那么当我们请求http://localhost/app/hello/index.html 的时候，该URL 就跟模板相匹配，只是把模板中的variable1 用hello 来取代。这个变量在SpringMVC 中是使用@PathVariable 来标记的。在SpringMVC 中，我们可以使用@PathVariable 来标记一个Controller 的处理方法参数，表示该参数的值将使用URI 模板中对应的变量的值来赋值。</p>
<p>代码中我们定义了两个URI 变量，一个是控制器类上的variable1 ，一个是showView 方法上的variable2 ，然后在showView 方法的参数里面使用@PathVariable 标记使用了这两个变量。所以当我们使用/test/hello/showView/2.do 来请求的时候就可以访问到MyController 的showView 方法，这个时候variable1 就被赋予值hello ，variable2 就被赋予值2 ，然后我们在showView 方法参数里面标注了参数variable1 和variable2 是来自访问路径的path 变量，这样方法参数variable1 和variable2 就被分别赋予hello 和2 。方法参数variable1 是定义为String 类型，variable2 是定义为int 类型，像这种简单类型在进行赋值的时候Spring 是会帮我们自动转换的。</p>
<p>在标记variable1 为path 变量的时候我们使用的是@PathVariable ，而在标记variable2 的时候使用的是@PathVariable(“variable2”) 。这两者有什么区别呢？
第一种情况就默认去URI 模板中找跟参数名相同的变量，但是这种情况只有在使用debug 模式进行编译的时候才可以;
第二种情况是明确规定使用的就是URI 模板中的variable2 变量。当不是使用debug 模式进行编译，或者是所需要使用的变量名跟参数名不相同的时候，就要使用第二种方式明确指出使用的是URI 模板中的哪个变量。</p>
<h4>使用 @RequestMapping 的一些高级用法</h4>
<p>（1）params属性</p>
<pre><code>@RequestMapping (value= &quot;testParams&quot; , params={ &quot;param1=value1&quot; , &quot;param2&quot; , &quot;!param3&quot; })
    public String testParams() {
       System. out .println( &quot;test Params...........&quot; );
       return &quot;testParams&quot; ;
    }
</code></pre>
<p>用@RequestMapping 的params 属性指定了三个参数，这些参数都是针对请求参数而言的，它们分别表示参数param1 的值必须等于value1 ，参数param2 必须存在，值无所谓，参数param3 必须不存在，只有当请求/testParams.do 并且满足指定的三个参数条件的时候才能访问到该方法。所以当请求/testParams.do?param1=value1&amp;param2=value2 的时候能够正确访问到该testParams 方法，当请求/testParams.do?param1=value1&amp;param2=value2&amp;param3=value3 的时候就不能够正常的访问到该方法，因为在@RequestMapping 的params 参数里面指定了参数param3 是不能存在的。</p>
<p>（2）method属性</p>
<pre><code>@RequestMapping (value= &quot;testMethod&quot; , method={RequestMethod. GET , RequestMethod. DELETE })
    public String testMethod() {
       return &quot;method&quot; ;
    }
</code></pre>
<p>在上面的代码中就使用method 参数限制了以GET 或DELETE 方法请求/testMethod 的时候才能访问到该Controller 的testMethod 方法。</p>
<p>（3）headers属性</p>
<pre><code>@RequestMapping (value= &quot;testHeaders&quot; , headers={ &quot;host=localhost&quot; , &quot;Accept&quot; })
    public String testHeaders() {
       return &quot;headers&quot; ;
    }
</code></pre>
<p>headers 属性的用法和功能与params 属性相似。在上面的代码中当请求/testHeaders.do 的时候只有当请求头包含Accept 信息，且请求的host 为localhost 的时候才能正确的访问到testHeaders 方法。</p>
<h4>@RequestMapping 标记的处理器方法支持的方法参数和返回类型</h4>
<ol>
<li>
<p>支持的方法参数类型
（1）HttpServlet 对象，主要包括HttpServletRequest 、HttpServletResponse 和HttpSession 对象。 这些参数Spring 在调用处理器方法的时候会自动给它们赋值，所以当在处理器方法中需要使用到这些对象的时候，可以直接在方法上给定一个方法参数的申明，然后在方法体里面直接用就可以了。但是有一点需要注意的是在使用HttpSession 对象的时候，如果此时HttpSession 对象还没有建立起来的话就会有问题。
（2）Spring 自己的WebRequest 对象。 使用该对象可以访问到存放在HttpServletRequest 和HttpSession 中的属性值。
（3）InputStream 、OutputStream 、Reader 和Writer 。 InputStream 和Reader 是针对HttpServletRequest 而言的，可以从里面取数据；OutputStream 和Writer 是针对HttpServletResponse 而言的，可以往里面写数据。
（4）使用@PathVariable 、@RequestParam 、@CookieValue 和@RequestHeader 标记的参数。
（5）使用@ModelAttribute 标记的参数。
（6）java.util.Map 、Spring 封装的Model 和ModelMap 。 这些都可以用来封装模型数据，用来给视图做展示。
（7）实体类。 可以用来接收上传的参数。
（8）Spring 封装的MultipartFile 。 用来接收上传文件的。
（9）Spring 封装的Errors 和BindingResult 对象。 这两个对象参数必须紧接在需要验证的实体对象参数之后，它里面包含了实体对象的验证结果。</p>
</li>
<li>
<p>支持的返回类型
（1）一个包含模型和视图的ModelAndView 对象。
（2）一个模型对象，这主要包括Spring 封装好的Model 和ModelMap ，以及java.util.Map ，当没有视图返回的时候视图名称将由RequestToViewNameTranslator 来决定。
（3）一个View 对象。这个时候如果在渲染视图的过程中模型的话就可以给处理器方法定义一个模型参数，然后在方法体里面往模型中添加值。
（4）一个String 字符串。这往往代表的是一个视图名称。这个时候如果需要在渲染视图的过程中需要模型的话就可以给处理器方法一个模型参数，然后在方法体里面往模型中添加值就可以了。
（5）返回值是void 。这种情况一般是我们直接把返回结果写到HttpServletResponse 中了，如果没有写的话，那么Spring 将会利用RequestToViewNameTranslator 来返回一个对应的视图名称。如果视图中需要模型的话，处理方法与返回字符串的情况相同。
（6）如果处理器方法被注解@ResponseBody 标记的话，那么处理器方法的任何返回类型都会通过HttpMessageConverters 转换之后写到HttpServletResponse 中，而不会像上面的那些情况一样当做视图或者模型来处理。
（7）除以上几种情况之外的其他任何返回类型都会被当做模型中的一个属性来处理，而返回的视图还是由RequestToViewNameTranslator 来决定，添加到模型中的属性名称可以在该方法上用@ModelAttribute(“attributeName”) 来定义，否则将使用返回类型的类名称的首字母小写形式来表示。使用@ModelAttribute 标记的方法会在@RequestMapping 标记的方法执行之前执行。</p>
</li>
</ol>
<hr>
<h3>@Resource和@Autowired</h3>
<p>@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p>
<p>1、共同点
两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p>
<p>2、不同点</p>
<p>（1）@Autowired</p>
<p>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p>
<pre><code>public class TestServiceImpl {
    // 下面两种@Autowired只要使用一种即可
    @Autowired
    private UserDao userDao; // 用于字段上
    
    @Autowired
    public void setUserDao(UserDao userDao) { // 用于属性的方法上
        this.userDao = userDao;
    }
}
</code></pre>
<p>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。如下：</p>
<pre><code>public class TestServiceImpl {
    @Autowired
    @Qualifier(&quot;userDao&quot;)
    private UserDao userDao; 
}
</code></pre>
<p>（2）@Resource</p>
<p>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p>
<pre><code>public class TestServiceImpl {
    // 下面两种@Resource只要使用一种即可
    @Resource(name=&quot;userDao&quot;)
    private UserDao userDao; // 用于字段上
    
    @Resource(name=&quot;userDao&quot;)
    public void setUserDao(UserDao userDao) { // 用于属性的setter方法上
        this.userDao = userDao;
    }
}
</code></pre>
<p>注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。</p>
<p>@Resource装配顺序：</p>
<p>①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。
②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。
③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。
④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。
@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。</p>
<hr>
<h3>@ModelAttribute和 @SessionAttributes</h3>
<p>@ModelAttribute代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。</p>
<p>@SessionAttributes即将值放到session作用域中，写在class上面。</p>
<hr>
<h3>@PathVariable</h3>
<p>用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数。如：</p>
<pre><code>@Controller  
public class TestController {  
     @RequestMapping(value=&quot;/user/{userId}/roles/{roleId}&quot;,method = RequestMethod.GET)  
     public String getLogin(@PathVariable(&quot;userId&quot;) String userId,  
         @PathVariable(&quot;roleId&quot;) String roleId){  
         System.out.println(&quot;User Id : &quot; + userId);  
         System.out.println(&quot;Role Id : &quot; + roleId);  
         return &quot;hello&quot;;  
     }  
     @RequestMapping(value=&quot;/product/{productId}&quot;,method = RequestMethod.GET)  
     public String getProduct(@PathVariable(&quot;productId&quot;) String productId){  
           System.out.println(&quot;Product Id : &quot; + productId);  
           return &quot;hello&quot;;  
     }  
     @RequestMapping(value=&quot;/javabeat/{regexp1:[a-z-]+}&quot;,  
           method = RequestMethod.GET)  
     public String getRegExp(@PathVariable(&quot;regexp1&quot;) String regexp1){  
           System.out.println(&quot;URI Part 1 : &quot; + regexp1);  
           return &quot;hello&quot;;  
     }  
}
</code></pre>
<hr>
<h3>@requestParam</h3>
<p>@requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(&quot;name&quot;)，它有三个常用参数：defaultValue = &quot;0&quot;, required = false, value = &quot;isApp&quot;；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。</p>
<hr>
<h3>@ResponseBody</h3>
<p>作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。</p>
<p>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；</p>
<hr>
<h3>@Component</h3>
<p>相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。</p>
<hr>
<h3>@Repository</h3>
<p>用于注解dao层，在daoImpl类上面注解。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/05/Linux/Linux 局域网localhost/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/05/Linux/Linux 局域网localhost/" itemprop="url">Linux 局域网localhost</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-05T16:01:29+08:00">
                2018-02-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>背景：有一个部署在Linux虚拟机中的web应用，但是虚拟机没有安装图形界面只有字符界面，Linux作为服务器部署web应用，但是不能通过其自身localhost访问，不方便调试，如何能够让主机通过访问Linux虚拟机的局域网IP+端口访问web应用呢？</p>
<p>步骤如下：</p>
<p>Linux虚拟机为NAT或桥接模式，确保主机能够ping通；</p>
<pre><code># vi /etc/hosts
  127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4  
  ::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
</code></pre>
<p>修改为：</p>
<pre><code>  192.168.80.21   localhost localhost.localdomain localhost4 localhost4.localdomain4
  ::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
</code></pre>
<p>其中192.168.80.21是Linux虚拟机的局域网IP;</p>
<p>将web应用部署在localhost中；</p>
<p>打开主机浏览器，输入192.168.80.21:端口 即可访问；</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/05/Linux/Linux shell 脚本参数传递/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/05/Linux/Linux shell 脚本参数传递/" itemprop="url">Linux shell 脚本参数传递</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-05T10:59:19+08:00">
                2018-02-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 Shell中，调用函数时可以向其传递参数。在函数体内部，通过 n的形式来获取参数的值，例如，1 表示第一个参数，$2 表示第二个参数...</p>
<p>特殊变量	说明
<code>$0</code> 当前脚本文件名
<code>$n</code> 传递给脚本或函数的参数，n是一个数字，表示第几个参数，$1表示第一个参数，$2表示第二个参数 ...
<code>$#</code> 传递给脚本或函数的参数个数
<code>$*</code> 传递给脚本或函数的所有参数，当它被双引号（&quot; &quot;）包含时，<code>&quot;$*&quot;</code> 会将所有的参数作为一个整体，以<code>&quot;$1 $2 ... $n&quot;</code>的形式输出所有参数
<code>$@</code> 传递给脚本或函数的所有参数，当它被双引号（&quot; &quot;）包含时，与<code>$*</code>稍有不同，<code>&quot;$@&quot;</code> 会将各个参数分开，以<code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;</code> 的形式输出所有参数
<code>$*</code>和<code>$@</code>不被双引号(&quot; &quot;)包含时，都以<code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;</code> 的形式输出所有参数</p>
<p>另外还有：
<code>$?</code> 上一个命令的退出状态，或函数的返回值，如果正常退出则返回0，反之为非0值
<code>$$</code> 当前shell进程pid，对于shell脚本，就是这些脚本所在的进程ID
<code>$!</code> 上一个命令的pid</p>
<p>写一个测试脚本：
#!/bin/bash
echo &quot;$<em>=&quot; $</em>
echo &quot;$@=&quot; $@</p>
<pre><code>echo &quot;print each param from \$*&quot; 
for var in $*
do
    echo $var
done

echo &quot;print each param from \$@&quot;
for var in $@
do
    echo $var
done

echo &quot;print each param from \&quot;\$*\&quot;&quot;
for var in &quot;$*&quot;
do
    echo $var
done

echo &quot;print each param from \&quot;\$@\&quot;&quot;
for var in &quot;$@&quot;
do
    echo $var
done
</code></pre>
<p>结果如下：
# sh test.sh a b c d
$<em>= a b c d
$@= a b c d
print each param from $</em>
a
b
c
d
print each param from $@
a
b
c
d
print each param from &quot;$*&quot;
a b c d
print each param from &quot;$@&quot;
a
b
c
d</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/03/Java/Java内部类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/03/Java/Java内部类/" itemprop="url">Java内部类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-03T09:51:07+08:00">
                2018-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文章转自:<a href="http://liuzxc.github.io/blog/java-advance-02/" target="_blank" rel="external">链接</a></p>
<h3>什么是内部类</h3>
<p>定义在其他类（outer class）中的类被称作内部类。内部类可以有访问修饰服，甚至可以被标记为 abstract 或 final。 内部类与外部类实例有特殊的关系，这种关系允许内部类访问外部类的成员，也包括私有成员。</p>
<p>内部类分为以下四种：</p>
<ul>
<li>inner class</li>
<li>局部内部类</li>
<li>匿名内部类</li>
<li>静态嵌套类</li>
</ul>
<h3>Inner Class</h3>
<p>一个内部类被声明在另外一个类当中：</p>
<pre><code>//Top level class definition
class MyOuterClassDemo {
   private int myVar= 1;

   // inner class definition
   class MyInnerClassDemo {
      public void seeOuter () {
         System.out.println(&quot;Value of myVar is :&quot; + myVar);
      }
    } // close inner class definition

} // close Top level class definitio
</code></pre>
<p>实例化一个内部类</p>
<p>为了实例化一个内部类的实例，需要一个外部类的实例。内部类的实例只能通过外部类的实例来创建。</p>
<pre><code>//Top level class definition
class MyOuterClassDemo {
 private int myVar= 1;

 // inner class definition
 class MyInnerClassDemo {
    public void seeOuter () {
       System.out.println(&quot;Value of myVar is :&quot; + myVar);
    }
  } // close inner class definition

 void innerInstance(){
	MyInnerClassDemo inner = new MyInnerClassDemo();
	inner.seeOuter();
 }
 public static void main(String[] args){
	 MyOuterClassDemo outer = new MyOuterClassDemo();
	 outer.innerInstance();
 }
} // close Top level class definitio

Output: Outer Value of x is :1
</code></pre>
<p>上面的例子 mian 方法也可以这样写：</p>
<pre><code> public static void main(String[] args){
	 MyOuterClassDemo.MyInnerClassDemo inner = new MyOuterClassDemo().new MyInnerClassDemo();
	 inner.seeOuter();
 }
</code></pre>
<h3>局部内部类</h3>
<p>局部内部类被定义在外部类的方法当中。</p>
<p>如果你想使用内部类，必须同一方法中实例化内部类
只有 abstract 和 final 这两个修饰符被允许修饰局部内部类
只有在方法的局部变量被标记为 final 或 局部变量是 effectively final的， 内部类才能使用它们。
什么是 effectively final？ “Starting in Java SE 8, a local class can access local variables and parameters of the enclosing block that are final or effectively final. A variable or parameter whose value is never changed after it is initialized is effectively final.” 因此当变量或参数在初始化之后，值再也没有改变过，那么就说明该变量或参数是 effectively final。</p>
<pre><code>//Top level class definition
class MyOuterClassDemo {
 private int x= 1;

 public void doThings(){
    String name =&quot;local variable&quot;; // name is effectively final
    // inner class defined inside a method of outer class
    class MyInnerClassDemo {
      public void seeOuter() {
         System.out.println(&quot;Outer Value of x is :&quot; + x);
         System.out.println(&quot;Value of name is :&quot; + name);
      } //close inner class method
    } // close inner class definition
    MyInnerClassDemo inner = new MyInnerClassDemo();
    inner.seeOuter();
 } //close Top level class method
 public static void main(String[] args){
	 MyOuterClassDemo outer = new MyOuterClassDemo();
	 outer.doThings();
 }
} // close Top level class

Output:

Outer Value of x is :1
Value of name is :local variable
</code></pre>
<h3>匿名内部类</h3>
<p>匿名内部类有以下特点：</p>
<ul>
<li>没有名字</li>
<li>只能被实例化一次</li>
<li>通常被声明在方法或代码块的内部，以一个带有分号的花括号结尾</li>
<li>因为没有名字，所以没有构造函数</li>
<li>不能是静态的（static)</li>
</ul>
<p>为什么要使用匿名类，我们先看一个例子：</p>
<pre><code>abstract class Animal {
	abstract void play();
}

class Dog extends Animal{
	void play(){
		System.out.println(&quot;play with human&quot;);
	}
}

class Demo{
	public static void main(String[] args){
		Animal d = new Dog();
		d.play();
	}
}

Output:  play with human
</code></pre>
<p>如果此处的 Dog 类只使用了一次，那么单独定义一个Dog类是否会显得有点麻烦？ 这个时候我们可以引入匿名类：</p>
<pre><code>abstract class Animal {
	abstract void play();
}

class Person{
	public static void main(String[] args){
		Animal d = new Animal(){
			void play(){
				System.out.println(&quot;play with human&quot;);
			}
		};
		d.play();
	}
}

Output:  play with human
</code></pre>
<p>由上面的例子可以看出，匿名类的一个重要作用就是简化代码。</p>
<p>匿名类的常用场景：</p>
<p>事件监听
普通的实现方式：</p>
<pre><code> public class WindowClosingAdapter extends WindowAdapter {
     public void windowClosing( WindowEvent e ) {
         System.exit(0);
     }
 }

 ...

  addWindowListener( new WindowClosingAdapter() );
</code></pre>
<p>匿名内部类的实现方式：</p>
<pre><code> addWindowListener(
     new WindowAdapter() {
         public void windowClosing( WindowEvent e ) {
             System.exit(0);
         }
     });
</code></pre>
<p>Thread 类的匿名内部类实现
public class Demo {
public static void main(String[] args) {
Thread t = new Thread() {
public void run() {
for (int i = 1; i &lt;= 5; i++) {
System.out.print(i + &quot; &quot;);
}
}
};
t.start();
}
}
Runnable 接口的匿名内部类实现
public class Demo {
public static void main(String[] args) {
Runnable r = new Runnable() {
public void run() {
for (int i = 1; i &lt;= 5; i++) {
System.out.print(i + &quot; &quot;);
}
}
};
Thread t = new Thread(r);
t.start();
}
}</p>
<h3>静态嵌套类</h3>
<p>一个静态嵌套类是被标记为 static 的内部类。
静态嵌套类无法访问外部类的非静态成员。
嵌套类被分为两类：静态和非静态的。被声明为 static 的被称作静态嵌套类，非静态嵌套类就是内部类</p>
<p>例如：</p>
<pre><code>class Outer{
   static class Nested{}
}
静态嵌套类可以被这样实例化：

class Outer{// outer class
   static class Nested{}// static nested class
}

class Demo{
   public static void main(string[] args){
      // use both class names
      Outer.Nested n= new Outer.Nested();
   }
}</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/03/Java/final关键字用法2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/03/Java/final关键字用法2/" itemprop="url">final关键字用法2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-03T09:40:37+08:00">
                2018-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文转自：<a href="http://wiki.jikexueyuan.com/project/java-enhancement/java-fifteen.html" target="_blank" rel="external">原文链接</a></p>
<p>在程序设计中，我们有时可能希望某些数据是不能够改变的，这个时候 final 就有用武之地了。final 是 Java 的关键字，它所表示的是“这部分是无法修改的”。不想被改变的原因有两个：效率、设计。使用到 final 的有三种情况：数据、方法、类。</p>
<p><strong>一、final 数据</strong>
有时候数据的恒定不变是很有用的，它能够减轻系统运行时的负担。对于这些恒定不变的数据我可以叫做“常量”。“常量”主要应用与以下两个地方：</p>
<p>1、编译期常量，永远不可改变。</p>
<p>2、运行期初始化时，我们希望它不会被改变。</p>
<p>对于编译期常量，它在类加载的过程就已经完成了初始化，所以当类加载完成后是不可更改的，编译期可以将它代入到任何用到它的计算式中，也就是说可以在编译期执行计算式。当然对于编译期常量，只能使用基本类型，而且必须要在定义时进行初始化。</p>
<p>有些变量，我们希望它可以根据对象的不同而表现不同，但同时又不希望它被改变，这个时候我们就可以使用运行期常量。对于运行期常量，它既可是基本数据类型，也可是引用数据类型。基本数据类型不可变的是其内容，而引用数据类型不可变的是其引用，引用所指定的对象内容是可变的。</p>
<pre><code>public class Person {
    private String name;

    Person(String name){
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

public class FinalTest {
    private final String final_01 = &quot;chenssy&quot;;    //编 译期常量，必须要进行初始化，且不可更改
    private final String final_02;                //构造器常量，在实例化一个对象时被初始化

    private static Random random = new Random();
    private final int final_03 = random.nextInt(50);    //使用随机数来进行初始化

    //引用
    public final Person final_04 = new Person(&quot;chen_ssy&quot;);    //final指向引用数据类型

    FinalTest(String final_02){
        this.final_02 = final_02;
    }

    public String toString(){
        return &quot;final_01 = &quot; + final_01 +&quot;   final_02  = &quot; + final_02 + &quot;   final_03 = &quot; + final_03 +
               &quot;   final_04 = &quot; + final_04.getName();
    }

    public static void main(String[] args) {
        System.out.println(&quot;------------第一次创建对象------------&quot;);
        FinalTest final1 = new FinalTest(&quot;cm&quot;);
        System.out.println(final1);
        System.out.println(&quot;------------第二次创建对 象------------&quot;);
        FinalTest final2 = new FinalTest(&quot;zj&quot;);
        System.out.println(final2);
        System.out.println(&quot;------------修改引用对 象--------------&quot;);
        final2.final_04.setName(&quot;chenssy&quot;);
        System.out.println(final2);
    }
}

------------------
Output:
------------第一次创建对象------------
final_01 = chenssy   final_02 = cm   final_03 = 34    final_04 = chen_ssy
------------第二次创建对象------------
final_01 = chenssy   final_02 = zj   final_03 = 46   final_04 = chen_ssy
------------修改引用对象--------------
final_01 = chenssy   final_02 = zj   final_03 = 46   final_04 = chenssy
</code></pre>
<p>这里只阐述一点就是：不要以为某些数据是 final 就可以在编译期知道其值，通过 final_03 我们就知道了，在这里是使用随机数其进行初始化，他要在运行期才能知道其值。</p>
<p><strong>二、final 方法</strong>
所有被 final 标注的方法都是不能被继承、更改的，所以对于 final 方法使用的第一个原因就是方法锁定，以防止任何子类来对它的修改。至于第二个原因就是效率问题，鄙人对这个效率问题理解的不是很清楚，在网上摘抄这段话：</p>
<p>在 Java 的早期实现中，如果将一个方法指明为 final，就是同意编译器将针对该方法的所有调用都转为内嵌调用。当编译器发现一个 final 方法调用命令时，它会根据自己的谨慎判断，跳过插入程序代码这种正常的调用方式而执行方法调用机制（将参数压入栈，跳至方法代码处执行，然后跳回并清理栈中的参数，处理返回值），并且以方法体中的实际代码的副本来代替方法调用。这将消除方法调用的开销。当然，如果一个方法很大，你的程序代码会膨胀，因而可能看不到内嵌所带来的性能上的提高，因为所带来的性能会花费于方法内的时间量而被缩减。
对这段话理解我不是很懂就照搬了，那位 Java 牛人可以解释解释下！！</p>
<p>父类的 final 方法是不能被子类所覆盖的，也就是说子类是不能够存在和父类一模一样的方法的。</p>
<pre><code>public class Custom extends Person{
    public void method1(){
        System.out.println(&quot;Person's  method1....&quot;);
    }

//    Cannot override the final method from person：子类不能覆盖父类的final方法
//    public void method2(){
//        System.out.println(&quot;Person's method2...&quot;);
//    }
}
</code></pre>
<p><strong>三、final 类</strong></p>
<p>如果某个类用 final 修改，表明该类是最终类，它不希望也不允许其他来继承它。在程序设计中处于安全或者其他原因，我们不允许该类存在任何变化，也不希望它有子类，这个时候就可以使用 final 来修饰该类了。</p>
<p>对于 final 修饰的类来说，它的成员变量可以为 final，也可以为非 final。如果定义为 final，那么 final 数据的规则同样适合它。而它的方法则会自动的加上 final，因为 final 类是无法被继承，所以这个是默认的。</p>
<p><strong>四、final 参数</strong></p>
<p>在实际应用中，我们除了可以用 final 修饰成员变量、成员方法、类，还可以修饰参数、若某个参数被 final 修饰了，则代表了该参数是不可改变的。</p>
<p>如果在方法中我们修改了该参数，则编译器会提示你：The final local variable i cannot be assigned. It must be blank and not using a compound assignment。</p>
<pre><code>public class Custom {
    public void test(final int i){
        //i++;     ---final参数不可改变
        System.out.println(i);
    }

    public void test(final Person p){
     //p = new Person();    --final参数不可变
     p.setName(&quot;chenssy&quot;);
    }
}
</code></pre>
<p>同 final 修饰参数在内部类中是非常有用的，在匿名内部类中，为了保持参数的一致性，若所在的方法的形参需要被内部类里面使用时，该形参必须为 final。详情参看：<a href="http://www.cnblogs.com/chenssy/p/3390871.html" target="_blank" rel="external">链接</a>。</p>
<p><strong>五、final 与 static</strong></p>
<p>final 和 static 在一起使用就会发生神奇的化学反应，他们同时使用时即可修饰成员变量，也可修饰成员方法。</p>
<p>对于成员变量，该变量一旦赋值就不能改变，我们称它为“全局常量”。可以通过类名直接访问。</p>
<p>对于成员方法，则是不可继承和改变。可以通过类名直接访问。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/02/Java/Java相关名词概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/02/Java/Java相关名词概念/" itemprop="url">Java移位运算</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-02T19:05:34+08:00">
                2018-02-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java里面有很多名词，刚入门的新手肯定有很多名词不知道其意，这里简要总结，详细阐述见其它博客。</p>
<p><strong>J2EE</strong>
全称Java 2 Enterprise Edition，是Java的一种企业版，用于企业级应用开发。</p>
<p><strong>J2SE</strong>
全称Java 2 Standard Edition，是Java的标准版，用于标准应用开发，也是Java基础版本。</p>
<p><strong>J2ME</strong>
全称Java 2 Micro Edition，是Java的微型版，用于手机、PDA等嵌入式开发，针对手机开发，还有专门的J2ME Wireless Toolkit免费套件提供。</p>
<p>总而言之，J2EE,J2SE,J2ME是java针对不同使用范畴提供不同的服务，也就是提供不同类型的类库。针对企业应用的J2EE（Java 2 Enterprise Edition）、针对普通PC应用的J2SE（Java 2 Standard Edition）和针对嵌入式设备及消费类电器的J2ME（Java 2 Micro Edition）三个版本。</p>
<p><strong>EJB</strong>
EJB是sun的JavaEE服务器端组件模型，设计目标与核心应用是部署分布式应用程序。简单来说就是把已经编写好的程序（即：类）打包放在服务器上执行。凭借java跨平台的优势，用EJB技术部署的分布式系统可以不限于特定的平台。EJB (Enterprise JavaBean)是J2EE(javaEE)的一部分，定义了一个用于开发基于组件的企业多重应用程序的标准。</p>
<p><strong>SDK</strong>
全称Software Develop Kit，软件开发工具包，用于帮助开发人员提高开发效率。各种不同类型的软件开发，都可以有自己的SDK。Windows有Windows SDK，DirectX 有 DirectX 9 SDK，.NET开发也有Microsoft .NET Framework SDK。JAVA开发当然也有自己的Java SDK。</p>
<p><strong>JDK</strong>
全称Java development toolkit，相当于是Java的库函数，是编译、运行java程序的工具包，是一切java应用程序的基础,所有java应用程序是构建在这个之上的。它是一组API，也可以说是一些java Class。JDK作为Java开发工具包，主要用于构建在Java平台上运行的应用程序、Applet 和组件等，目前ORACLE官网介绍看，JDK属于SDK的一部分，JDK和SDK一起发行的。</p>
<p><strong>JRE</strong>
全称Java Runtime Environment，Java运行环境，也就是Java平台。所有的Java程序都要在JRE下才能运行。JDK的工具也是Java程序，也需要JRE才能运行。为了保持JDK的独立性和完整性，在JDK的安装过程中，JRE也是安装的一部分。所以，目前ORACLE官网介绍看，JRE则属于JDK的一部分，如果不想开发，只是想跑跑JAVA程序，官网可以下载到单独的JRE包，但如果要开发，还是需安装上面的JDK。</p>
<p><strong>JVM</strong>
全称Java Virtual Machine，Java虚拟机，是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完 善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。JAVA虚拟机JVM是属于JRE的，而现在我们安装JDK时也附带安装了JRE（当然也可以单独安装JRE）。</p>
<p><strong>IoC</strong>
控制反转（Inversion of Control，英文缩写为IoC）把创建对象的权利交给框架,是框架的重要特征，并非面向对象编程的专用术语。它包括依赖注入（Dependency Injection，简称DI）和依赖查找（Dependency Lookup）。IoC不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</p>
<p><strong>AOP</strong>
在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<p><strong>JavaBean</strong>
JavaBean 是一种JAVA语言写成的可重用组件。为写成JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性，set和get方法获取。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/31/Java/Java移位运算符/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/31/Java/Java移位运算符/" itemprop="url">Java移位运算</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-31T11:30:45+08:00">
                2018-01-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JAVA 中有以上三种移位符号，那么下面的输出是什么呢？</p>
<pre><code>System.out.println(0xff &gt;&gt;&gt; 7);

System.out.println((((byte) 0xff) &gt;&gt;&gt; 7));

System.out.println((byte) (((byte) 0xff) &gt;&gt;&gt; 7));
</code></pre>
<p>1、三种移位符号的意义是什么？</p>
<pre><code>&gt;&gt; 是带符号右移，若左操作数是正数，则高位补“0”，若左操作数是负数，则高位补“1”.
&lt;&lt; 将左操作数向左边移动，并且在低位补0.
&gt;&gt;&gt; 是无符号右移，无论左操作数是正数还是负数，在高位都补“0”
</code></pre>
<p>2、三种移位符号作用的左操作数有五种：long,int,short,byte,char,但是在作用不同的操作数类型时，其具体过程不同, 遵循一下几个原则：</p>
<p>a : int移位时，左边的操作数是32位的，此时的移位符号作用在32位bit上。如：1 &gt;&gt; 3, 是将00000000 00000000 00000000 00000001这32位向右边移动3位。</p>
<p>b: long 移位时，左边的操作数是64位的，此时移位符号作用在64位bit上。如：1L &gt;&gt; 3。</p>
<p>c: short, byte,char 在移位之前首先将数据转换为int，然后再移位，此时移位符号作用在32为bit上。如：(byte)0xff &gt;&gt;&gt; 7, 是将11111111 11111111 11111111 11111111向右边移动7位，得到00000001 11111111 11111111 11111111, 所以结果不是你所期望的1，呵呵。</p>
<p>3、有1,2可知，当左操作数是long时，移位之后得到的类型是long，当左操作数是其它四中类型时，移位之后得到的类型是int，所以如果做操作数是byte,char,short 时，你用　&gt;&gt;=,&gt;&gt;&gt;=, &lt;&lt;= 其实是将得到的int 做低位截取得到的数值。这里往往容易犯错。</p>
<p>４、三种移位符号除了对做操作数有操作规则外，其实对右操作数也有操作规则。如果左操作数（转换之后的）是int,那么右操作数只有低５位有效，为什么?因为int 总共就32位，如：23 &gt;&gt; 33, 结果与23 &gt;&gt;1是一样的，都是11；同理，如果左边操作数是long，那么右边操作数只有低6位有效。</p>
<pre><code>System.out.println(0xff &gt;&gt;&gt; 7);
</code></pre>
<p>0xff 本身就是一个int，其bits为：00000000 00000000 00000000 11111111，无符号向右移动7位， 得到的bits当然为：00000000 00000000 00000000 00000001，</p>
<pre><code>System.out.println((((byte) 0xff) &gt;&gt;&gt; 7));
</code></pre>
<p>(byte)0xff 是一个byte，bits为： 11111111， 首先转换为int，其bits为：11111111 11111111 11111111 11111111， 向右边无符号移动7为，得到的结果bits是：00000001 11111111 11111111 11111111。</p>
<pre><code>System.out.println((byte) (((byte) 0xff) &gt;&gt;&gt; 7));
</code></pre>
<p>(byte) 0xff 是一个byte，bits为： 11111111， 首先转换为int，其bits为：11111111 11111111 11111111 11111111，向右边无符号移动7为，得到的结果bits是：00000001 11111111 11111111 11111111，然后转换为byte，低位截取得到bits: 11111111, 在输出的时候转换为int， 其bits为：11111111 11111111 11111111 11111111.</p>
<p>上面三个的结果是：</p>
<pre><code>1
33554431
-1</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/30/Java/final关键字用法1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/30/Java/final关键字用法1/" itemprop="url">final关键字用法1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-30T23:52:32+08:00">
                2018-01-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.修饰数据</p>
<p>在java中，用final关键字修饰的变量，只能进行一次赋值操作，并且在生存期内不可以改变它的值。在针对基本类型和引用类型时，final关键字的效果存在细微差别。例子：</p>
<pre><code>class Value {
    int v;
    public Value(int v) {
        this.v = v;
    }
}

public class FinalTest {
    
    final int f1 = 1;
    final int f2;
    public FinalTest() {
        f2 = 2;
    }

    public static void main(String[] args) {
        final int value1 = 1;
        // value1 = 4;
        final double value2;
        value2 = 2.0;
        final Value value3 = new Value(1);
        value3.v = 4;
    }
}
</code></pre>
<p>给value1赋初始值之后，我们无法再对value1的值进行修改，final关键字起到了常量的作用;从value2我们可以看到，final修饰的变量可以不在声明时赋值，即可以先声明，后赋值;value3时一个引用变量，final修饰引用变量时，只是限定了引用变量的引用不可改变，即不能将value3再次引用另一个Value对象，但是引用的对象的值是可以改变的。</p>
<p>引用变量的值实际上是它所引用的对象的地址，该地址的值是不可改变的，实际引用的对象实际上是不受final关键字的影响的，所以它的值是可以改变的。因为final修饰的数据的值是不可改变的，所以我们必须确保在使用前就已经对成员变量赋值了。因此对于final修饰的成员变量，我们有且只有两个地方可以给它赋值，一个是声明该成员时赋值，另一个是在构造方法中赋值。</p>
<p>2.修饰方法参数</p>
<p>编写方法时，可以在参数前面添加final关键字，它表示在整个方法中，不能改变参数的值：</p>
<pre><code>public class FinalTest {

    /* ... */

    public void finalFunc(final int i, final Value value) {
        // i = 5; 不能改变i的值
        // v = new Value(); 不能改变v的值
        value.v = 5; // 可以改变引用对象的值
    }
}
</code></pre>
<p>3.修饰方法</p>
<p>第三种方式，即用final关键字修饰方法，它表示该方法不能被覆盖。关于private和final关键字还有一点联系，这就是类中所有的private方法都隐式地指定为是final的，由于无法在类外使用private方法，所以也就无法覆盖它。</p>
<p>4.修饰类</p>
<p>用final修饰的类是无法被继承的。</p>
<p>总结</p>
<p>final关键字是我们经常使用的关键字之一，它的主要用法有以下四种：</p>
<ul>
<li>用来修饰数据，包括成员变量和局部变量，该变量只能被赋值一次且它的值无法被改变。对于成员变量来讲，我们必须在声明时或者构造方法中对它赋值；</li>
<li>用来修饰方法参数，表示在变量的生存期中它的值不能被改变；</li>
<li>修饰方法，表示该方法无法被重写；</li>
<li>修饰类，表示该类无法被继承。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/29/Nginx/Nginx基本概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/29/Nginx/Nginx基本概念/" itemprop="url">nginx基础概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-29T20:23:42+08:00">
                2018-01-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3>connection</h3>
<p>在nginx中connection就是对tcp连接的封装，其中包括连接的socket，读事件，写事件。nginx连接上限与系统对fd的限制不一样。nginx在实现时，是通过一个连接池来管理的，每个worker进程都有一个独立的连接池，连接池的大小是worker_connections。连接池里面保存的其实不是真实的连接，它只是一个worker_connections大小的一个ngx_connection_t结构的数组。nginx会通过一个链表free_connections来保存所有的空闲ngx_connection_t，每次获取一个连接时，就从空闲连接链表中获取一个，用完后，再放回空闲连接链表里面。（worker_connections表示每个worker进程所能建立连接的最大值）</p>
<h3>request</h3>
<p>nginx指的是http请求，具体到nginx中的数据结构是ngx_http_request_t，是对一个http请求的封装。处理流程图：
<img src="http://tengine.taobao.org/book/_images/chapter-2-2.PNG" alt=""></p>
<h3>请求相关的概念</h3>
<h3>keepalive</h3>
<p>http请求是基于TCP协议之上的，客户端在发起请求前，需要先与服务端建立TCP连接，需要三次握手来确定的，三次交互也会带来网络流量。http请求是请求应答式的，如果能知道每个请求头与响应体的长度，可以在一个连接上面执行多个请求的，这就是长连接。</p>
<h3>http协议中关于响应body长度的确定：</h3>
<p>对于http1.0协议，如果响应头中有content-length头，则以content-length的长度就可以知道body的长度了，客户端在接收body时，就可以依照这个长度来接收数据。而如果没有content-length头，则客户端会一直接收数据，直到服务端主动断开连接，才表示body接收完了。
对于http1.1协议，如果响应头中的Transfer-encoding为chunked传输，则表示body是流式输出，body会被分成多个块，每块的开始会标识出当前块的长度，此时，body不需要通过长度来指定。如果是非chunked传输，而且有content-length，则按照content-length来接收数据。否则，如果是非chunked，并且没有content-length，则客户端接收数据，直到服务端主动断开连接。</p>
<p>当服务端在输出完body之后，会可以考虑使用长连接。如果客户端的请求头中的connection为close，则表示客户端需要关掉长连接；如果为keep-alive，则客户端需要打开长连接；如果客户端的请求中没有connection这个头，那么根据协议，http1.0默认为close，http1.1默认为keep-alive。如果结果为keepalive，nginx在输出完响应体后，会设置当前连接的keepalive属性，然后等待客户端下一次请求。当然，nginx不可能一直等待下去，当nginx设置了keepalive等待下一次的请求时，同时也会设置一个最大等待时间，这个时间是通过选项keepalive_timeout来配置的，如果配置为0，则表示关掉keepalive，强制为close。</p>
<h3>pipe</h3>
<p>在http1.1中，引入了一种新的特性，即pipeline。它可以看作为keepalive的一种升华，因为pipeline也是基于长连接的，目的就是利用一个连接做多次请求。如果客户端要提交多个请求，对keepalive来说，第二个请求必须要等到第一个请求的响应接收完全后，才能发起，这和TCP的停止等待协议是一样的，得到两个响应的时间至少为2<em>RTT。对pipeline来说，客户端不必等到第一个请求处理完后，就可以马上发起第二个请求，得到两个响应的时间可能能够达到1</em>RTT。
nginx对pipeline中的多个请求的处理却不是并行的，依然是一个请求接一个请求的处理，只是在处理第一个请求的时候，客户端就可以发起第二个请求。nginx利用pipeline减少了处理完一个请求后等待第二个请求的请求头数据的时间。nginx在读取数据时，会将读取的数据放到一个buffer里面，如果nginx在处理完前一个请求后，如果发现buffer里面还有数据，就认为剩下的数据是下一个请求的开始，然后就接下来处理下一个请求，否则就设置keepalive。</p>
<h3>lingering_close</h3>
<p>lingering_close就是延迟关闭，当nginx要关闭连接时，并非立即关闭连接，而是先关闭tcp连接的写，再等待一段时间后再关掉连接的读。考虑以下场景：nginx在接收客户端的请求时，可能由于客户端或服务端出错了，要立即响应错误信息给客户端，而nginx在响应错误信息后，大分部情况下是需要关闭当前连接。nginx执行完write()系统调用把错误信息发送给客户端，write()系统调用返回成功并不表示数据已经发送到客户端，有可能还在tcp连接的write buffer里。接着如果直接执行close()系统调用关闭tcp连接，内核会首先检查tcp的read buffer里有没有客户端发送过来的数据留在内核态没有被用户态进程读取，如果有则发送给客户端RST报文来关闭tcp连接丢弃write buffer里的数据，如果没有则等待write buffer里的数据发送完毕，然后再经过正常的4次分手报文断开连接。所以,当在某些场景下出现tcp write buffer里的数据在write()系统调用之后到close()系统调用执行之前没有发送完毕，且tcp read buffer里面还有数据没有读，close()系统调用会导致客户端收到RST报文且不会拿到服务端发送过来的错误信息数据。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/29/Nginx/Nginx架构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/29/Nginx/Nginx架构/" itemprop="url">nginx架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-29T20:18:27+08:00">
                2018-01-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>nginx在启动后，在unix系统中会以daemon的方式在后台运行，后台进程包含一个master进程和多个worker进程。</p>
<p>nginx进程模型图：
<img src="http://tengine.taobao.org/book/_images/chapter-2-1.PNG" alt=""></p>
<p>master进程接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。而基本的网络事件，则是放在worker进程中来处理了。多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。</p>
<p>每个worker进程都是从master进程fork过来，在master进程里面，先建立好需要listen的socket（listenfd）之后，然后再fork出多个worker进程。所有worker进程的listenfd会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有worker进程在注册listenfd读事件前抢accept_mutex，抢到互斥锁的那个进程注册listenfd读事件，在读事件里调用accept接受该连接。当一个worker进程在accept这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，一个请求，只在一个worker进程中处理。</p>
<p>进程模型好处：对于每个worker进程来说，独立的进程，不需要加锁；采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断；worker进程的异常退出，会导致当前worker上的所有请求失败，不会影响到所有请求，降低了风险。</p>
<p>nginx采用了异步非阻塞的方式来处理请求，即利用select|poll|epoll|kqueue这样的库函数。它们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回，当读写返回EAGAIN时，我们将它再次加入到epoll里面（以epoll为例）。</p>
<p>为什么要推荐设置worker的个数为cpu的核数？更多的worker数，只会导致进程来竞争cpu资源了，从而带来不必要的上下文切换。nginx提供了cpu亲缘性的绑定选项,不会因为进程的切换带来cache的失效。</p>
<p>对于一个基本的web服务器来说，事件通常有三种类型，网络事件、信号、定时器。首先，信号的处理，如果nginx正在等待事件（epoll_wait时），如果程序收到信号，在信号处理函数处理完后，epoll_wait会返回错误，然后程序可再次进入epoll_wait调用。定时器的处理，由于epoll_wait等函数在调用的时候是可以设置一个超时时间的，所以nginx借助这个超时时间来实现定时器。nginx里面的定时器事件是放在一颗维护定时器的红黑树里面，每次在进入epoll_wait前，先从该红黑树里面拿到所有定时器事件的最小时间，在计算出epoll_wait的超时时间后进入epoll_wait。所以，当没有事件产生，也没有中断信号时，epoll_wait会超时，定时器事件到了，nginx会检查所有的超时事件，将他们的状态设置为超时，然后再去处理网络事件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/29/Nginx/Nginx代码风格/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/29/Nginx/Nginx代码风格/" itemprop="url">Nginx代码风格</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-29T16:20:48+08:00">
                2018-01-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>一、基本原则</strong></p>
<ul>
<li>K&amp;R编码风格（偏BSD子类）。</li>
<li>每行不能超过80列。</li>
<li>不用TAB对齐，用空格。</li>
<li>默认对齐单元是4个空格。</li>
<li>除宏定义外，字母均为小写，单词间用下划线_间隔。</li>
<li>使用C方式的注释，不得使用//形式注释。</li>
<li>中缀运算符的前后须空一格，如3 + 2以及a &gt; 3。</li>
<li>逗号后须空一格，如foo(a, b, c);</li>
</ul>
<p><strong>二、风格图示</strong></p>
<p><img src="http://tengine.taobao.org/book/_images/code-style-1.JPG" alt="">
1、	if/while/for/switch语句的左花括号和关键字在同一行上，和括号之间空一个空格。
2、	else关键字和两个花括号在同一行上。
<img src="http://tengine.taobao.org/book/_images/code-style-2.JPG" alt="">
3、	文件开始的注释空一行。
4、	较为完整的代码块间的距离为空两行。如函数声明、函数定义之间等。
5、	函数声明或定义若一行显示不下，则函数原型空4个空格。
6、	结构体数组的花括号和内容之间空一个空格。
<img src="http://tengine.taobao.org/book/_images/code-style-3.JPG" alt="">
7、	结构体数组的左花括号放在同一行上。
8、	较大的结构体数组元素最开始空一行。
9、	元素内容上下对齐。
<img src="http://tengine.taobao.org/book/_images/code-style-4.JPG" alt="">
10、注释上下对齐。
<img src="http://tengine.taobao.org/book/_images/code-style-5.JPG" alt="">
11、函数调用折行时，参数上下对齐。
<img src="http://tengine.taobao.org/book/_images/code-style-6.JPG" alt="">
12、函数定义时，类型单独一行。
13、变量声明的类型上下排列按照从短到长的顺序。注意，最下面的变量的类型和名称间的空格为2-3个。一般情况下为2个，这是Nginx中最小的变量声明中类型和名称的距离。
14、变量名称上下对齐——字母对齐，不包括指针的*号。
<img src="http://tengine.taobao.org/book/_images/code-style-7.JPG" alt="">
15、结构体内变量上下对齐（字母，不包括指针的的*号）。
<img src="http://tengine.taobao.org/book/_images/code-style-8.JPG" alt="">
16、单行注释格式为/* something */
<img src="http://tengine.taobao.org/book/_images/code-style-9.JPG" alt="">
17、多行注释的格式为：</p>
<pre><code>/*
 * something
 */
</code></pre>
<p><img src="http://tengine.taobao.org/book/_images/code-style-10.JPG" alt="">
18、函数定义的左花括号独占一行。
19、switch语句中，switch和case关键字上下对齐。
<img src="http://tengine.taobao.org/book/_images/code-style-11.JPG" alt="">
20、当条件表达式过长需要折行时，关系运算符须位于下一行的行首，并与上一行的条件表达式的第一个字符对齐，同时右花括号须位于单独的一行，并与if/while等关键字对齐。
<img src="http://tengine.taobao.org/book/_images/code-style-12.JPG" alt="">
21、 else语句之前须空出一行。
<img src="http://tengine.taobao.org/book/_images/code-style-13.JPG" alt="">
22、在函数中，相同类型的变量声明放在一行上。</p>
<hr>
<p><strong>参考链接：</strong></p>
<ul>
<li><a href="http://tengine.taobao.org/book/appendix_a.html" target="_blank" rel="external">编码风格</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/01/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/01/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式05/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-01T19:56:56+08:00">
                2017-11-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3>Linux-Socket编程-TCP非阻塞方式05</h3>
<hr>
<ul>
<li>
<p><strong>测试程序tcp_server5，接受连接成功后，server 发数据（每次10 字节，间隔1 秒）并同时用大小100 的缓冲区收数据，死循环运行</strong></p>
</li>
<li>
<p><strong>测试程序tcp_client5-1，连接成功后，client 发数据（每次15 字节，间隔3 秒）并同时用大小100 的缓冲区收数据，死循环运行</strong></p>
</li>
<li>
<p><strong>Server 端先接受一个Client 端的连接，进入死循环读写状态</strong></p>
</li>
<li>
<p><strong>要求此时Server 能接受一个新的Client 端的连接，也进入死循环读写状态（Server 端一个程序维护一个listen socket 和多个accept 的socket，要保证accept 的socket 进入死循环读写的同时，仍然能接受新的Client 端的连接）</strong></p>
<p>利用select进行单进程并发。</p>
<p>将所有fds（包括listenfd, 所有connectfd）加入到allfds中管理；</p>
<pre><code>rfds=allfds; 
selres=select(maxfd+1, &amp;rfds, NULL, NULL, NULL);
</code></pre>
<p>selres&lt;0 判断是否为定时中断，可写时执行写操作；<br>
selres&gt;0<br>
若FD_ISSET(listenfd, &amp;rfds)有效，建立新的连接，新连接设置为非阻塞，加入到allfds中；
若其他连接的connectfd在FD_ISSET(connectfd, &amp;rfds)有效，进行读操作。</p>
<p>关键代码：</p>
<pre><code>for (i=0; i&lt;FD_SETSIZE; ++i) {
	client[i]=-1;
}
maxfd=listenfd;
maxi=-1;
FD_ZERO(&amp;allfds);
FD_SET(listenfd, &amp;allfds);

while(1) {
	rfds=allfds;
	wfds=allfds;

	selres=select(maxfd+1, &amp;rfds, NULL, NULL, NULL);
	if(selres&lt;0) {
		err=errno;
		if(err==EINTR) {
			wfds=allfds;
			selres = select(maxfd + 1, NULL, &amp;wfds, NULL, NULL);
			for (i=0; i&lt;=maxi; ++i) {
				if((connectfd=client[i])&lt;0)
					continue;
				if(FD_ISSET(connectfd, &amp;wfds)) {
					n = write(connectfd, writebuff, WRITE_SIZE);
					writebuff[n] = '\0';
					printf(&quot;server write %d bytes to client's fds %d \n&quot;, n, connectfd);
				}
			}
			continue;
		} else {
			printf(&quot;select error: %s(errno: %d)\n&quot;,strerror(errno),errno);
			exit(0);
		}
	}

	nready=selres;
	if(FD_ISSET(listenfd, &amp;rfds)) {
		if( (connectfd = accept(listenfd, (struct sockaddr*)NULL, NULL)) == -1) {
			printf(&quot;accept socket error: %s(errno: %d)\n&quot;,strerror(errno),errno);
			exit(0);
		}
		setNonBlock(connectfd);
		outputConnect(connectfd);
		for (i=0; i&lt;FD_SETSIZE; ++i) {
			if(client[i]&lt;0) {
				client[i]=connectfd;
				break;
			}
		}
		if(i==FD_SETSIZE) {
			printf(&quot;too many clients \n&quot;);
			exit(0);
		}

		FD_SET(connectfd, &amp;allfds);
		maxfd=maxfd&gt;connectfd? maxfd: connectfd;
		maxi=maxi&gt;i? maxi: i;

		if (--nready == 0)
			continue;
	}

	for (i = 0; i &lt;= maxi; i++) {
		if ( (connectfd = client[i]) &lt; 0)
			continue;
		if (FD_ISSET(connectfd, &amp;rfds)) {
			n = read(connectfd, readbuff, READ_SIZE);
			if (n == 0) {
				/* connection closed by client */
				if(close(connectfd) == -1) {
					printf(&quot;close socket error: %s(errno: %d)\n&quot;,strerror(errno),errno);
					exit(0);
				}
				printf(&quot;client fds %d closed \n&quot;, connectfd);
				FD_CLR(connectfd, &amp;allfds);
				client[i] = -1;
			} else {
				printf(&quot;server read %d bytes from client's fds %d\n&quot;, n, connectfd);
			}
			if (--nready == 0)
				break;
		}
	}
}
</code></pre>
<p>测试截图：</p>
<p>启动两个client：</p>
<p><img src="/2017/11/01/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式05/051.jpg" alt=""></p>
<p>关闭两个client：</p>
<p><img src="/2017/11/01/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式05/052.jpg" alt=""></p>
</li>
<li>
<p><strong>用两个会话窗口分别启动两个tcp_server5 （如：./tcp_server5 4000 ./tcp_server5 5000）</strong></p>
</li>
<li>
<p><strong>测试程序tcp_client5-2，运行时带两个端口号（例：./tcp_client5-2 192.168.80.230 40005000），表示在一个程序中建立两个socket，分别连接两个不同端口号的server 端，client发数据（每次15 字节，间隔3 秒）并同时用大小100 的缓冲区收数据，死循环运行，允许在不同会话窗口启动多个client 端</strong></p>
</li>
<li>
<p><strong>Server 端和Client 端均不允许采用分裂进程的方式，只能是一个程序</strong></p>
<p>tcp_client5-2 原理类似server程序，不再赘述。</p>
<p>测试截图：</p>
<p>启动两个server，启动两个client，每个client连接两个server。</p>
<p><img src="/2017/11/01/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式05/053.jpg" alt=""></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/01/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/01/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式04/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-01T19:53:56+08:00">
                2017-11-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3>Linux-Socket编程-TCP非阻塞方式04</h3>
<hr>
<ul>
<li>
<p><strong>测试程序tcp_server4-1，接受client 的连接成功后，用getchar()进入暂停运行状态</strong></p>
</li>
<li>
<p><strong>测试程序tcp_client4-1，连接服务端成功后，用write 向服务端不断写入，直到write 失败为止，用netstat 观察读写队列的值</strong></p>
<p>server端的recv-Q缓冲区达到一定大小时，不再接受，client端在server端recv-Q满后，写入到send-Q中，达到一定大小时，不能继续写入，select函数阻塞。</p>
<p>server端的recv-Q+client端的send-Q等于total write bytes。</p>
<p>测试截图：</p>
<p><img src="/2017/11/01/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式04/041.jpg" alt=""></p>
</li>
<li>
<p><strong>测试程序tcp_server4-2，接受client 的连接成功后，用每读20 字节就延时1 秒的方法循环读数据</strong></p>
</li>
<li>
<p><strong>测试程序tcp_client4-2，连接服务端成功后，用write 向服务端不断大量写入，直到write失败为止，用netstat 观察读写队列的值，write 失败后，如何重新恢复为继续写状态？</strong></p>
<p>client向server不断大量写入后，缓冲区慢，write失败。这时只有当server读取一定数据后，使得client发送缓冲区留有空间大于write的低水位大小时，select返回有效，可继续写入。</p>
<p>测试截图：</p>
<p><img src="/2017/11/01/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式04/042.jpg" alt=""></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/01/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/01/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式03/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-01T19:45:00+08:00">
                2017-11-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3>Linux-Socket编程-TCP非阻塞方式03</h3>
<hr>
<ul>
<li>
<p><strong>测试程序tcp_server3-1/tcp_client3-1，连接成功后，server 发数据（每次10 字节，间隔1 秒）并同时用大小100 的缓冲区收数据，client 发数据（每次15 字节，间隔3 秒）并同时用大小100 的缓冲区收数据，死循环运行</strong></p>
</li>
<li>
<p><strong>注意：死循环中不是先发送若干字节、延时、再收若干字节，而是读写并发，以client 端为例，相当于打印信息为收3 次，发1 次（也可能是其它收发值）</strong></p>
<p>在非阻塞服务端编程中，绝对不能用 sleep 或类似的办法来让程序原地停留等待，这会让程序失去响应，因为主事件循环被挂起了，无法处理 IO 事件。这就像在 Windows 编程中绝对不能在消息循环里执行耗时的代码一样，会让程序界面失去响应。</p>
<p>利用select+定时器，当发生定时信号SIGALRM后，select函数中断，返回-1，错误号errno=EINTR(4),这时进行写入。</p>
<p>定时器:</p>
<pre><code>#include &lt;unistd.h&gt;
unsigned int alarm(unsigned int seconds);
</code></pre>
<p>非阻塞函数，定时时间到了就发送SIGALRM信号，如果在alarm之前已经调用了alarm并且时间没有到的话，那么此次返回之前alarm剩余的时间，否则返回0。</p>
<p>以server端为例，关键代码如下：</p>
<p>定时信号产生后执行函数</p>
<pre><code>#define ALARM_SECOND 1
void do_alarm(int i) {
	alarm(ALARM_SECOND);
}
</code></pre>
<p>主函数中写法</p>
<pre><code>if(signal(SIGALRM , do_alarm) == SIG_ERR) {
	printf(&quot;register alarm error: %s(errno: %d)\n&quot;,strerror(errno),errno);
	exit(0);
}
alarm(ALARM_SECOND);

while(1) {
	FD_ZERO(&amp;rfds);
	FD_SET(connectfd, &amp;rfds);
	wfds=rfds;

	selres = select(connectfd + 1, &amp;rfds, NULL, NULL, NULL);
	if(selres&lt;0) {
		err=errno;
		if(err==EINTR) {
			selres = select(connectfd + 1, NULL, &amp;wfds, NULL, NULL);
			if(FD_ISSET(connectfd, &amp;wfds)) {
				n = write(connectfd, writebuff, WRITE_SIZE);
				writebuff[n] = '\0';
				printf(&quot;server write %d bytes\n&quot;, n);
			}
			continue;
		} else {
			printf(&quot;select error: %s(errno: %d)\n&quot;,strerror(errno),errno);
			exit(0);
		}
	}
	if(FD_ISSET(connectfd, &amp;rfds)) {
		n = read(connectfd, readbuff, READ_SIZE);
		readbuff[n] = '\0';
		printf(&quot;server read %d bytes\n&quot;, n);
	}
}
</code></pre>
<p>测试截图：</p>
<p><img src="/2017/11/01/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式03/031.jpg" alt=""></p>
</li>
<li>
<p><strong>测试程序tcp_server3-2/tcp_client3-2，连接成功后，server 发数据（每次10 字节，间隔1 秒）并同时用大小为88 的缓冲区收数据，能否在非阻塞模式下保证每次必须收到88 字节才返回，即每read 或recv 函数均返回读取了88 字节？(注：不允许采用自己写循环保证读满88 字节）client 发数据（每次15 字节，间隔3 秒）并同时用大小100 的缓冲区收数据，死循环运行</strong></p>
<p>SO_RCVLOWAT 和 SO_SNDLOWAT套接字选项</p>
<p>每个套接字还有一个接收低水位标记和一个发送低水位标记。由select函数使用，这两个套接字选项允许我们修改这两个低水位标记。接收低水位标记是让select返回“可读”时，套接字接收缓冲区中所需的数据量。对于TCP，UDP和SCTP套接字，其默认值为1。发送低水位标记是让select返回“可写”时套接字发送缓冲区中所需的可用空间。对于TCP套接字，其默认值通常为2048。</p>
<pre><code>#define READ_SIZE 88
int recv_min_size = READ_SIZE;
int flag = setsockopt(connectfd, SOL_SOCKET, SO_RCVLOWAT, (void *)&amp;recv_min_size, sizeof(int));
</code></pre>
<p>测试截图：</p>
<p><img src="/2017/11/01/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式03/032.jpg" alt=""></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/01/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/01/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式02/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-01T19:41:01+08:00">
                2017-11-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3>Linux-Socket编程-TCP非阻塞方式02</h3>
<hr>
<ul>
<li>
<p><strong>测试程序tcp_server2-1/tcp_client2-1，连接成功后，client 发数据（每次10 字节，间隔1 秒），server 用大小100 的缓冲区收数据，死循环运行</strong></p>
</li>
<li>
<p><strong>此时在client（server）端按CTRL+C，server（client）端能否检测到连接中断？</strong></p>
<p>client端ctrl+c后，server的connectfd仍可读，但是read函数返回0，说明client端已经关闭连接。</p>
<p>client端ctrl+c，运行示例：</p>
<p><img src="/2017/11/01/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式02/021.jpg" alt=""></p>
<p>server端ctrl+c后，client端会收到SIGPIPE信号，说明server已经关闭连接。</p>
<p>当服务器close一个连接时，若client端接着发数据。根据TCP协议的规定，会收到一个RST响应，client再往这个服务器发送数据时，系统会发出一个SIGPIPE信号给进程，告诉进程这个连接已经断开了，不要再写了。</p>
<p>根据信号的默认处理规则SIGPIPE信号的默认执行动作是terminate(终止、退出),所以client会退出。</p>
<p>若不想客户端退出可以把SIGPIPE设为SIG_IGN。如:<code>signal(SIGPIPE,SIG_IGN)</code>;这时SIGPIPE交给了系统处理。</p>
<p>signal设置的信号句柄只能起一次作用，信号被捕获一次后，信号句柄就会被还原成默认值了。<br>
sigaction设置的信号句柄，可以一直有效，直到你再次改变它的设置。</p>
<pre><code>struct sigaction action;
action.sa_handler = handle_pipe;
sigemptyset(&amp;action.sa_mask); //清空此信号集
action.sa_flags = 0;
sigaction(SIGPIPE, &amp;action, NULL);
</code></pre>
<p>server端ctrl+c，运行示例：</p>
<p><img src="/2017/11/01/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式02/022.jpg" alt=""></p>
</li>
<li>
<p><strong>如果新开一个会话窗口，用kill -9 杀client（server）端程序，server（client）端能否检测到连接中断？</strong></p>
<p>kill -9 结果与ctrl+c一样。</p>
<p>kill -9 client</p>
<p><img src="/2017/11/01/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式02/023.jpg" alt=""></p>
<p>kill -9 server</p>
<p><img src="/2017/11/01/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式02/024.jpg" alt=""></p>
</li>
<li>
<p><strong>测试程序tcp_server2-2/tcp_client2-2，连接成功后，server 发数据（每次10 字节，间隔1 秒），client 用大小100 的缓冲区收数据，死循环运行（同时观察2-1 的两种中断检测方式）</strong></p>
<p>与2-1一样，无论是ctrl+c或者kill -9， 一端关闭，若另一端在读数据，select返回rdfs有效，但是read返回0，判断为关闭； 一端关闭，若另一端在写，会收到SIGPIPE信号。</p>
<p>client端ctrl+c，运行示例：</p>
<p><img src="/2017/11/01/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式02/025.jpg" alt=""></p>
<p>server端ctrl+c，运行示例：</p>
<p><img src="/2017/11/01/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式02/026.jpg" alt=""></p>
<p>kill -9 client，运行示例：</p>
<p><img src="/2017/11/01/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式02/027.jpg" alt=""></p>
<p>kill -9 server，运行示例：</p>
<p><img src="/2017/11/01/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式02/028.jpg" alt=""></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/31/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/31/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式01/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-31T18:13:50+08:00">
                2017-10-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3>Linux-Socket编程-TCP非阻塞方式01</h3>
<hr>
<ul>
<li>
<p><strong>测试程序tcp_server1-1（源程序名任意，允许多个，C/C++语言任选，make 后得到tcp_server1即可，下同），运行后绑定某个TCP 端口号，并进入等待连接状态（下面称为LISTEN 状态），要求端口号通过main 函数带参数的方式传入（例：./tcp_server1 4000 表示绑定TCP 4000端口）</strong></p>
</li>
<li>
<p><strong>测试程序tcp_client1-1，运行时带入服务端IP 地址及端口号，即可向服务端发起连接，要求IP 地址、端口号通过main 函数带参数的方式传入（例：./tcp_client1 192.168.80.230 4000则表示连接192.168.80.230 的TCP 4000 端口）</strong></p>
</li>
<li>
<p><strong>Server 端用于listen 的socket，不设置为非阻塞方式，accept 成功后，将accept 的socket设置为非阻塞方式</strong></p>
</li>
<li>
<p><strong>Client 端建立的socket，先不设置为非阻塞方式，待connect 成功后，再设置为非阻塞方式</strong></p>
</li>
<li>
<p><strong>连接成功后，双方均进入read(recv)状态，read(recv)函数后直接关闭socket，程序退出</strong></p>
</li>
<li>
<p><strong>read(recv)函数的表现会如何？程序会阻塞在read(recv)还是立即结束？ read(recv)函数
返回什么？</strong></p>
<p>read(recv)函数不会阻塞，读取了0字节，read(recv)函数返回0。</p>
<p><img src="/2017/10/31/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式01/011.jpg" alt=""></p>
</li>
<li>
<p><strong>测试程序tcp_server1-2/tcp_client1-2，在1-1 的基础上，用select 使read(recv)停下来而不立即返回</strong></p>
<p>用select函数处于无限阻塞</p>
<pre><code>fd_set rfds;
FD_ZERO(&amp;rfds);
FD_SET(socket_fd, &amp;rfds);

int selres = select(socket_fd + 1, &amp;rfds, NULL, NULL, NULL);
</code></pre>
<p><img src="/2017/10/31/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式01/012.jpg" alt=""></p>
</li>
<li>
<p><strong>测试程序tcp_server1-3，要求socket 建立成功后，先设置非阻塞方式，再进行bind、listen和accept，accept 的新socket，也是立即设置为非阻塞方式，再进行后续操作</strong></p>
</li>
<li>
<p><strong>测试程序tcp_client1-3，要求socket 建立成功后，先设置非阻塞方式，再connect</strong></p>
</li>
<li>
<p><strong>要求tcp_client1-3 能连接tcp_server1-3 成功,并在连接成功后，使双方都停在read(recv)上而不立即返回</strong></p>
<p>server 非阻塞accpet失败后用select建立新的连接，核心代码：</p>
<pre><code>if( (connectfd = accept(listenfd, (struct sockaddr*)NULL, NULL)) == -1) {
	FD_ZERO(&amp;rfds);
	FD_SET(listenfd, &amp;rfds);
	selres = select(listenfd + 1, &amp;rfds, NULL, NULL, NULL);
	if(selres&lt;0) {
		perror(&quot;select error\n&quot;);
		exit(0);
	}

	if(FD_ISSET(listenfd, &amp;rfds)) {
		if( (connectfd = accept(listenfd, (struct sockaddr*)NULL, NULL)) == -1) {
			printf(&quot;accept socket error: %s(errno: %d)\n&quot;,strerror(errno),errno);
			exit(0);
		}
	}
}

setNonBlock(connectfd);
outputConnect(connectfd);
</code></pre>
<p>client端建立非阻塞连接时，select返回大于0，调用connect可能返回-1,若errno被设为EINPROGRESS,意即connect仍旧在进行还没有完成，需要时间建立，多次select。</p>
<pre><code>int nonBlockConnect(int socket_fd, struct sockaddr_in *servaddr) {
	fd_set rfds, wfds;
	struct timeval tv;
	int selres, conres, ret;

	conres=connect(socket_fd, (struct sockaddr*)servaddr, sizeof(struct sockaddr_in));
	if (0 == conres) {
		printf(&quot;socket connect succeed immediately.\n&quot;);
		ret=0;
	} else {
		printf(&quot;get the connect result by select().\n&quot;);
		if (errno == EINPROGRESS) {
			int times = 0;
			while (times++ &lt; 5) {
				FD_ZERO(&amp;rfds);
				FD_ZERO(&amp;wfds);
				FD_SET(socket_fd, &amp;rfds);
				FD_SET(socket_fd, &amp;wfds);

				tv.tv_sec = 10;
				tv.tv_usec = 0;
				selres=select(socket_fd + 1, &amp;rfds, &amp;wfds, NULL, &amp;tv);
				if(-1==selres) {
					printf(&quot;select error\n&quot;);
					ret = -1;
				} else if(0==selres) {
					printf(&quot;select time out\n&quot;);
					ret = -1;
				} else {
					if (FD_ISSET(socket_fd, &amp;rfds) || FD_ISSET(socket_fd, &amp;wfds)) {
						connect(socket_fd, (struct sockaddr *)servaddr, sizeof(struct sockaddr_in));
						int err = errno;
						if  (err == EISCONN) {
							printf(&quot;connect finished.\n&quot;);
							ret = 0;
						} else {
							printf(&quot;connect failed. errno = %d\n&quot;, errno);
							printf(&quot;FD_ISSET(socket_fd, &amp;rfds) :%d FD_ISSET(socket_fd, &amp;wfds) :%d\n&quot;,
							       FD_ISSET(socket_fd, &amp;rfds) , FD_ISSET(socket_fd, &amp;wfds));
							ret = errno;
						}
					}
				}

				if (-1 != selres &amp;&amp; (ret != 0)) {
					printf(&quot;check connect result again... times=%d\n&quot;, times);
					continue;
				} else {
					break;
				}
			}
		} else {
			printf(&quot;connect error: %s(errno: %d)\n&quot;,strerror(errno),errno);
			ret = errno;
			exit(0);
		}
	}
	return ret;
}
</code></pre>
<p><img src="/2017/10/31/Linux/homework/Linux-Socket编程-TCP非阻塞方式/Linux-Socket编程-TCP非阻塞方式01/013.jpg" alt=""></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/29/Major/栈空间和堆空间/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/29/Major/栈空间和堆空间/" itemprop="url">栈空间和堆空间</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-29T22:15:16+08:00">
                2017-10-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一个由C/C++编译的程序占用的内存分为以下几个部分：</p>
<p>1、栈区（stack）：又编译器自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构的栈。</p>
<p>2、堆区（heap）：一般是由程序员分配释放，若程序员不释放的话，程序结束时可能由OS回收，值得注意的是他与数据结构的堆是两回事，分配方式倒是类似于数据结构的链表。</p>
<p>3、全局区（static）：也叫静态数据内存空间，存储全局变量和静态变量，全局变量和静态变量的存储是放一块的，初始化的全局变量和静态变量放一块区域，没有初始化的在相邻的另一块区域，程序结束后由系统释放。</p>
<p>4、文字常量区：常量字符串就是放在这里，程序结束后由系统释放。</p>
<p>5、程序代码区：存放函数体的二进制代码。</p>
<p><strong>堆和栈的区别：</strong></p>
<p>1、由以上综述就可以得知，他们程序的内存分配方式不同。</p>
<p>2、申请和响应不同：</p>
<p>（1）申请方式：</p>
<p>stack由系统自动分配，系统收回；heap需要程序员自己申请，C中用函数malloc分配空间，用free释放，C++用new分配，用delete释放。</p>
<p>（2）申请后系统的响应：</p>
<p>栈：只要栈的剩余空间大于所申请的空间，体统将为程序提供内存，否则将报异常提示栈溢出。</p>
<p>堆：首先应该知道操作系统有一个记录内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请的空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete或free语句就能够正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会将多余的那部分重新放入空闲链表中。</p>
<p>3、申请的大小限制不同：</p>
<p>栈：在windows下，栈是向低地址扩展的数据结构，是一块连续的内存区域，栈顶的地址和栈的最大容量是系统预先规定好的，能从栈获得的空间较小。</p>
<p>堆：堆是向高地址扩展的数据结构，是不连续的内存区域，这是由于系统是由链表在存储空闲内存地址，自然堆就是不连续的内存区域，且链表的遍历也是从低地址向高地址遍历的，堆得大小受限于计算机系统的有效虚拟内存空间，由此空间，堆获得的空间比较灵活，也比较大。</p>
<p>4、申请的效率不同：</p>
<p>栈：栈由系统自动分配，速度快，但是程序员无法控制。</p>
<p>堆：堆是有程序员自己分配，速度较慢，容易产生碎片，不过用起来方便。</p>
<p>5、堆和栈的存储内容不同：</p>
<p>栈：在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令的地址，然后是函数的各个参数，在大多数的C编译器中，参数是从右往左入栈的，当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令。</p>
<p>堆：一般是在堆得头部用一个字节存放堆得大小，具体内容由程序员安排</p>
<hr>
<p><strong>参考链接：</strong></p>
<ul>
<li><a href="http://www.cnblogs.com/kevinGaoblog/archive/2012/03/23/2413102.html" target="_blank" rel="external">参考1</a></li>
<li><a href="http://www.jianshu.com/p/2a06728d583c" target="_blank" rel="external">参考2</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/29/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式06/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/29/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式06/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-29T12:15:50+08:00">
                2017-10-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3>Linux-Socket编程-TCP阻塞方式06</h3>
<hr>
<p>写一对TCP Socket 的测试程序，分为client 和server，分别运行在不同虚拟机上</p>
<ul>
<li>
<p><strong>测试程序tcp_server6-1，接受client 的连接成功后，进入死循环，死循环中先read 再write反复进行；测试程序tcp_client6-1，连接服务端成功后，也进入死循环，死循环中同样先read 再write 反复进行，此时双方能否正常收发数据？</strong></p>
<p>不能</p>
<p><img src="/2017/10/29/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式06/061.jpg" alt=""></p>
</li>
<li>
<p><strong>测试程序tcp_server6-2，接受client 的连接成功后，进入死循环，死循环中先write 再read反复进行；测试程序tcp_client6-2，连接服务端成功后，也进入死循环，死循环中也是先write 再read 反复进行，此时双方能否正常收发数据？</strong></p>
<ol>
<li>假设双方每次read/write 都是1000 字节</li>
</ol>
<p>能</p>
<p><img src="/2017/10/29/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式06/0621.jpg" alt=""></p>
<ol start="2">
<li>假设server 端每次read 1000 字节/write 500 字节，client 端每次read 500 字节write1000 字节</li>
</ol>
<p>能</p>
<p><img src="/2017/10/29/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式06/0622.jpg" alt=""></p>
<ol start="3">
<li>假设server 端每次read/write 是1000 字节，client 端每次read/write 是700 字节</li>
</ol>
<p>能</p>
<p><img src="/2017/10/29/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式06/0623.jpg" alt=""></p>
</li>
<li>
<p><strong>测试程序tcp_server6-3，接受client 的连接成功后，进入死循环，死循环中先write 再read反复进行；测试程序tcp_client6-3，连接服务端成功后，也进入死循环，死循环中先read再write 反复进行，此时双方能否正常收发数据？</strong></p>
<ol>
<li>假设双方每次read/write 都是1000 字节</li>
</ol>
<p>能</p>
<p><img src="/2017/10/29/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式06/0631.jpg" alt=""></p>
<ol start="2">
<li>假设server 端每次read 1000 字节/write 500 字节，client 端每次read 500 字节write1000 字节</li>
</ol>
<p>能</p>
<p><img src="/2017/10/29/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式06/0632.jpg" alt=""></p>
<ol start="3">
<li>假设server 端每次read/write 是1000 字节，client 端每次read/write 是700 字节</li>
</ol>
<p>能</p>
<p><img src="/2017/10/29/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式06/0633.jpg" alt=""></p>
</li>
<li>
<p><strong>测试程序tcp_server6-4，接受client 的连接成功后，进入死循环，死循环中先read 再write反复进行；测试程序tcp_client6-4，连接服务端成功后，也进入死循环，死循环中先write再read 反复进行，此时双方能否正常收发数据？</strong></p>
<ol>
<li>假设双方每次read/write 都是1000 字节</li>
</ol>
<p>能</p>
<p><img src="/2017/10/29/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式06/0641.jpg" alt=""></p>
<ol start="2">
<li>假设server 端每次read 1000 字节/write 500 字节，client 端每次read 500 字节write1000 字节</li>
</ol>
<p>能</p>
<p><img src="/2017/10/29/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式06/0642.jpg" alt=""></p>
<ol start="3">
<li>假设server 端每次read/write 是1000 字节，client 端每次read/write 是700 字节</li>
</ol>
<p>能</p>
<p><img src="/2017/10/29/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式06/0643.jpg" alt=""></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/28/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/28/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式05/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-28T19:45:25+08:00">
                2017-10-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3>Linux-Socket编程-TCP阻塞方式05</h3>
<hr>
<p>写一对TCP Socket 的测试程序，分为client 和server，分别运行在不同虚拟机上</p>
<ul>
<li>
<p><strong>测试程序tcp_server5-1，接受client 的连接成功后，用一句getchar()进入等待输入状态</strong></p>
</li>
<li>
<p><strong>测试程序tcp_client5-1，连接服务端成功后，用write 函数不断向服务端写入数据（加计数
器统计写入了多少字节），大约写入多少字节后会使write 函数不再返回（阻塞状态）</strong></p>
<p>第一次阻塞</p>
<p><img src="/2017/10/28/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式05/051.jpg" alt=""></p>
<p>阻塞解除</p>
<p><img src="/2017/10/28/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式05/052.jpg" alt=""></p>
<p>再次阻塞后解除</p>
<p><img src="/2017/10/28/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式05/053.jpg" alt=""></p>
</li>
<li>
<p><strong>server 端在getchar()后用read 进行读（假设每次读n 个字节），读入多少字节后，client
端的write 函数可以返回？这说明了什么问题？</strong></p>
<p><strong>socket缓冲区</strong></p>
<p>每个 socket 创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。</p>
<p>write()/send() 并不会立刻向网络中传输数据，而是先将数据写入缓冲区，再由TCP协议将数据从缓冲区发送到目标机器。一旦数据写入到缓冲区，函数就可以成功返回。不管它们有没有到达 目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。</p>
<p>read()/recv() 函数也是如此，从输入缓冲区中读取数据，而不是直接从网络中读取。</p>
<p><strong>socket阻塞模式</strong></p>
<p>对于TCP套接字，默认情况下是属于阻塞模式，当使用 write() / send() 发送数据时：</p>
<ol>
<li>
<p>首先会检查缓冲区，如果缓冲区的可用空间长度 小于 要发送的数据，那么 write() / send() 会被阻塞，直到缓冲区中的数据被发送到目标机器，腾出足够的空间，才唤醒 write() / send() 函数 继续写入数据。</p>
</li>
<li>
<p>如果TCP协议正在向网络发送数据，那么输出缓冲区会被锁定，不允许写入， write() / send() 会被阻塞，直到数据发送完毕缓冲区解锁， write() / send() 才会被唤醒。</p>
</li>
<li>
<p>如果要写入的数据大于缓冲区的最大长度，那么将分批写入，直到所有数据都写入缓冲区 write() / send() 才能返回。</p>
</li>
</ol>
<p>当使用 read() / recv() 读取数据时：</p>
<ol>
<li>
<p>首选检查输入缓冲区，如果缓冲区中有数据，那么就读取，否则函数会阻塞，直到网络有数据的到来。</p>
</li>
<li>
<p>如果要读取的数据长度 小于 缓冲区中的数据长度，那么就不能一次性将缓冲区中的所有数据读出，剩余数据将吧不断积压，直到下次 read() / recv() 函数再次读取。</p>
</li>
<li>
<p>read() / recv() 调用，一定要等到读取到数据才会返回，否则就一直被阻塞。</p>
</li>
</ol>
</li>
<li>
<p><strong>在整个过程中用新会话打开终端后，用netstat 命令观察tcp 连接的各种信息（netstat 可以带哪些参数？显示的内容代表什么？）</strong></p>
<p>netstat命令用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况。</p>
<p><img src="/2017/10/28/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式05/054.jpg" alt=""></p>
<p>netstat命令输出说明：</p>
<pre><code>Proto
   套接字使用的协议。
Recv-Q
   连接此套接字的用户程序未拷贝的字节数。
Send-Q
   远程主机未确认的字节数。
Local Address
   套接字的本地地址(本地主机名)和端口号。除非给定-n选项，否则套接字地址
   按标准主机名(FQDN)进行解析，而端口号则转换到相应的服务名。
Foreign Address
   套接字的远程地址(远程主机名)和端口号。
   套接字的状态。因为在RAW协议中没有状态，而且UDP也不用状态信息，所以此行留空。
   通常它为以下几个值之一：
   ESTABLISHED
          套接字有一个有效连接。
   SYN_SENT
          套接字尝试建立一个连接。
   SYN_RECV
          从网络上收到一个连接请求。
   FIN_WAIT1
          套接字已关闭，连接正在断开。
   FIN_WAIT2
          连接已关闭，套接字等待远程方中止。
   TIME_WAIT
          在关闭之后，套接字等待处理仍然在网络中的分组
   CLOSED 套接字未用。
   CLOSE_WAIT
          远程方已关闭，等待套接字关闭。
   LAST_ACK
          远程方中止，套接字已关闭。等待确认。
   LISTEN 套接字监听进来的连接。如果不设置 (-l)或者(-a)
          选项，将不显示出来这些连接。
   CLOSING
          套接字都已关闭，而还未把所有数据发出。
   UNKNOWN
          套接字状态未知
User
   套接字属主的名称或UID。
PID/Program name
   以斜线分隔的处理套接字程序的PID及进程名
</code></pre>
</li>
<li>
<p><strong>测试程序tcp_server5-2/tcp_client_5-2，双方角色互换，即server 写至阻塞为止，然后
client 开始读，直到server 端解除阻塞，观察整个过程</strong></p>
<p>第一次阻塞</p>
<p><img src="/2017/10/28/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式05/055.jpg" alt=""></p>
<p>阻塞解除</p>
<p><img src="/2017/10/28/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式05/056.jpg" alt=""></p>
<p>再次阻塞后解除</p>
<p><img src="/2017/10/28/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式05/057.jpg" alt=""></p>
</li>
<li>
<p><strong>测试程序tcp_server5-3/tcp_client_5-3，功能同5-1，在其中通过设置函数改变TCP 收发
缓冲区大小，通过netstat 观察整个过程</strong></p>
<p>第一次阻塞</p>
<p><img src="/2017/10/28/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式05/058.jpg" alt=""></p>
<p>阻塞解除</p>
<p><img src="/2017/10/28/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式05/059.jpg" alt=""></p>
<p>再次阻塞后解除</p>
<p><img src="/2017/10/28/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式05/0510.jpg" alt=""></p>
</li>
</ul>
<p><strong>参考：</strong>
<a href="http://www.yangxg.com/blog/1225002879.html" target="_blank" rel="external">socket缓冲区以及阻塞模式</a>  <a href="http://man.linuxde.net/netstat" target="_blank" rel="external">netstat命令</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/28/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/28/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式04/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-28T16:05:36+08:00">
                2017-10-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3>Linux-Socket编程-TCP阻塞方式04</h3>
<hr>
<p>写一对TCP Socket 的测试程序，分为client 和server，分别运行在不同虚拟机上</p>
<ul>
<li>
<p><strong>测试程序tcp_server4-1，接受client 的连接成功后，用read 函数一次读20 字节（此时对
方无输入，应进入阻塞状态）</strong></p>
</li>
<li>
<p><strong>测试程序tcp_client4-1-1，连接服务端成功后，用write 函数向服务端一次性写入超过
20 字节的内容，观察sevrer 端read 函数的返回值和返回内容，是否与client 端写入内
容一致</strong></p>
<p>内容一致，测试截图：</p>
<p><img src="/2017/10/28/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式04/041.jpg" alt=""></p>
</li>
<li>
<p><strong>测试程序tcp_client4-1-2，连接服务端成功后，用write 函数向服务端写入，要求每次
写2 字节，然后延时1 秒，再写2 字节…，观察server 端read 函数的返回值和返回内
容，是否与client 端写入内容一致</strong></p>
<p>内容不一致，读取一次后读到2字节，执行后续程序，终止。测试截图：</p>
<p><img src="/2017/10/28/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式04/042.jpg" alt=""></p>
</li>
<li>
<p><strong>测试程序tcp_server4-2/tcp_client_4-2-1/tcp-client_4-2-2 ， 将read/write 换成
recv/send 函数，用法是否相同？结果是否相同？</strong></p>
<p>此时问题分情况。</p>
<p>tcp_4-2-1 tcp_4-2-2中send函数的flags均设置为0；</p>
<p>当tcp_server4-2中recv函数的flags设置为0时，结果如下：</p>
<p><img src="/2017/10/28/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式04/043.jpg" alt=""></p>
<p>当tcp_server4-2中recv函数的flags设置为MSG_WAITALL时，结果如下：</p>
<p><img src="/2017/10/28/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式04/044.jpg" alt=""></p>
</li>
<li>
<p><strong>如果要求read/recv 函数执行后，不读满20 字节一直不返回(client 端要求每次写2 字节，
然后延时1 秒，再写2 字节…)，能否做到？如何做到？(注：不允许采用自己写循环保证读
满20 字节）</strong></p>
<p>recv函数能做到，方法如下：</p>
<pre><code>recv(connect_fd, buff, 20, MSG_WAITALL)
</code></pre>
</li>
<li>
<p><strong>给出read/recv 函数的使用区别，给出write/send 函数的使用区别</strong></p>
<p>read/write与recv/send的区别</p>
<ul>
<li>在功能上，read/write是recv/send的子集。read/wirte是更通用的文件描述符操作，而recv/send在socket领域则更“专业”一些。</li>
<li>当recv/send的flag参数设置为0时，则和read/write是一样的。</li>
<li>如果有如下几种需求，则read/write无法满足，必须使用recv/send:
<ul>
<li>为接收和发送进行一些选项设置</li>
<li>从多个客户端中接收报文</li>
<li>发送带外数据（out-of-band data)</li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/28/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/28/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式03/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-28T11:10:14+08:00">
                2017-10-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3>Linux-Socket编程-TCP阻塞方式03</h3>
<hr>
<p>写一对TCP Socket 的测试程序，分为client 和server，分别运行在不同虚拟机上</p>
<ul>
<li>
<p><strong>两台用于测试的RHEL7 虚拟机均设置多个地址（例如：192.168.80.230/ 172.18.12.230）</strong></p>
</li>
<li>
<p><strong>测试程序tcp_server3，能读到本机所有网卡的所有IP 地址，然后只绑定其中的某个IP 地址
的某个端口，要求IP 地址和端口号通过main 函数带参数的方式传入（例：./tcp_sevrer3
172.18.12.230 4000 表示只绑定172.18.12.230 的4000 端口）</strong></p>
<pre><code>//获取本机网卡所有IP地址 
void getAllLocalIP(char **pIps[], int *ipcnt) {
	char **ips;
	int sockfd;
	struct ifconf ifconf;
	struct ifreq *ifreq;
	char buf[MAXLINE];//缓冲区
	//初始化ifconf
	ifconf.ifc_len =MAXLINE;
	ifconf.ifc_buf = buf;
	if ((sockfd =socket(AF_INET,SOCK_DGRAM,0))&lt;0) {
		printf(&quot;create socket error: %s(errno: %d)\n&quot;,strerror(errno),errno);
		exit(0);
	}
	ioctl(sockfd, SIOCGIFCONF, &amp;ifconf); //获取所有接口信息

	//接下来一个一个的获取IP地址
	ifreq = (struct ifreq*)ifconf.ifc_buf;
//    printf(&quot;ifconf.ifc_len:%d\n&quot;,ifconf.ifc_len);
//    printf(&quot;sizeof (struct ifreq):%d\n&quot;,sizeof (struct ifreq));

	*ipcnt=(ifconf.ifc_len/sizeof (struct ifreq));
	*pIps=(char **)malloc(*ipcnt*sizeof(char**));
	ips=*pIps;

	int i, len;
	for (i=0; i&lt;*ipcnt; ++i) {
		if(ifreq-&gt;ifr_flags == AF_INET) { //for ipv4
			//printf(&quot;name =[%s]\n&quot; , ifreq-&gt;ifr_name);
			//printf(&quot;local addr = [%s]\n&quot; ,inet_ntoa(((struct sockaddr_in*)&amp;(ifreq-&gt;ifr_addr))-&gt;sin_addr));
			len=1+strlen(inet_ntoa(((struct sockaddr_in*)&amp;(ifreq-&gt;ifr_addr))-&gt;sin_addr));
			ips[i]=(char *)malloc(len*sizeof(char));
			strcpy(ips[i], inet_ntoa(((struct sockaddr_in*)&amp;(ifreq-&gt;ifr_addr))-&gt;sin_addr));
			ifreq++;
		}
	}
	return;
}
</code></pre>
</li>
<li>
<p><strong>测试程序tcp_client3，运行时带入服务端IP 地址及其中任意一个端口号，即可向服务端发
起连接，要求IP 地址、端口号通过main 函数带参数的方式传入（例：./tcp_client3
172.18.12.230 4000 则表示连接172.18.12.230 的TCP 4000 端口）</strong></p>
<p><img src="/2017/10/28/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式03/032.jpg" alt=""></p>
</li>
<li>
<p><strong>如果tcp_client3 连接未绑定的IP 地址（例如：192.168.80.230），会怎样？</strong></p>
<p>会出现以下错误：</p>
<pre><code>connect error: No route to host(errno: 113)
</code></pre>
<p><img src="/2017/10/28/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式03/031.jpg" alt=""></p>
</li>
</ul>
<p><strong>参考：</strong>
<a href="http://blog.csdn.net/k346k346/article/details/48231933" target="_blank" rel="external">Linux下编程获取本地IP地址的常见方法</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/26/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/26/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式02/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-26T21:15:57+08:00">
                2017-10-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2>Linux-Socket编程-TCP阻塞方式02</h2>
<p>写一对TCP Socket 的测试程序，分为client 和server，分别运行在不同虚拟机上</p>
<ul>
<li>
<p><strong>前提：第1 小题中，client 每次连接server 时，client 的端口号是随机分配的</strong></p>
</li>
<li>
<p><strong>测试程序tcp_server2，与tcp_server1 功能相同，但接受连接时打印client 端的IP 地址
和端口号</strong></p>
<p>打印client 端的IP 地址和端口号</p>
<pre><code>struct sockaddr_in sa;
int len = sizeof(sa);
if(getpeername(connect_fd, (struct sockaddr *)&amp;sa, &amp;len)==-1) {
	printf(&quot;getpeername is error : %s(error: %d)\n&quot;, strerror(errno), errno);
} else {
	printf(&quot;client login. ip: %s, port :%d\n&quot;,inet_ntoa(sa.sin_addr),ntohs(sa.sin_port));
}
</code></pre>
</li>
<li>
<p><strong>测试程序tcp_client2，要求连接server 端的时候使用固定端口号，通过main 函数带参数的方式传入（例：./tcp_client2 12345 192.168.80.230 4000 则表示client 的12345 端口连接server 的4000 端口）</strong></p>
<p>建立连接函数代码</p>
<pre><code>/**
 * 客户端绑定固定端口 去 连接到server端
 */
int connectServer(int localPort, char* ip, int port) {
	int flags = 1;
	int fd = socket(AF_INET, SOCK_STREAM, 0);
	setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (void *) &amp;flags, sizeof(flags));
	/* 客户端绑定固定端口*/
	struct sockaddr_in localAddr;
	bzero(&amp;localAddr, sizeof(localAddr));
	localAddr.sin_family = AF_INET;
	localAddr.sin_addr.s_addr = htonl(INADDR_ANY);
	localAddr.sin_port = htons(localPort);
	if( -1==bind(fd, (struct sockaddr*) &amp;localAddr, sizeof(localAddr))) {
		printf(&quot;bind error: %s(errno: %d)\n&quot;,strerror(errno),errno);
		exit(0);
	}

	struct sockaddr_in remote_addr; //服务器端网络地址结构体
	memset(&amp;remote_addr, 0, sizeof(remote_addr)); //数据初始化--清零
	remote_addr.sin_family = AF_INET; //设置为IP通信
	remote_addr.sin_addr.s_addr = inet_addr(ip); //服务器IP地址
	remote_addr.sin_port = htons(port); //服务器端口号
	if(-1==connect(fd, (struct sockaddr*) &amp;remote_addr,sizeof(struct sockaddr))) {
		printf(&quot;connect error: %s(errno: %d)\n&quot;,strerror(errno),errno);
		close(fd);
		exit(0);
	}
	return fd;
}
</code></pre>
<p>测试截图：</p>
<p><img src="/2017/10/26/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式02/021.jpg" alt=""></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/24/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/24/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式01/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-24T23:36:14+08:00">
                2017-10-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3>Linux-Socket编程-TCP阻塞方式01</h3>
<hr>
<p>写一对TCP Socket 的测试程序，分为client 和server，分别运行在不同虚拟机上</p>
<ul>
<li>
<p><strong>测试程序tcp_server1（源程序名任意，允许多个，C/C++语言任选，make 后得到tcp_server1即可，下同），运行后绑定某个TCP 端口号，并进入等待连接状态（下面称为LISTEN 状态），要求端口号通过main 函数带参数的方式传入（例：./tcp_server1 4000 表示绑定TCP 4000
端口）</strong></p>
</li>
<li>
<p><strong>如果服务端绑定的端口号已被使用（比如两次运行 ./tcp_server1 4000 或 ./tcp_server180），则无法进入LISTEN 状态，会在哪个函数上出错？</strong></p>
<p>bind函数出错</p>
<p><img src="/2017/10/24/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式01/011.jpg" alt=""></p>
</li>
<li>
<p><strong>测试程序tcp_client1，运行时带入服务端IP 地址及端口号，即可向服务端发起连接，要求
IP 地址、端口号通过main 函数带参数的方式传入（例：./tcp_client1 192.168.80.230 4000
则表示连接192.168.80.230 的TCP 4000 端口）</strong></p>
</li>
<li>
<p><strong>如果client 端连接时的IP 地址不正确（例如不存在的IP 地址），会在哪一步出错？如果连
接的端口号不正确，会在哪一步出错？</strong></p>
<p>IP地址不正确：connect函数出错</p>
<p><img src="/2017/10/24/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式01/012.jpg" alt=""></p>
<p>端口号不正确：connect函数出错</p>
<p><img src="/2017/10/24/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式01/013.jpg" alt=""></p>
</li>
<li>
<p><strong>连接成功后，双方给出相应的提示信息，双方均进入read(recv)状态，此时read/recv 函数
会阻塞</strong></p>
<p>如图：</p>
<p><img src="/2017/10/24/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式01/014.jpg" alt=""></p>
</li>
<li>
<p><strong>连接成功后，用CTRL+C 中断client（server）端，Server（client）端能否能侦测到连接已中断？</strong></p>
<p>中断client, server能侦测连接中断</p>
<p><img src="/2017/10/24/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式01/0151.jpg" alt=""></p>
<p>中断server, client能侦测连接中断</p>
<p><img src="/2017/10/24/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式01/0152.jpg" alt=""></p>
</li>
<li>
<p><strong>连接成功后，用kill -9 杀死client（server）端，Server（client）端能否能侦测到连接
已中断？（另外启动一个SecureCRT 的会话来做kill）</strong></p>
<p>kill client, server能侦测连接中断</p>
<p><img src="/2017/10/24/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式01/0161.jpg" alt=""></p>
<p>kill server, client能侦测连接中断</p>
<p><img src="/2017/10/24/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式01/0162.jpg" alt=""></p>
</li>
<li>
<p><strong>在双方连接成功后，再新的会话中再启动一个tcp_client1 连接server，会出现什么情况？</strong></p>
<p>两个tcp_client1能同时连接server,但是退出情况不同</p>
<p>第一个tcp_client1先退出：</p>
<p><img src="/2017/10/24/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式01/0171.jpg" alt=""></p>
<p>第二个tcp_client1先退出，</p>
<p><img src="/2017/10/24/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式01/0172.jpg" alt=""></p>
</li>
<li>
<p><strong>tcp_sevrer1 运行终止后，立即再次启动，绑定相同端口号，能否成功？（REUSEADDR 选项的作用，加或不加的区别是什么？）</strong></p>
<p>若在bind()函数前加上以下代码，设置reuse为0,则不能；否则能。</p>
<pre><code>int reuse=0;
setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, sizeof(reuse);
</code></pre>
<p>设置reuse为0测试截图：</p>
<p><img src="/2017/10/24/Linux/homework/Linux-Socket编程-TCP阻塞方式/Linux-Socket编程-TCP阻塞方式01/018.jpg" alt=""></p>
<p>一般来说，一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用。未设置此项前，若服务端开启后，又关闭，此时sock处于TIME_WAIT状态，与之绑定的socket地址不可重用，而导致再次开启服务端失败。经过setsockopt设置之后， 即使处于TIME_WAIT些状态也可以立即被重用。</p>
<p>SO_REUSEADDR提供如下四个功能：</p>
<ol>
<li>SO_REUSEADDR允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将此端口用做他们的本地端口的连接仍存在。这通常是重启监听服务器时出现，若不设置此选项，则bind时将出错。</li>
<li>SO_REUSEADDR允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地IP地址即可。对于TCP，我们根本不可能启动捆绑相同IP地址和相同端口号的多个服务器。</li>
<li>SO_REUSEADDR允许单个进程捆绑同一端口到多个套接口上，只要每个捆绑指定不同的本地IP地址即可。这一般不用于TCP服务器。</li>
<li>SO_REUSEADDR允许完全重复的捆绑：当一个IP地址和端口绑定到某个套接口上时，还允许此IP地址和端口捆绑到另一个套接口上。一般来说，这个特性仅在支持多播的系统上才有，而且只对UDP套接口而言（TCP不支持多播）。</li>
</ol>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/22/Linux/homework/Linux-rpm制作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/22/Linux/homework/Linux-rpm制作/" itemprop="url">Linux-rpm包的制作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-22T11:21:19+08:00">
                2017-10-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4>RPM相关知识准备</h4>
<hr>
<p><a href="https://fedoraproject.org/wiki/How_to_create_an_RPM_package/zh-cn#RPM_.E5.9F.BA.E7.A1.80.E7.9F.A5.E8.AF.86" target="_blank" rel="external">官方文档</a></p>
<h5>RPM 基础知识</h5>
<p>若要构建一个标准的 RPM 包，您需要创建 .spec 文件，其中包含软件打包的全部信息。然后，对此文件执行 rpmbuild 命令，经过这一步，系统会按照步骤生成最终的 RPM 包。</p>
<p>一般情况，您应该把源代码包，比如由开发者发布的以 .tar.gz 结尾的文件，放入 ~/rpmbuild/SOURCES 目录。将.spec 文件放入 ~/rpmbuild/SPECS 目录，并命名为 &quot;软件包名.spec&quot; 。当然， 软件包名 就是最终 RPM 包的名字。为了创建二进制（Binary RPM）和源码软件包（SRPM），您需要将目录切换至 ~/rpmbuild/SPECS 并执行：</p>
<pre><code> $ rpmbuild -ba NAME.spec   
</code></pre>
<p>当执行此命令时，rpmbuild 会自动读取 .spec 文件并按照下表列出的步骤完成构建。下表中，以 % 开头的语句为预定义宏，每个宏的作用如下：</p>
<p><img src="/2017/10/22/Linux/homework/Linux-rpm制作/rpm1.jpg" alt=""></p>
<p>在 rpmbuild 中，对上表中的每个宏代码都有对应的目录：</p>
<p><img src="/2017/10/22/Linux/homework/Linux-rpm制作/rpm2.jpg" alt=""></p>
<p>如果某一阶段失败，请查看输出信息以了解失败原因，并根据需要修改 .spec 文件。</p>
<p>做好准备打包一个特殊程序</p>
<p>如果这里有特殊的程序，它们需要被安装或者运行以便让您打包的普通程序正常工作，那么请先安装它们，然后记录下诸如软件包等相关信息。</p>
<p>不可以使用预编译代码进行打包。将源代码（通常是 .tar.gz 文件）放入 &quot;~/rpmbuild/SOURCES&quot; 目录（注意用户）。</p>
<p>仔细阅读该软件的安装说明。我们建议您先手工安装一次以了解具体情况。除少数情况外，所有二进制文件和程序库都必须由源码包中的源码编译而成。</p>
<h5>新建一个 .spec 文件</h5>
<p>现在，您需要在 ~/rpmbuild/SPECS 目录下，新建一个 SPEC 文件。文件应命名为 &quot;软件包名.spec&quot;。名称根据软件包名或通用名填写即可。但是，必须要遵守 软件包命名规定。</p>
<p>如果您首次创建 .spec 文件，vim 或 emacs 会自动生成模板：</p>
<pre><code> $ cd ~/rpmbuild/SPECS
 $ vim program.spec
</code></pre>
<p>示例（仅供参考）：</p>
<pre><code>Name:
Version:
Release:	1%{?dist}
Summary:
Group:
License:
URL:
Source0:
BuildRoot:	%{_tmppath}/%{name}-%{version}-%{release}-root-%(%{__id_u} -n)

BuildRequires:
Requires:

%description

%prep
%setup -q

%build
%configure
make %{?_smp_mflags}

%install
rm -rf %{buildroot}
make install DESTDIR=%{buildroot}

%clean
rm -rf %{buildroot}

%files
%defattr(-,root,root,-)
%doc

%changelog
</code></pre>
<p>您可以使用 $RPM_BUILD_ROOT 代替 %{buildroot}，两者都可以使用。
您也可以使用 rpmdev-newspec 命令来创建 SPEC 文件。rpmdev-newspec 软件包名 可以创建一个初始 SPEC 文件，该工具从软件包名判断使用哪个模板，支持指定模板。 /etc/rpmdevtools/spectemplate-*.spec 包含所有可用的模板，使用 rpmdev-newspec --help 命令了解更多信息。例如，为 python 模块创建 SPEC 文件：</p>
<pre><code>cd ~/rpmbuild/SPECS
rpmdev-newspec python-antigravity
vi python-antigravity.spec
</code></pre>
<h5>SPEC 文件综述</h5>
<p>您需要遵守这些规定：软件包命名规定，打包规定 和 软件包审核规定。</p>
<p>&quot;#&quot; 字符表示注释，但需要避免注释宏（以 % 开头），因为它们会首先被替换展开。使用 %% 注释宏。另外，还要避免在脚本命令的相同行中使用行内注释。</p>
<p>以下介绍了主要的标签。注意 %{name}，%{version} 和 %{release} 代表 Name, Version 和 Release 这三个标签。只要更改标签，宏就会使用新值。</p>
<p><img src="/2017/10/22/Linux/homework/Linux-rpm制作/rpm3.jpg" alt="">
<img src="/2017/10/22/Linux/homework/Linux-rpm制作/rpm4.jpg" alt=""></p>
<h5>SPEC 文件剖析</h5>
<ul>
<li>
<p><strong>%prep部分</strong></p>
<p>描述了解压源码包的方法。一般而言，其中包含 &quot;%autosetup&quot; 命令。另外，还可以使用 &quot;%setup&quot; 和 &quot;%patch&quot; 命令来指定操作 Source0 等标签的文件。</p>
</li>
<li>
<p><strong>%prep 部分：%autosetup 命令</strong></p>
<p>&quot;%autosetup&quot; 命令用于解压源码包。可用选项包括：<br>
-n name : 如果源码包解压后的目录名称与 RPM 名称不同，此选项用于指定正确的目录名称。例如，如果 tarball 解压目录为 FOO，则使用 &quot;%autosetup -n FOO&quot;。<br>
-c name : 如果源码包解压后包含多个目录，而不是单个目录时，此选项可以创建名为 name 的目录，并在其中解压。<br>
如果使用 &quot;%setup&quot; 命令，通常使用 -q' 抑止不必要的输出。</p>
</li>
<li>
<p><strong>%build 部分</strong></p>
<p>&quot;%build&quot; 部分有时会有点复杂；在这里你可以配置，并编译用于安装的文件。<br>
许多程序使用 GNU configure 进行配置。默认情况下，文件会安装到前缀为 &quot;/usr/local&quot; 的路径下，对于手动安装很合理。然而，打包时需要修改前缀为 &quot;/usr&quot;。共享库路径视架构而定，安装至 /usr/lib 或 /usr/lib64 目录。<br>
由于 GNU configure 很常见，可使用 &quot;%configure&quot; 宏来自动设置正确选项（例如，设置前缀为 /usr）。一般用法如下：</p>
<pre><code> %configure
 make %{?_smp_mflags}
</code></pre>
<p>若需要覆盖 makefile 变量，请将变量作为参数传递给 make：</p>
<pre><code>make %{?_smp_mflags} CFLAGS=&quot;%{optflags}&quot; BINDIR=%{_bindir}
</code></pre>
</li>
<li>
<p><strong>%install 部分</strong></p>
<p>此部分包含安装阶段需要执行的命令，即从 %{_builddir} 复制相关文件到 %{buildroot} 目录（通常表示从 ~/rpmbuild/BUILD 复制到 ~/rpmbuild/BUILDROOT) 目录，并根据需要在 %{buildroot} 中创建必要目录。</p>
<p>容易混淆的术语：<br>
&quot;build 目录&quot;，也称为 %{_builddir}，实际上与 &quot;build root&quot;，又称为 %{buildroot}，是不同的目录。在前者中进行编译，并将需要打包的文件从前者复制到后者。<br>
在 %build 阶段，当前目录为 %{buildsubdir}，是 %prep 阶段中在 %{_builddir} 下创建的子目录。这些目录通常名为 ~/rpmbuild/BUILD/%{name}-%{version}。<br>
%install 阶段的命令不会在用户安装 RPM 包时执行，此阶段仅在打包时执行。
一般，这里执行 &quot;make install&quot; 之类的命令：</p>
<pre><code>%install
rm -rf %{buildroot} # 仅用于 RHEL 5
%make_install
</code></pre>
<p>理想情况下，对于支持的程序，你应该使用 %make_install，它等同于 DESTDIR=%{buildroot}，它会将文件安装到 %{buildroot} 目录中。</p>
</li>
</ul>
<h5>Scriptlets</h5>
<p>当用户安装 RPM 时，您可能想要执行一些命令。这可以通过 scriptlets 完成。请查看 Packaging/ScriptletSnippets。</p>
<p>脚本片段可以：</p>
<ul>
<li>在软体包安装之前 (%pre) 或之后 (%post) 执行</li>
<li>在软体包卸载之前 (%preun) 或之后 (%postun) 执行</li>
<li>在事务开始 (%pretrans) 或结束 (%posttrans) 时执行</li>
</ul>
<hr>
<h4>test-1453381.rpm包的制作过程</h4>
<hr>
<ol>
<li>
<p>开始前的准备</p>
<p>安装rpmbuild软件包</p>
<pre><code>yum -y install rpm-build
</code></pre>
<p>Linux RedHat 7.4已经安装了。</p>
</li>
<li>
<p>生成相关目录</p>
<pre><code>mkdir -p $(rpmDir)/SOURCES $(rpmDir)/SPECS $(rpmDir)/BUILD $(rpmDir)/RPMS $(rpmDir)/SRPMS
</code></pre>
<p>目录结构如下：</p>
<pre><code>rpmbuild/
├── BUILD
├── BUILDROOT
├── RPMS
├── SOURCES
├── SPECS
└── SRPMS
</code></pre>
</li>
<li>
<p>编写.spec文件</p>
<pre><code>Name:	test-1453381
Version:	1.0
Release:	1%{?dist}
Summary:	test-rpm

Group:		none
License:	none
URL:		none
Source0:	test-1453381-1.0.tar.gz

%description
test-1453381-rpm

%prep
%setup -q 

%pre
echo &quot;准备安装test-1453381&quot;

%post
echo &quot;完成安装test-1453381&quot;

%build
make

%install
make install DESTDIR=%{buildroot}

%preun
echo &quot;准备卸载test-1453381&quot;

%postun
cd %{_builddir}/%{name}-%{version}/
make uninstall 
echo &quot;完成卸载test-1453381&quot;

%files
%doc

%changelog
</code></pre>
</li>
<li>
<p>拷贝相关文件到指定目录</p>
<pre><code>mkdir $(releaseName)
cp $(rpmSrcFile) $(releaseName)/
tar -zcvf $(rpmDir)/SOURCES/$(rpmGz) $(releaseName)
rm -rf $(releaseName)
cp $(rpmSpec) $(rpmDir)/SPECS
</code></pre>
</li>
<li>
<p>生成rpm包</p>
<pre><code>rpmbuild -bb $(rpmDir)/SPECS/$(rpmSpec)
cp $(rpmDir)/RPMS/x86_64/$(releaseName)-1.el7.x86_64.rpm $(binFinal).rpm
</code></pre>
</li>
<li>
<p>测试</p>
<p><img src="/2017/10/22/Linux/homework/Linux-rpm制作/rpmp1.jpg" alt=""></p>
<p><img src="/2017/10/22/Linux/homework/Linux-rpm制作/rpmp2.jpg" alt=""></p>
</li>
</ol>
<p>可供参考：<a href="http://www.cnblogs.com/postgres/p/5726339.html" target="_blank" rel="external">链接</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/22/Linux/homework/Linux-service自定义/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/22/Linux/homework/Linux-service自定义/" itemprop="url">Linux-service自定义</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-22T11:20:37+08:00">
                2017-10-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h5>制作service的基本知识</h5>
<ol>
<li>
<p><strong>服务权限</strong></p>
<p>systemd有系统和用户区分；系统（<code>/user/lib/systemd/system/</code>）、用户（<code>/etc/lib/systemd/user/</code>）.一般系统管理员手工创建的单元文件建议存放在<code>/etc/systemd/system/</code>目录下面。</p>
</li>
<li>
<p><strong>创建服务文件</strong></p>
<p><strong>[Unit]</strong><br>
<strong>Description</strong> : 服务的简单描述<br>
<strong>Documentation</strong> ： 服务文档<br>
<strong>Before、After</strong> :定义启动顺序。Before=xxx.service,代表本服务在xxx.service启动之前启动。After=xxx.service,代表本服务在xxx.service之后启动。<br>
<strong>Requires</strong>：这个单元启动了，它需要的单元也会被启动；它需要的单元被停止了，这个单元也停止了。<br>
<strong>Wants</strong>：这个单元启动了，它需要的单元也会被启动；它需要的单元被停止了，对本单元没有影响。</p>
<p><strong>[Service]</strong><br>
<strong>Type=simple（默认值）</strong>：systemd认为该服务将立即启动。服务进程不会fork。如果该服务要启动其他服务，不要使用此类型启动，除非该服务是socket激活型。<br>
<strong>Type=forking</strong>：systemd认为当该服务进程fork，且父进程退出后服务启动成功。对于常规的守护进程（daemon），除非你确定此启动方式无法满足需求，使用此类型启动即可。使用此启动类型应同时指定 PIDFile=，以便systemd能够跟踪服务的主进程。<br>
<strong>Type=oneshot</strong>：这一选项适用于只执行一项任务、随后立即退出的服务。可能需要同时设置 RemainAfterExit=yes 使得 systemd 在服务进程退出之后仍然认为服务处于激活状态。<br>
<strong>Type=notify</strong>：与 Type=simple 相同，但约定服务会在就绪后向 systemd 发送一个信号。这一通知的实现由 libsystemd-daemon.so 提供。<br>
<strong>Type=dbus</strong>：若以此方式启动，当指定的 BusName 出现在DBus系统总线上时，systemd认为服务就绪。<br>
<strong>Type=idle</strong>: systemd会等待所有任务(Jobs)处理完成后，才开始执行idle类型的单元。除此之外，其他行为和Type=simple 类似。<br>
<strong>PIDFile</strong>：pid文件路径<br>
<strong>ExecStart</strong>：指定启动单元的命令或者脚本，ExecStartPre和ExecStartPost节指定在ExecStart之前或者之后用户自定义执行的脚本。Type=oneshot允许指定多个希望顺序执行的用户自定义命令。<br>
<strong>ExecReload</strong>：指定单元停止时执行的命令或者脚本。<br>
<strong>ExecStop</strong>：指定单元停止时执行的命令或者脚本。<br>
<strong>PrivateTmp</strong>：True表示给服务分配独立的临时空间<br>
<strong>Restart</strong>：这个选项如果被允许，服务重启的时候进程会退出，会通过systemctl命令执行清除并重启的操作。<br>
<strong>RemainAfterExit</strong>：如果设置这个选择为真，服务会被认为是在激活状态，即使所以的进程已经退出，默认的值为假，这个选项只有在Type=oneshot时需要被配置。</p>
<p><strong>[Install]</strong><br>
<strong>Alias</strong>：为单元提供一个空间分离的附加名字。<br>
<strong>RequiredBy</strong>：单元被允许运行需要的一系列依赖单元，RequiredBy列表从Require获得依赖信息。<br>
<strong>WantBy</strong>：单元被允许运行需要的弱依赖性单元，Wantby从Want列表获得依赖信息。<br>
<strong>Also</strong>：指出和单元一起安装或者被协助的单元。<br>
<strong>DefaultInstance</strong>：实例单元的限制，这个选项指定如果单元被允许运行默认的实例。</p>
</li>
</ol>
<hr>
<h5>Linux test-1453381.service实际制作</h5>
<ol>
<li>
<p>编写service文件</p>
<p>test-1453381.service</p>
<pre><code># cp test-1453381.service /etc/systemd/system/

[Unit]
Description=test-1453381

[Service]
Type=forking
#下面这行对于此次的test.service需要注释掉
#PIDFile=/usr/local/test-1453381.pid
ExecStart=/usr/sbin/test-1453381 &amp;
ExecReload=/bin/kill -s HUP $MAINPID
ExecStop=/bin/kill -s QUIT $MAINPID

[Install]
WantedBy=multi-user.target
</code></pre>
<p>为避免<code>systemctl start</code> 时遇到<code>Warning: test-1453381.service changed on disk. Run 'systemctl daemon-reload' to reload units.</code>,可在start前先执行 <code>systemctl enable teset.service</code> 。</p>
</li>
<li>
<p>拷贝编写好的service文件至特定目录</p>
<pre><code>cp test-1453381.service /etc/systemd/system/
</code></pre>
</li>
<li>
<p>测试</p>
<p><img src="/2017/10/22/Linux/homework/Linux-service自定义/1.jpg" alt=""></p>
</li>
</ol>
<p>参考链接：</p>
<ul>
<li><a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html#" target="_blank" rel="external">参考1</a></li>
<li><a href="https://wiki.archlinux.org/index.php/systemd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="external">参考2</a></li>
<li><a href="http://blog.chinaunix.net/uid-26790551-id-3189115.html" target="_blank" rel="external">参考3</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程2/" itemprop="url">Linux守护进程2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-18T19:44:25+08:00">
                2017-10-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4>Linux守护进程2——守护进程的作用、用途、父进程标识的特点</h4>
<hr>
<ul>
<li>
<p><strong>在02 子目录下写test2.c，写配套的makefile 文件，make 后可生成test2 可执行文件</strong></p>
<p>基本概念如下：<br>
<strong>进程组 ：</strong><br>
每个进程属于一个进程组<br>
每个进程都有一个进程组号，该号等于该进程组组长的PID号<br>
一个进程只能为它自己或子进程设置进程组ID号</p>
<p><strong>会话期：</strong><br>
会话期(session)是一个或多个进程组的集合<br>
setsid()函数可以建立一个对话期。如果调用setsid的进程不是一个进程组的组长，此函数创建一个新的会话期：<br>
(1)此进程变成该对话期的首进程<br>
(2)此进程变成一个新进程组的组长进程。<br>
(3)此进程没有控制终端，如果在调用setsid前，该进程有控制终端，那么与该终端的联系被解除。 如果该进程是一个进程组的组长，此函数返回错误。<br>
(4)为了保证这一点，我们先调用fork()然后exit()，此时只有子进程在运行</p>
<p><strong>编写守护进程的一般步骤步骤：</strong><br>
（1）在父进程中执行fork并exit推出；<br>
（2）在子进程中调用setsid函数创建新的会话；<br>
（3）在子进程中调用chdir函数，让根目录 ”/” 成为子进程的工作目录；<br>
（4）在子进程中调用umask函数，设置进程的umask为0；<br>
（5）在子进程中关闭任何不需要的文件描述符</p>
<pre><code>//test2.c
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;syslog.h&gt;
#include &lt;signal.h&gt;

int daemon_init(void){
    pid_t pid;
    if ((pid = fork()) &lt; 0)
		return -1;
	else if (pid)   
		exit(0);	/* parent exit */

	/* child continues */
	/* become session leader */
	setsid();
	/* change working directory */
    chdir(&quot;\n&quot;);
	/* clear file mode creation mask */
	umask(0);
    /* close stdin stdout stderr */
	close(0);
	close(1);
	close(2);

	return 0;
}       

void sig_term(int signo){
	if(signo==SIGTERM){
		syslog(LOG_INFO, &quot;program terminated&quot;);
		closelog();
		exit(0);
	}
}

#define SLEEP_TIME 5

int main(){
	
	if (daemon_init() == -1){
		printf(&quot;can't fork self\n&quot;);
		exit(0);
	}

	//以下三行不是必须的，仅提供log信息
	openlog(&quot;daemontest&quot;, LOG_PID, LOG_USER);
	syslog(LOG_INFO, &quot;program started&quot;);
	signal(SIGTERM, sig_term);

	while(1){
		printf(&quot;1453381\n&quot;);
		sleep(SLEEP_TIME);
	}
	
	return 0;
}
</code></pre>
<p>makefile :</p>
<pre><code>CC=gcc
CFLAGS=

BIN=test2
SRC=$(wildcard *.c)
OBJ=$(SRC:.c=.o)

$(BIN):$(OBJ)
	$(CC) $(OBJ) -o $(BIN)

.PHONY :clean
clean:
	rm -f $(BIN) $(OBJ)
</code></pre>
<p>说明：</p>
<ol>
<li>在后台运行
为避免挂起控制终端将Daemon放入后台执行。方法是在进程中调用fork使父进程终止，让Daemo在子
进程中后台执行。
if(pid=fork())
exit(0);//是父进程，结束父进程，子进程继续</li>
<li>脱离控制终端，登录会话和进程组
登录会话和进程组之间的关系：进程属于一个进程组，进程组号（GID）就是进程组长的进程号（PID
）。登录会话可以包含多个进程组。这些进程组共享一个控制终端。这个控制终端通常是创建进程的
登录终端。 控制终端，登录会话和进程组通常是从父进程继承下来的。我们的目的就是要摆脱它们，
使之不受它们的影响。方法是在第1点的基础上，调用setsid()使进程成为会话组长：
setsid();
说明：当进程是会话组长时setsid()调用失败。但第一点已经保证进程不是会话组长。setsid()调
用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。由于会话过
程对控制终端的独占性，进程同时与控制终端脱离。</li>
<li>禁止进程重新打开控制终端
现在，进程已经成为无终端的会话组长。但它可以重新申请打开一个控制终端。可以通过使进程不再
成为会话组长来禁止进程重新打开控制终端：
if(pid=fork())
exit(0);//结束第一子进程，第二子进程继续（第二子进程不再是会话组长）</li>
<li>关闭打开的文件描述符
进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在
的文件系统无法卸下以及引起无法预料的错误。</li>
<li>改变当前工作目录
进程活动时，其工作目录所在的文件系统不能卸下。一般需要将工作目录改变到根目录。对于需要转
储核心，写运行日志的进程将工作目录改变到特定目录如/tmpchdir(&quot;/&quot;)</li>
<li>重设文件创建掩模
进程从创建它的父进程那里继承了文件创建掩模。它可能修改守护进程所创建的文件的存取位。为防
止这一点，将文件创建掩模清除：umask(0);</li>
</ol>
</li>
<li>
<p><strong>用./test2 运行后直接成为守护进程</strong></p>
</li>
<li>
<p><strong>test2 的进程标识、父进程标识是谁？如何查看？</strong></p>
<p>进程 test2 的 ppid 为1，在 RedHat7.4 下为 systemd</p>
<pre><code>ps -ef |grep test2
pstree 1
ps -ef |grep -E &quot;test2|systemd&quot;
</code></pre>
<p>测试截图：</p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程2/1.jpg" alt="">
<img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程2/2.jpg" alt=""></p>
</li>
<li>
<p><strong>在另一个控制台中能否查看到test2 进程的相关信息？</strong></p>
<p>能，完全一样。<br>
测试截图：</p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程2/3.jpg" alt=""></p>
</li>
<li>
<p><strong>当test2 在后台运行时，如果CTRL+D 退出控制台登录，test2 会怎样？</strong></p>
<p>test2 是守护进程，即使 [CTRL] + D 退出登录，只要操作系统保持运行，则 test2 会保持运行。</p>
</li>
<li>
<p><strong>再次登录控制台后，test2 是否仍在运行？此时打印信息能否继续出现在新登录的终端上？</strong></p>
<p>再次登陆，test2 仍在运行，打印信息不能出现在终端，原因上个题目已说。</p>
</li>
<li>
<p><strong>引申问题：如果想在进程中打印信息并保证始终能被查看到，应该如何做？</strong></p>
<p>守护进程没有控制终端进行信息的输出，而有些情况还需要根据进程提供的信息进行系统管理和维护工作。因此Linux提供了syslogd守护进程，专门用于接受其他守护进程提供的信息记录在指定位置来解决日志记录的问题。</p>
<p>在 RedHat7.4 中没有syslogd，但是有rsyslogd守护进程，rsyslog的配置文件是<code>/etc/rsyslog.conf</code></p>
<p>下面说明一下相关syslog函数：</p>
<pre><code>// 函数说明
#include &lt;syslog.h&gt;
vodi openlog(const char *ident, int option, int facility);
void syslog(int priority, const char *format, ...);
void closelog(void);

openlog函数原型如下：
1）void openlog(const char* ident, int option, int facility);
        //打开系统日志链接，必须步骤。
ident   :信息来源，哪个可执行程序
option  :控制标志的参数，多个可以同时使用，用|操作合并
facility:指定消息类型，与配置文件对应，日志会写入配置文件指定位置。

2）void syslog(int priority,const char* format,....);
priority：消息级别，与openlog中的facility可以共同决定日志写入位置。
format  ：消息格式，再后面为格式对应的参数，类似printf的使用
 
3）void closelog();
关闭系统日志链接，可选步骤。
</code></pre>
<p>在原来的程序中打印学号的地方添加一行：</p>
<pre><code>syslog(LOG_INFO, &quot;1453381\n&quot;);
</code></pre>
<p>执行后，查看新增信息</p>
<pre><code>tail -f /var/log/messages
</code></pre>
<p>测试截图：</p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程2/4.jpg" alt=""></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程1/" itemprop="url">Linux守护进程1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-18T19:44:25+08:00">
                2017-10-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4>Linux守护进程1——程序前后台切换</h4>
<hr>
<ul>
<li>
<p><strong>写test1-1.c/test1-2.c 两个程序，都是死循环操作，每5 秒打印一句话，写配套的makefile 文件，make 后可生成test1-1和test1-2 两个可执行文件</strong></p>
<pre><code>//test1-1.c
#include&lt;stdio.h&gt;
#include&lt;unistd.h&gt;

#define SLEEP_TIME 5

int main(){
        while(1){
                printf(&quot;1453381\n&quot;);
                sleep(SLEEP_TIME);
        }
        return 0;
}

//test1-2.c

#include&lt;stdio.h&gt;
#include&lt;unistd.h&gt;

#define SLEEP_TIME 5

int main(){
        while(1){
                printf(&quot;曾鸣\n&quot;);
                sleep(SLEEP_TIME);
        }
        return 0;
}
</code></pre>
<p>makefile ：</p>
<pre><code>cc ?= gcc

srcNames :=test1-1 test1-2

all :
	@for src in $(srcNames) ; \
	do \
		$(cc) -o $$src &quot;$$src&quot;.c ; \
	done

clean :
	rm -f *.o $(srcNames)

.PHONY : all clean
</code></pre>
</li>
<li>
<p><strong>用SecureCRT登录系统（简称控制台），然后./test1-1 运行test1-1 程序，控制台进入死循环，不再出现#或$提示符</strong></p>
</li>
<li>
<p><strong>如何将test1-1 放入后台运行？</strong></p>
<p>程序运行时在终端按下 [Ctrl] + z，使工作转入后台，但此时工作停止，需要使用 bg 来使之运行。</p>
</li>
<li>
<p><strong>如何查看在后台的test1-1 程序的信息？</strong></p>
<ul>
<li>
<p>jobs命令<br>
功能：查看当前终端后台运行的任务<br>
<code>jobs -l</code>选项可显示当前终端所有任务的PID，jobs的状态可以是running，stopped，Terminated。+ 号表示当前任务，- 号表示后一个任务。</p>
</li>
<li>
<p>ps命令<br>
功能：ps命令用于报告当前系统的进程状态<br>
<code>ps -ef | grep &quot;test1-1&quot;</code><br>
-a：显示所有终端机下执行的程序<br>
-f：显示UID,PPIP,C与STIME栏位。</p>
</li>
</ul>
<p>测试截图</p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程1/1.jpg" alt=""></p>
</li>
<li>
<p><strong>如何使test1-1 重新切换到前台来？</strong></p>
<p>fg 命令</p>
</li>
<li>
<p><strong>再次将test1-1 放入后台，./test1-2 运行test1-2 程序，然后将test1-2 也放入后台如何控制将test1-1/test1-2 中的某一个切换到前台来？</strong></p>
<p>fg + 工作序号。如 fg 2 会让 test1-2 回到前台。<br>
同理，如果后台有多个工作停止，则使用 bg + 工作序号可以使指定工作开始后台运行。</p>
<p><code>[1]- [2]+</code>，加号代表当前工作为<code>[2]</code>，减号代表当前工作的下一个工作为<code>[1]</code>。它们表明了工作执行的顺序，如果你使用不加序号的 fg 命令，则默认把带加号的工作提到前台。</p>
<p>测试截图</p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程1/2.jpg" alt=""></p>
</li>
<li>
<p><strong>test1-1/test1-2 的父进程标识是谁？如何查看？</strong></p>
<pre><code>ps -ef | grep test1-1   #查看test1-1进程信息
pstree pid  #查看pid进程树
ps -ef | grep pid #筛选出包含与pid有关的进程，其中第二列为pid，第三列为ppid
</code></pre>
<p>测试截图</p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程1/3.jpg" alt=""><br>
<img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程1/4.jpg" alt=""></p>
</li>
<li>
<p><strong>用SecureCRT 再登录一个控制台，用什么命令可以看到test1-1/test1-2 的信息？此时父进
程标识是谁？如何查看？</strong></p>
<p>同上，一样的命令可以查看，原进程pid及ppid不变，此时的bash进程pid不同。</p>
</li>
<li>
<p><strong>当test1-1/test1-2 在后台运行时，如果CTRL+D 退出该控制台登录，在另一个控制台再查看test1-1/test1-2 的信息，此时父进程标识是谁？</strong></p>
<p>父进程PID 是 1。</p>
<p>测试截图</p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程1/5.jpg" alt=""></p>
</li>
<li>
<p><strong>能否使test1-1/test1-2 在终端退出登录后继续运行（不是再次运行）？此时打印信息能否继续出现在新登录的终端上？</strong></p>
<ol>
<li>
<p>setsid命令，用setsid来启动程序，使启动的进程在新的session中，并且终端关闭时，进程不退出。</p>
<pre><code>setsid ./test1-1 &amp;
setsid ./test1-2 &amp;
</code></pre>
</li>
<li>
<p>nohup命令，被nohup启动的程序会忽略SIGHUP信号。</p>
<pre><code>nohup ./test1-1 &amp;
nohup ./test1-2 &amp;
</code></pre>
<p>nohup命令可以将程序以忽略挂起信号的方式运行起来，被运行的程序的输出信息将不会显示到终端。 无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中。如果当前目录的 nohup.out 文件不可写，输出重定向到$HOME/nohup.out文件中。</p>
</li>
<li>
<p>对于jobs中的后台程序，通过disown命令</p>
<pre><code>disown -h %id   #id表示jobs中的id
</code></pre>
</li>
</ol>
<p>打印信息不会继续出现在新的终端上。<br>
会不会出现在新的终端上取决于新的 shell 的标准输出/错误输出的文件描述符是否与 test1-1 test1-2 进程相同。在原来终端未退出时，默认情况下（没有使用重定向）它们继承了父进程（即原来 shell）的文件描述符。在原来 shell 结束后，它们继承新的父进程的文件描述符，而新的文件描述符和原来文件描述符是不同的，所以不会。</p>
<p>我们可以用重定向将输出重定向为指定设备。</p>
<pre><code>tty #获取某个终端的控制台
setsid ./test1-1 &gt;/dev/pts/1    #/dev/pts/1 是上面的结果
</code></pre>
</li>
<li>
<p><strong>如何将一个正常程序直接放入后台运行？（不要通过按键切换）</strong></p>
<p>执行程序时，在命令后加上 &amp;，比如 <code>./test1-1 &amp;</code></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程0/" itemprop="url">Linux守护进程0</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-18T19:44:25+08:00">
                2017-10-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>signal函数</p>
<pre><code>#include &lt;signal.h&gt;

typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);

作用1：站在应用程序的角度，注册一个信号处理函数
作用2：忽略信号，设置信号默认处理 信号的安装和回复

参数
--  signal是一个带signum和handler两个参数的函数，准备捕捉或屏蔽的信号由参数signum
    给出，接收到指定信号时将要调用的函数有handler给出
--  handler这个函数必须有一个int类型的参数（即接收到的信号代码），它本身的类型是void
--  handler也可以是下面两个特殊值：① SIG_IGN 屏蔽该信号  ② SIG_DFL 恢复默认行为

SIGABRT        进程停止运行    6
SIGALRM        警告钟    
SIGFPE        算述运算例外
SIGHUP        系统挂断
SIGILL        非法指令
SIGINT        终端中断   2
SIGKILL        停止进程（此信号不能被忽略或捕获）
SIGPIPE        向没有读的管道写入数据
SIGSEGV        无效内存段访问
SIGQOUT        终端退出    3
SIGTERM        终止
SIGUSR1        用户定义信号1
SIGUSR2        用户定义信号2
SIGCHLD        子进程已经停止或退出
SIGCONT        如果被停止则继续执行
SIGSTOP        停止执行
SIGTSTP        终端停止信号
SIGTOUT        后台进程请求进行写操作
SIGTTIN        后台进程请求进行读操作
</code></pre>
<p>kill函数</p>
<pre><code>#include &lt;sys/types.h&gt; 
#include &lt;signal.h&gt;

int kill(pid_t pid, int sig);

作用：用于向任何进程组或进程发送信号。

参数： 
pid：可能选择有以下四种
1. pid大于零时，pid是信号欲送往的进程的标识。
2. pid等于零时，信号将送往所有与调用kill()的那个进程属同一个使用组的进程。
3. pid等于-1时，信号将送往所有调用进程有权给其发送信号的进程，除了进程1(init)。
4. pid小于-1时，信号将送往以-pid为组标识的进程。

sig：准备发送的信号代码，假如其值为零则没有任何信号送出，但是系统会执行错误检查，通常
会利用sig值为零来检验某个进程是否仍在执行。

返回值说明： 成功执行时，返回0。失败返回-1，errno被设为以下的某个值
EINVAL：指定的信号码无效（参数 sig 不合法） 
EPERM；权限不够无法传送信号给指定进程 
ESRCH：参数 pid 所指定的进程或进程组不存在
</code></pre>
<p>wait和waitpid函数</p>
<pre><code>#include &lt;sys/types.h&gt;   
#include &lt;sys/wait.h&gt;  

pid_t waitpid(pid_t pid,int *status,int options);  

1）wait()函数用于使父进程（也就是调用wait()的进程）阻塞，直到一个子进程结束或者该进程
接收到了一个指定的信号为止。如果该父进程没有子进程或者它的子进程已经结束，则wait()函数
就会立即返回。
2) waitpid()的作用和wait()一样，但它并不一定要等待第一个终止的子进程（它可以指定需要
等待终止的子进程），它还有若干选项，如可提供一个非阻塞版本的 wait()功能，也能支持作业
控制。实际上，wait()函数只是 waitpid()函数的一个特例，在Linux 内部实现 wait()函数
时直接调用的就是waitpid()函数。

1）pid_t pid
参数pid为欲等待的子进程识别码，其具体含义如下：
参数值	说明
pid&lt;-1	等待进程组号为pid绝对值的任何子进程。
pid=-1	等待任何子进程，此时的waitpid()函数就退化成了普通的wait()函数。
pid=0	等待进程组号与目前进程相同的任何子进程，也就是说任何和调用waitpid()函数的进
        程在同一个进程组的进程。
pid&gt;0	等待进程号为pid的子进程。 

2）int *status
这个参数将保存子进程的状态信息，有了这个信息父进程就可以了解子进程为什么会推出，是正常
退出还是出了什么错误。也可以传入空指针。

3）int options
参数options提供了一些另外的选项来控制waitpid()函数的行为。如果不想使用这些选项，则可
以把这个参数设为0。
主要使用的有以下两个选项：
参数	说明
WNOHANG	    如果pid指定的子进程没有结束，则waitpid()函数立即返回0，而不是阻塞在这
            个函数上等待；如果结束了，则返回该子进程的进程号。
WUNTRACED	如果子进程进入暂停状态，则马上返回。</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程4/" itemprop="url">Linux守护进程4</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-18T19:44:25+08:00">
                2017-10-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4>Linux守护进程4 -- 杀掉守护进程及其子进程</h4>
<hr>
<ul>
<li>
<p><strong>在04 子目录下写test4-1.c，循环10 次，每隔3 秒产生一个子进程，循环完成后，自己进入
死循环操作，每5 秒打印&quot;父进程号+自己的进程号+你的学号+main&quot;信息即可；分裂出的子进
程进入死循环操作，要求每15 秒打印&quot;父进程号+自己的进程号+你的学号+sub&quot;；写配套的
makefile 文件，make 后可生成test4-1 可执行文件</strong></p>
<pre><code>//test4-1.c

#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/wait.h&gt;

#define FORK_NUM 10
#define FORK_SLEEP_TIME 3
#define MAIN_SLEEP_TIME 5
#define SUB_SLEEP_TIME 15

int daemon_init(void){
    pid_t pid;
    if ((pid = fork()) &lt; 0)
		return -1;
	else if (pid)   
		exit(0);	/* parent exit */

	/* child continues */
	setsid();	/* become session leader */
    chdir(&quot;/&quot;);	/* change working directory */
	umask(0);	/* clear file mode creation mask */
	close(0);    /* close stdin stdout stderr */
//	close(1);
	close(2);
	return 0;
}

int main(){
	if (daemon_init() == -1){
		printf(&quot;can't fork self\n&quot;);
		exit(0);
	}
	
	pid_t pid;
	int i;
	for (i=0; i&lt;FORK_NUM; ++i)
		if ((pid=fork()) &lt; 0){
			perror(&quot;fork error&quot;);
			exit(errno);
		}
		else if(pid==0)
			//子进程退出
			break;
		else 
			//父进程间隔3s
			sleep(FORK_SLEEP_TIME);	
	
	if(pid){	//父进程
		while(1){
			printf(&quot;%d %d 1453381 main\n&quot;, getppid(), getpid());
			sleep(MAIN_SLEEP_TIME);
		}
	}
	else{		//子进程
		while(1){
			printf(&quot;%d %d 1453381 sub\n&quot;, getppid(), getpid());
			sleep(SUB_SLEEP_TIME);
		}
	}
	
	return 0;
}
</code></pre>
<p>makefile :</p>
<pre><code>CC ?= gcc
CFLAGS =

srcNames :=test4-1 test4-2

all :
	@for src in $(srcNames) ; \
	do \
		$(CC) $(CFLAGS) -o $$src &quot;$$src&quot;.c ; \
	done

clean :
	rm -f *.o $(srcNames)

.PHONY : all clean
</code></pre>
<p>测试截图：</p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程4/0.jpg" alt=""></p>
</li>
<li>
<p><strong>如何杀死test4-1 分裂出来的一个子进程？</strong></p>
<pre><code>kill -9 pid
</code></pre>
</li>
<li>
<p><strong>如何快速杀死test4-1 分裂出来的全部子进程？</strong></p>
<pre><code>ps -ef |grep test4-1 |grep -v grep|cut -c 9-15|xargs kill -9

# 批量杀死包含关键字&quot;test4-1&quot;的进程
# &quot;ps -ef&quot; ——查看所有进程
# &quot;grep test4-1&quot; ——列出所有含有关键字&quot;test4-1&quot;的进程
# &quot;grep -v grep&quot; ——在列出的进程中去除含有关键字&quot;grep&quot;的进程
# &quot;cut -c 9-15&quot; ——截取输入行的第9个字符到第15个字符，而这正好是进程号PID
# &quot;xargs kill -9&quot; ——xargs 命令是用来把前面命令的输出结果（PID）作为&quot;kill -9&quot;
  命令的参数，并执行该命令。&quot;kill -9&quot;会强行杀掉指定进程。
</code></pre>
<p>测试截图：</p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程4/1.jpg" alt=""></p>
</li>
<li>
<p><strong>如果杀死test4-1，其子进程会发生哪些变化？</strong></p>
<p>子进程成为孤儿进程，被 pid=1 （RedHat7.4下名为systemd） 的进程收留，ppid成为1。</p>
<p>测试截图：</p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程4/2.jpg" alt=""></p>
</li>
<li>
<p><strong>写test4-2.c，要求与test4-1 相同，但是要求杀死test4-2 后，它的全部子进程自动退出</strong></p>
<p>可以在父进程终止退出前，调用kill函数，kill函数相关用法如下:</p>
<pre><code>#include &lt;sys/types.h&gt; 
#include &lt;signal.h&gt;

int kill(pid_t pid, int sig);

作用：用于向任何进程组或进程发送信号。

参数： 
pid：可能选择有以下四种
1. pid大于零时，pid是信号欲送往的进程的标识。
2. pid等于零时，信号将送往所有与调用kill()的那个进程属同一个使用组的进程。
3. pid等于-1时，信号将送往所有调用进程有权给其发送信号的进程，除了进程1(init)。
4. pid小于-1时，信号将送往以-pid为组标识的进程。
</code></pre>
<p>需要在main函数中第一行添加<code>signal(SIGTERM, kill_child);</code>意在父进程退出时进入kill_child函数进行处理，kill_child函数如下：</p>
<pre><code>void kill_child(int sig){
	kill(0, SIGKILL);
	int status;
	while(waitpid(-1, &amp;status, WNOHANG)&gt;0)
		;
	exit(0);
}
</code></pre>
<p>test4-2.c最终代码如下：</p>
<pre><code>//test4-2.c

#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/wait.h&gt;

#define FORK_NUM 10
#define FORK_SLEEP_TIME 3
#define MAIN_SLEEP_TIME 5
#define SUB_SLEEP_TIME 15

int daemon_init(void){
    pid_t pid;
    if ((pid = fork()) &lt; 0)
		return -1;
	else if (pid)   
		exit(0);	/* parent exit */

	/* child continues */
	setsid();	/* become session leader */
    chdir(&quot;/&quot;);	/* change working directory */
	umask(0);	/* clear file mode creation mask */
	close(0);    /* close stdin stdout stderr */
//	close(1);
	close(2);
	return 0;
}

void kill_child(int sig){
	kill(0, SIGKILL);
	int status;
	while(waitpid(-1, &amp;status, WNOHANG)&gt;0)
		;
	exit(0);
}

int main(){
	if (daemon_init() == -1){
		printf(&quot;can't fork self\n&quot;);
		exit(0);
	}

	signal(SIGTERM, kill_child);

	pid_t pid;
	int i;
	for (i=0; i&lt;FORK_NUM; ++i)
		if ((pid=fork()) &lt; 0){
			perror(&quot;fork error&quot;);
			exit(errno);
		}
		else if(pid==0)
			//子进程退出
			break;
		else 
			//父进程间隔3s
			sleep(FORK_SLEEP_TIME);	
	
	pid_t selfid=getpid();
	pid_t faid=getppid();
	
	if(pid){	//父进程
		while(1){
			printf(&quot;%d %d 1453381 main\n&quot;, faid, selfid);
			sleep(MAIN_SLEEP_TIME);
		}
	}
	else{		//子进程
		while(1){
			printf(&quot;%d %d 1453381 sub\n&quot;, faid, selfid);
			sleep(SUB_SLEEP_TIME);
		}
	}
	
	return 0;
}
</code></pre>
<p>最后需要说明的是，杀掉父进程时，需要用<code>kill -15 pid</code>结束，此时定义在main函数中的<code>signal(SIGTERM, kill_child)</code>才会生效，如果用<code>kill -9 pid</code>结束父进程，分裂的子进程父进程变为1，成为孤儿进程。</p>
<p>测试截图：</p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程4/3.jpg" alt=""></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程5/" itemprop="url">Linux守护进程5</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-18T19:44:25+08:00">
                2017-10-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4>Linux守护进程5 — 守护进程分裂子进程极限测试</h4>
<hr>
<ul>
<li>
<p><strong>在05 子目录下写test5-1.c，用main 函数带参数方式带入一个参数表示循环次数，然后循环
指定参数产生子进程，每个子进程中定义一个大小为1024 的字符数组，任意赋值，然后进入
死循环（为了屏幕干净，不用打印信息）；主进程每分裂若干个子进程（例如：10 个/100 个
等，可自行决定）后打印一次&quot;已分裂***个子进程&quot;，循环结束后/或分裂子进程失败后打印
分裂成功的总数，然后进入死循环；写配套的makefile 文件，make 后可生成test5-1 可执行
文件，执行方法为 ./test5-1 1000 表示分裂1000 个子进程</strong></p>
<pre><code>//test5-1.c

#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/wait.h&gt;

#define DEFAULT_NUMS 500
#define PRINT_CYCLE 1000
#define SUB_STR_SIZE 1024
#define SUB_SLEEP_TIME 1
#define MAIN_SLEEP_TIME 1

int daemon_init(void){
    pid_t pid;
    if ((pid = fork()) &lt; 0)
		return -1;
	else if (pid)   
		exit(0);	/* parent exit */

	/* child continues */
	setsid();	/* become session leader */
    chdir(&quot;/&quot;);	/* change working directory */
	umask(0);	/* clear file mode creation mask */
	close(0);    /* close stdin stdout stderr */
//	close(1);
	close(2);
	return 0;
}

void sig_child(int signo){
	while(waitpid(-1, NULL, WNOHANG)&gt;0)
		;
}

int main(int argc, char **argv){
	if (daemon_init() == -1){
		printf(&quot;can't fork self\n&quot;);
		exit(0);
	}
	signal(SIGCHLD, sig_child);
	signal(SIGINT, sig_child);
    signal(SIGTERM, sig_child);
	
	int forkNums=argc&gt;1 ? atoi(argv[1]): DEFAULT_NUMS;
	int i;
	
	pid_t pid;
	
	for (i=0; i&lt;forkNums; ++i){
		if (i%PRINT_CYCLE==0)
			printf(&quot;已分裂 %6d 个子进程\n&quot;, i);
		
		if ((pid=fork()) &lt; 0){
			perror(&quot;fork error&quot;);
			break;
		}
		else if(pid==0)		//子进程退出
			break;
	}

	if (pid==0) {	//子进程
		char str [SUB_STR_SIZE];
		//初始随机，算是随机赋值了吧
		while (1)
			sleep(SUB_SLEEP_TIME);
	}
	else {
		printf(&quot;目标分裂:%d 成功分裂:%d \n&quot;, forkNums, i);
		while (1)
			sleep(MAIN_SLEEP_TIME);
	}
	
	return 0;
}
</code></pre>
<p>makefile</p>
<pre><code>CC ?= gcc
CFLAGS =

srcNames :=test5-1 test5-2 test5-3

all :
	@for src in $(srcNames) ; \
	do \
		$(CC) $(CFLAGS) -o $$src &quot;$$src&quot;.c ; \
	done

clean :
	rm -f *.o $(srcNames)

.PHONY : all clean
</code></pre>
</li>
<li>
<p><strong>虚拟机的内存设置为512MB，分裂数量达到多少时，分裂子进程会失败？</strong></p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程5/1.jpg" alt=""></p>
</li>
<li>
<p><strong>虚拟机的内存为1024MB、2048MB 时，分裂最大数量又是多少？</strong></p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程5/2.jpg" alt=""></p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程5/3.jpg" alt=""></p>
</li>
<li>
<p><strong>把<code>char str[1024]</code>改为<code>char str[1024*10]</code>，再次测试三种内存下的最大分裂数量</strong></p>
<p>512M：</p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程5/4.jpg" alt=""></p>
<p>1024M：</p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程5/5.jpg" alt=""></p>
<p>2048M：</p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程5/6.jpg" alt=""></p>
</li>
<li>
<p><strong>写test5-2.c，要求与test5-1 相同，但是子进程给str 赋值完后，不要死循环，等待20 秒
后子进程退出，在这种情况下，如何做到在小内存的情况下分裂完成指定大数量的子进程？（例如：在512MB 内存情况下，分别100000 个子进程且必须都分裂成功）</strong></p>
<p>要做到在限定内存下同时存在大数量子进程是不行的，但是因为一些子进程会在一定时间推出，只要做到能够收到子进程退出信号回收内存，同时父进程在不能成功fork时休眠一段时间再尝试fork，这样总能成功，完成分裂指定大数量的子进程。测试截图见下一题。</p>
<pre><code>//test5-2.c

#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/wait.h&gt;

#define DEFAULT_NUMS 500
#define PRINT_CYCLE 1000
#define SUB_STR_SIZE 1024
#define SUB_SLEEP_TIME 20
#define MAIN_SLEEP_TIME 1

int daemon_init(void){
    pid_t pid;
    if ((pid = fork()) &lt; 0)
		return -1;
	else if (pid)   
		exit(0);	/* parent exit */

	/* child continues */
	setsid();	/* become session leader */
    chdir(&quot;/&quot;);	/* change working directory */
	umask(0);	/* clear file mode creation mask */
	close(0);   /* close stdin stdout stderr */
//	close(1);
	close(2);
	return 0;
}

void sig_child(int signo){
	while(waitpid(-1, NULL, WNOHANG)&gt;0)
		;
}

int main(int argc, char **argv){
	if (daemon_init() == -1){
		printf(&quot;can't fork self\n&quot;);
		exit(0);
	}
	signal(SIGCHLD, sig_child);
	signal(SIGINT, sig_child);
    signal(SIGTERM, sig_child);
	
	int forkNums=argc&gt;1 ? atoi(argv[1]): DEFAULT_NUMS;
	int i, max_pid=0;
	
	pid_t pid;
	
	for (i=0; i&lt;forkNums; ){
		if (i%PRINT_CYCLE==0)
			printf(&quot;已分裂 %6d 个子进程\n&quot;, i);
		
		pid=fork();
		if(pid==0)
			break;
		else if(pid&gt;0)
			++i;
		else
			sleep(MAIN_SLEEP_TIME);

		max_pid= max_pid&lt;pid? pid :max_pid;
	}

	if (pid==0) {	//子进程
		char str [SUB_STR_SIZE];
		//初始随机，算是随机赋值了吧
		sleep(SUB_SLEEP_TIME);
		exit(0);
	}
	else {			//父进程
		printf(&quot;目标分裂:%d 成功分裂:%d \n&quot;, forkNums, i);
		printf(&quot;max_pid = %d \n&quot;, max_pid);
		while (1)
			sleep(MAIN_SLEEP_TIME);
	}
	
	return 0;
}
</code></pre>
</li>
<li>
<p><strong>在test5-2.c 中加适当的语句，看分裂的子进程的最大进程号是多少？</strong></p>
<p>测试1截图（10w）：</p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程5/70.jpg" alt=""></p>
<p>测试2截图(10w)：</p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程5/71.jpg" alt=""></p>
<p>测试3截图(100w)：</p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程5/72.jpg" alt=""></p>
<p>测试4截图(100w)：</p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程5/73.jpg" alt=""></p>
</li>
<li>
<p><strong>写test5-3.c，基本要求同test5-2，但是由守护进程负责回收每个子进程退出信号，设置两
个全局变量做为计数器，一个记录分裂成功的数量，一个记录回收成功的数量，要求全部分
裂完成后，且所有子进程都退出后，两个计数器的值要相同（测试数量≧50000）</strong></p>
<p>在test5-2.c的基础上，只要做到子进程退出时，通知到父进程，父进程调用函数处理即可。</p>
<pre><code>//test5-3.c

#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/wait.h&gt;

#define DEFAULT_NUMS 500
#define PRINT_CYCLE 1000
#define SUB_STR_SIZE 1024
#define SUB_SLEEP_TIME 1
#define MAIN_SLEEP_TIME 1
#define ERROR_SLEEP_TIME SUB_SLEEP_TIME

int daemon_init(void){
    pid_t pid;
    if ((pid = fork()) &lt; 0)
		return -1;
	else if (pid)   
		exit(0);	/* parent exit */

	/* child continues */
	setsid();	/* become session leader */
    chdir(&quot;/&quot;);	/* change working directory */
	umask(0);	/* clear file mode creation mask */
	close(0);   /* close stdin stdout stderr */
//	close(1);
	close(2);
	return 0;
}

int exitNums=0;

void sig_child(int signo){
	while(waitpid(-1, NULL, WNOHANG)&gt;0)
		++exitNums;
}

int main(int argc, char **argv){
	if (daemon_init() == -1){
		printf(&quot;can't fork self\n&quot;);
		exit(0);
	}
	
	signal(SIGCHLD, sig_child);
	signal(SIGINT, sig_child);
    signal(SIGTERM, sig_child);
	
	int forkNums=argc&gt;1 ? atoi(argv[1]): DEFAULT_NUMS;
	int i, max_pid=0;
	
	pid_t pid;
	
	for (i=0; i&lt;forkNums; ){
		if (i%PRINT_CYCLE==0)
			printf(&quot;已分裂 %6d 个子进程\n&quot;, i);
		
		pid=fork();
		if(pid==0)
			break;
		else if(pid&gt;0)
			++i;
		else
			sleep(MAIN_SLEEP_TIME);

		max_pid= max_pid&lt;pid? pid :max_pid;
	}

	if (pid==0) {	//子进程
		char str [SUB_STR_SIZE];
		//初始随机，算是随机赋值了吧
		sleep(SUB_SLEEP_TIME);
		exit(0);
	}
	else {			//父进程
		printf(&quot;目标分裂:%d 成功分裂:%d \n&quot;, forkNums, i);
		printf(&quot;max_pid = %d \n&quot;, max_pid);
		while (1){
			printf(&quot;成功分裂%d个， 成功回收%d个\n&quot;, i, exitNums);
			sleep(MAIN_SLEEP_TIME);
		}
	}
	
	return 0;
}
</code></pre>
<p>测试截图</p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程5/80.jpg" alt="">
<img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程5/81.jpg" alt=""></p>
</li>
<li>
<p><strong>提示：当极限测试导致子进程分裂失败后，Linux 系统还能正常操作吗？</strong></p>
<p>已经不能正常工作。</p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程5/9.jpg" alt=""></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程3/" itemprop="url">Linux守护进程3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-18T19:44:25+08:00">
                2017-10-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4>Linux守护进程3 —— 守护进程分裂子进程</h4>
<hr>
<ul>
<li>
<p><strong>在03 子目录下写test3-1.c，循环10 次，每隔3 秒产生一个子进程，循环完成后，自己进入
死循环操作，每5 秒打印&quot;父进程号+自己的进程号+你的学号+main&quot;信息即可；分裂出的子进
程要求每25 秒打印&quot;父进程号+自己的进程号+你的学号+sub&quot;，打印三次后子进程退出；写配
套的makefile 文件，make 后可生成test3-1 可执行文件</strong></p>
<pre><code>//test3-1.c

#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/wait.h&gt;

#define FORK_NUM 10
#define SUB_NUM 3
#define MAIN_SLEEP_TIME 5
#define SUB_SLEEP_TIME 25

int daemon_init(void){
    pid_t pid;
    if ((pid = fork()) &lt; 0)
		return -1;
	else if (pid)   
		exit(0);	/* parent exit */

	/* child continues */
	setsid();	/* become session leader */
    chdir(&quot;/&quot;);	/* change working directory */
	umask(0);	/* clear file mode creation mask */
	close(0);    /* close stdin stdout stderr */
//	close(1);
	close(2);
	return 0;
}

int main(){
	if (daemon_init() == -1){
		printf(&quot;can't fork self\n&quot;);
		exit(0);
	}

	pid_t pid;
	int i;
	for (i=0; i&lt;FORK_NUM; ++i)
		if ((pid=fork()) &lt; 0){
			perror(&quot;fork error&quot;);
			exit(errno);
		}
		else if(pid==0)
			break;
	
	if(pid){
		while(1){
			printf(&quot;%5d %5d 1453381 main\n&quot;, getppid(), getpid());
			sleep(MAIN_SLEEP_TIME);
		}
	}
	else{
		for (i=1; i&lt;=SUB_NUM; ++i){
			printf(&quot;%5d %5d 1453381 sub\n&quot;, getppid(), getpid());
			sleep(SUB_SLEEP_TIME);
		}
	}
	
	return 0;
}
</code></pre>
<p>测试截图：</p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程3/1.jpg" alt=""></p>
</li>
<li>
<p><strong>分裂出的子进程和守护进程之间的进程id 有何关联？</strong></p>
<p>子进程的ppid为父进程的pid。</p>
<p>测试截图：</p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程3/2.jpg" alt=""></p>
</li>
<li>
<p><strong>什么叫僵尸进程？僵尸进程的产生原因？</strong></p>
<p><strong>僵尸进程：</strong> 一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</p>
<p><strong>原因：</strong> 在Linux进程的状态中，僵尸进程是非常特殊的一种，它需要它的父进程来为它收尸，如果他的父进程没安装SIGCHLD信号处理函数调用wait或waitpid（）等待子进程结束，又没有显式忽略该信号，那么它就一直保持僵尸状态，如果这时父进程结束了，那么init进程自动会接手这个子进程，为它收尸，它还是能被清除的。但是如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是为什么系统中有时会有很多的僵尸进程。</p>
</li>
<li>
<p><strong>如何杀死僵尸进程？</strong></p>
<p>一般杀掉进程可用 <code>kill -9 pid</code>命令，但是有些僵尸进程通过此命令不行。可以通过杀掉父进程结束。</p>
<p>测试截图：</p>
<p><img src="/2017/10/18/Linux/homework/Linux守护进程/Linux守护进程3/3.jpg" alt=""></p>
</li>
<li>
<p><strong>写test3-2.c，要求同test3-1，但是子进程退出后不能存在僵尸进程</strong></p>
<p><strong>僵尸进程解决办法</strong></p>
<p>（1）通过信号机制<br>
子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。</p>
<pre><code>//test3-2.c 新增函数
void sig_child(int signo){
	int status;
	pid_t pid;
	while((pid=waitpid(-1, &amp;status, WNOHANG))&gt;0)
		;
}

//在main函数第一行添加
signal(SIGCHLD, sig_child);
</code></pre>
<p>在Linux下 可以简单地将 SIGCHLD信号的操作设为SIG_IGN。</p>
<pre><code>signal(SIGCHLD,SIG_IGN);
</code></pre>
<p>（2）fork两次<br>
原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。</p>
<p>基于第一种方法实现：</p>
<pre><code>//test3-2.c

#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/wait.h&gt;

#define FORK_NUM 10
#define SUB_NUM 3
#define MAIN_SLEEP_TIME 5
#define SUB_SLEEP_TIME 25

int daemon_init(void){
    pid_t pid;
    if ((pid = fork()) &lt; 0)
		return -1;
	else if (pid)   
		exit(0);	/* parent exit */

	/* child continues */
	setsid();	/* become session leader */
    chdir(&quot;/&quot;);	/* change working directory */
	umask(0);	/* clear file mode creation mask */
	close(0);    /* close stdin stdout stderr */
//	close(1);
	close(2);
	return 0;
}

void sig_child(int signo){
	int status;
	pid_t pid;
	while((pid=waitpid(-1, &amp;status, WNOHANG))&gt;0)
		;
}

int main(){
	if (daemon_init() == -1){
		printf(&quot;can't fork self\n&quot;);
		exit(0);
	}
	
	signal(SIGCHLD, sig_child);

	pid_t pid;
	int i;
	
	for (i=0; i&lt;FORK_NUM; ++i)
		if ((pid=fork()) &lt; 0){
			perror(&quot;fork error&quot;);
			exit(errno);
		}
		else if(pid==0)
			break;
	
	if(pid){
		while(1){
			printf(&quot;%5d %5d 1453381 main\n&quot;, getppid(), getpid());
			sleep(MAIN_SLEEP_TIME);
		}
	}
	else{
		for (i=1; i&lt;=SUB_NUM; ++i){
			printf(&quot;%5d %5d 1453381 sub\n&quot;, getppid(), getpid());
			sleep(SUB_SLEEP_TIME);
		}
	}
	
	return 0;
}
</code></pre>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/Linux/homework/LinuxMySQL静态编译/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/08/Linux/homework/LinuxMySQL静态编译/" itemprop="url">Linux-MySQL的静态编译</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T23:26:12+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<ol>
<li>
<p><strong>准备</strong></p>
<p>1.1 <strong>libc 静态库文件</strong><br>
若缺少libc静态库文件，则会失败，如下信息。</p>
<p><img src="/2017/10/08/Linux/homework/LinuxMySQL静态编译/1.png" alt=""></p>
<p>安装如下：
首先下载相应安装包，<a href="https://centos.pkgs.org/7/centos-x86_64/glibc-static-2.17-196.el7.x86_64.rpm.html" target="_blank" rel="external">下载地址</a>，放置到任意目录下（此处为/home），进入该目录，</p>
<p>执行如下命令，升级安装完成。</p>
<p><img src="/2017/10/08/Linux/homework/LinuxMySQL静态编译/2.jpg" alt=""></p>
<p>可查看系统安装的GLIBC包，如下</p>
<p><img src="/2017/10/08/Linux/homework/LinuxMySQL静态编译/3.png" alt=""></p>
<p>1.2 <strong>获取libmysqlclient.a静态库</strong><br>
<strong>下载源码编译方式</strong></p>
<p>获取MariaDB源码
下载相应源码，下载地址https://downloads.mariadb.org/mariadb/5.5.56/ 下载后传到虚拟机中，解压然后编译。</p>
<p><img src="/2017/10/08/Linux/homework/LinuxMySQL静态编译/4.png" alt=""></p>
<p>准备安装环境</p>
<pre><code>yum –y groupinstall Development tools
yum –y install ncurses-devel
yum –y install cmake
</code></pre>
<p>编译MariaDB得到libmysqlclient.a</p>
<pre><code>tar –zxvf mariadb-5.5.56.tar.gz
cd mariadb-5.5.56
cmake . –LH		#查看cmake的可用选项
cmake . -DCMAKE_INSTALL_PREFIX=/home/mysql
        -DMYSQL_DATADIR=/home/mysqldata -DSYSCONFDIR=/etc 
        -DWITHOUT_TOKUDB=1 -DMYSQL_UNIX_ADDR=/home/tmp/mysql.sock 
        -DDEFAULT_CHARSET=gbk -DDEFAULT_COLLATION=gbk_general_ci
make
make install
</code></pre>
<p>完成上述命令后，在/home/mysql/lib/目录下可得到libmysqlclient.a静态库文件</p>
<p><strong>直接获取libmysqlclient.a方式</strong><br>
下载编译后的MariaDB文件，<a href="https://downloads.mariadb.org/mariadb/5.5.56/" target="_blank" rel="external">下载地址</a></p>
<p><img src="/2017/10/08/Linux/homework/LinuxMySQL静态编译/5.jpg" alt=""></p>
<p>解压</p>
<pre><code>tar -zxvf mariadb-5.5.56-linux-x86_64.tar.gz
</code></pre>
<p>在mariadb-5.5.56-linux-x86_64目录下的lib文件夹下得到libmysqlclient.a文件</p>
<p><img src="/2017/10/08/Linux/homework/LinuxMySQL静态编译/6.png" alt=""></p>
</li>
<li>
<p><strong>编译</strong></p>
<p><strong>编译说明：</strong></p>
<pre><code> 这里采用的是半静态半动态编译方法。libmysqlclient.a库用静态连接，一些常用的库用动态连接。
 因为程序是运行在linux中的，常用库系统默认都会有的。  
</code></pre>
<p><strong>编译命令：</strong></p>
<pre><code> g++ mysql_demo.cpp -o mysql_demo -I/usr/include/mysql -Wl,-dn -L. 
  -lmysqlclient  -Wl,-dy -lpthread -lm -ldl -lcrypt
</code></pre>
<p><strong>命令解释：</strong></p>
<pre><code> -Idir
 编译时优先在选项后的目录中查找包含的头文件,然后将到系统缺省的头文件目录查找
 -Ldir
 指定编译搜索库的路径
 -llibrary
 制定编译的时候使用的库
 -Wl,-dn
 后面是静态链接
 -Wl,-dy
 后面是动态连接
</code></pre>
<p><strong>库解释：</strong></p>
<pre><code> -lpthread
 使用POSIX线程库添加对多线程的支持
 -lm 
 链接的是数学函数库
 -ldl
 显式加载动态库的动态函数库（dlopen(),dlclose() , dlerror() , dlsym()）
</code></pre>
</li>
<li>
<p><strong>运行</strong></p>
<p>ln命令用来为文件创件连接，连接类型分为硬连接和符号连接两种，默认的连接类型是硬连接。如果要创建符号连接必须使用&quot;-s&quot;选项。</p>
<pre><code>ln -s /var/lib/mysql/mysql.sock /tmp/mysql.sock
</code></pre>
<p><img src="/2017/10/08/Linux/homework/LinuxMySQL静态编译/7.jpg" alt=""></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/Linux/homework/Linux动态编译/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/08/Linux/homework/Linux动态编译/" itemprop="url">Linux动态编译</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T22:16:50+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<pre><code>前几周的做的，懒得重新编辑，图较多，直接截图了。
</code></pre>
<p><img src="/2017/10/08/Linux/homework/Linux动态编译/11.jpg" alt="11">
<img src="/2017/10/08/Linux/homework/Linux动态编译/12.jpg" alt="12">
<img src="/2017/10/08/Linux/homework/Linux动态编译/13.jpg" alt="13">
<img src="/2017/10/08/Linux/homework/Linux动态编译/14.jpg" alt="14">
<img src="/2017/10/08/Linux/homework/Linux动态编译/15.jpg" alt="15">
<img src="/2017/10/08/Linux/homework/Linux动态编译/16.jpg" alt="16"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/Linux/homework/Linux静态编译/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/08/Linux/homework/Linux静态编译/" itemprop="url">Linux静态编译</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T21:45:01+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<pre><code>前几周的做的，懒得重新编辑，图较多，直接截图了。
</code></pre>
<p><img src="/2017/10/08/Linux/homework/Linux静态编译/11.jpg" alt="11">
<img src="/2017/10/08/Linux/homework/Linux静态编译/12.jpg" alt="12">
<img src="/2017/10/08/Linux/homework/Linux静态编译/13.jpg" alt="13">
<img src="/2017/10/08/Linux/homework/Linux静态编译/14.jpg" alt="14">
<img src="/2017/10/08/Linux/homework/Linux静态编译/15.jpg" alt="15"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/Linux/homework/Linux-Makefile的基本使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/08/Linux/homework/Linux-Makefile的基本使用/" itemprop="url">Linux-Makefile的基本使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T20:59:27+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3>Makefile之我见</h3>
<ol>
<li>
<p><strong>Makefile文件的作用</strong></p>
<p>Linux内核中 Makefile 的作用是根据配置的情况，构造出需要编译的源文件列表，然后分别编译，并把目标代码链接到一起，最终形成 linux 内核二进制文件。</p>
<p>一个工程中的源文件不计其数，按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p>
<p>makefile文件保存了编译器和连接器的参数选项,还表述了所有源文件之间的关系(源代码文件需要的特定的包含文件,可执行文件要求包含的目标文件模块及库等).创建程序(make程序)首先读取makefile文件,然后再激活编译器,汇编器,资源编译器和连接器以便产生最后的输出,最后输出并生成的通常是可执行文件.创建程序利用内置的推理规则来激活编译器,以便通过对特定CPP文件的编译来产生特定的OBJ文件.</p>
</li>
<li>
<p><strong>作业中用到的基本语法</strong></p>
<p><strong>Makefile基本格式：</strong></p>
<pre><code>target ... : prerequisites ...
command
...
...
</code></pre>
<p>target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label）。
prerequisites就是，要生成那个target所需要的文件或是目标。
command也就是make需要执行的命令。（任意的Shell命令）
这是一个文件的依赖关系，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。</p>
<p><strong>关于依赖关系</strong><br>
make会一层一层的去找文件的依赖关系，最终编译出第一个目标文件。</p>
<p><strong>关于重新编译</strong><br>
只要任何prerequisite 比 target新，那么这个目标文件就会被下面的命令重新生成。每一个命令都会被传递到shell中，并在自己的子shell里面执行。</p>
<p><strong>关于错误</strong><br>
如果在寻找过程中出现错误，如文件找不到，则make会直接退出并报错。对于所定义的命令错误或者编译不成功，make是不会理会的，它只负责文件的依赖性。</p>
<p><strong>变量的基本使用</strong><br>
在Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是Makefile的其它部分中。
变量在声明时需要给予初值，而在使用时，需要给在变量名前加上“$”符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来。</p>
<p><strong>伪目标</strong><br>
伪目标是这样一个目标：它不代表一个真正的文件名，在执行make时可以指定这个目标来执行其所在规则定义的命令，有时我们也可以将一个伪目标称为标签。
将一个目标声明为伪目标需要将它作为特殊目标.PHONY的依赖。如下：</p>
<pre><code>.PHONY : clean 
clean: 
rm *.o temp 
</code></pre>
<p>这样目标clean就是一个伪目标，无论当前目录下是否存在clean这个文件。我们输入make clean之后。rm命令都会被执行。而且，当一个目标被声明为伪目标后，make在执行此规则时不会试图去查找隐含规则来创建这个目标。这样也提高了make的执行效率，同时我们也不用担心由于目标和文件名重名而使我们的期望失败。</p>
<p><strong>Makefile自动推导</strong><br>
GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来。</p>
<p><strong>嵌套执行make</strong><br>
在Makefile中使用“make”作为一个命令来执行本身或者其它makefile文件。递归调用在一个村在有多级子目录的项目中非常有用。例如，当前目录下存在一个“subdir”子目录，这个子目录中有描述这个目录编译规则的makefile文件，在执行make时需要从上层目录（当前目录）开始并完成它所有子目录的编译。那么在当前目录下可以使用这样一个规则来实现对它的子目录的编译：</p>
<pre><code>subsystem:
   $(MAKE) -C subdir
</code></pre>
<p>规则中“$(MAKE)”是对变量“MAKE”的引用，在make的递归调用中，需要了解变量“CURDIR”，此变量代表了make当前的工作路径。如果使用“-C”选项进入一个子目录后，此变量将被重新赋值。总之，如果在Makefile中没有对此变量进行显式的赋值操作，那么它代表make的当前工作目录。我们也可以在Makefile为这个变量赋一个新的值。此时这变量将不再代表make的工作目录。</p>
<p><strong>Shell函数</strong><br>
shell函数也不像其它的函数。它的参数应该就是操作系统Shell的命令。它和反引号“`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：</p>
<pre><code>contents := $(shell cat foo) 
files := $(shell echo *.c) 
</code></pre>
<p>注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。</p>
<p><strong>for循环</strong><br>
在makefile中使用for语句，其行结束要使用“；\”do的前后用空格分开用\结尾；for语句内循环要用2个Tab。形如：</p>
<pre><code>@(for i in $(files); do \
echo &quot;$$i &quot;;\
done
</code></pre>
</li>
</ol>
<hr>
<h3>系统概述Makefile</h3>
<ol>
<li>
<p><strong>Make的概念</strong></p>
<p>Make这个词，英语的意思是&quot;制作&quot;。Make命令直接用了这个意思，就是要做出某个文件。比如，要做出文件a.txt，就可以执行下面的命令。</p>
<pre><code>$ make a.txt
</code></pre>
<p>但是，如果你真的输入这条命令，它并不会起作用。因为Make命令本身并不知道，如何做出a.txt，需要有人告诉它，如何调用其他命令完成这个目标。
比如，假设文件 a.txt 依赖于 b.txt 和 c.txt ，是后面两个文件连接（cat命令）的产物。那么，make 需要知道下面的规则。</p>
<pre><code>a.txt: b.txt c.txt
cat b.txt c.txt &gt; a.txt
</code></pre>
<p>也就是说，make a.txt 这条命令的背后，实际上分成两步：第一步，确认 b.txt 和 c.txt 必须已经存在，第二步使用 cat 命令 将这个两个文件合并，输出为新文件。
像这样的规则，都写在一个叫做Makefile的文件中，Make命令依赖这个文件进行构建。Makefile文件也可以写为makefile， 或者用命令行参数指定为其他文件名。</p>
<pre><code>$ make -f rules.txt
# 或者
$ make --file=rules.txt
</code></pre>
<p>上面代码指定make命令依据rules.txt文件中的规则，进行构建。
总之，make只是一个根据指定的Shell命令进行构建的工具。它的规则很简单，你规定要构建哪个文件、它依赖哪些源文件，当那些文件有变动时，如何重新构建它。</p>
</li>
<li>
<p><strong>Makefile文件的格式</strong></p>
<p>2.1 <strong>概述</strong><br>
Makefile文件由一系列规则（rules）构成。每条规则的形式如下。</p>
<pre><code>&lt;target&gt; : &lt;prerequisites&gt; 
[tab]  &lt;commands&gt;
</code></pre>
<p>上面第一行冒号前面的部分，叫做&quot;目标&quot;（target），冒号后面的部分叫做&quot;前置条件&quot;（prerequisites）；第二行必须由一个tab键起首，后面跟着&quot;命令&quot;（commands）。
&quot;目标&quot;是必需的，不可省略；&quot;前置条件&quot;和&quot;命令&quot;都是可选的，但是两者之中必须至少存在一个。
每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。</p>
<p>2.2 <strong>目标（target）</strong><br>
一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。
除了文件名，目标还可以是某个操作的名字，这称为&quot;伪目标&quot;（phony target）。
clean:
rm *.o</p>
<p>上面代码的目标是clean，它不是文件名，而是一个操作的名字，属于&quot;伪目标 &quot;，作用是删除对象文件。</p>
<pre><code>$ make  clean
</code></pre>
<p>但是，如果当前目录中，正好有一个文件叫做clean，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。
为了避免这种情况，可以明确声明clean是&quot;伪目标&quot;，写法如下。</p>
<pre><code>.PHONY: clean
clean:
rm *.o temp
</code></pre>
<p>声明clean是&quot;伪目标&quot;之后，make就不会去检查是否存在一个叫做clean的文件，而是每次运行都执行对应的命令。像.PHONY这样的内置目标名还有不少，可以查看手册。
如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。</p>
<pre><code>$ make
</code></pre>
<p>上面代码执行Makefile文件的第一个目标。</p>
<p>2.3 <strong>前置条件（prerequisites）</strong><br>
前置条件通常是一组文件名，之间用空格分隔。它指定了&quot;目标&quot;是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），&quot;目标&quot;就需要重新构建。</p>
<pre><code>result.txt: source.txt
cp source.txt result.txt
</code></pre>
<p>上面代码中，构建 result.txt 的前置条件是 source.txt 。如果当前目录中，source.txt 已经存在，那么make result.txt可以正常运行，否则必须再写一条规则，来生成 source.txt 。</p>
<pre><code>source.txt:
echo &quot;this is the source&quot; &gt; source.txt
</code></pre>
<p>上面代码中，source.txt后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件还不存在，每次调用make source.txt，它都会生成。
$ make result.txt
$ make result.txt</p>
<p>上面命令连续执行两次make result.txt。第一次执行会先新建 source.txt，然后再新建 result.txt。第二次执行，Make发现 source.txt 没有变动（时间戳晚于 result.txt），就不会执行任何操作，result.txt 也不会重新生成。
如果需要生成多个文件，往往采用下面的写法。</p>
<pre><code>source: file1 file2 file3
</code></pre>
<p>上面代码中，source 是一个伪目标，只有三个前置文件，没有任何对应的命令。</p>
<pre><code>$ make source
</code></pre>
<p>执行make source命令后，就会一次性生成 file1，file2，file3 三个文件。这比下面的写法要方便很多。</p>
<pre><code>$ make file1
$ make file2
$ make file3
</code></pre>
<p>2.4 <strong>命令（commands）</strong><br>
命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建&quot;目标&quot;的具体指令，它的运行结果通常就是生成目标文件。
每行命令之前必须有一个tab键。如果想用其他键，可以用内置变量.RECIPEPREFIX声明。</p>
<pre><code>.RECIPEPREFIX = &gt;
all:
&gt; echo Hello, world
</code></pre>
<p>上面代码用.RECIPEPREFIX指定，大于号（&gt;）替代tab键。所以，每一行命令的起首变成了大于号，而不是tab键。
需要注意的是，每行命令在一个单独的shell中执行。这些Shell之间没有继承关系。</p>
<pre><code>var-lost:
export foo=bar
echo &quot;foo=[$$foo]&quot;
</code></pre>
<p>上面代码执行后（make var-lost），取不到foo的值。因为两行命令在两个不同的进程执行。一个解决办法是将两行命令写在一行，中间用分号分隔。</p>
<pre><code>var-kept:
export foo=bar; echo &quot;foo=[$$foo]&quot;
</code></pre>
<p>另一个解决办法是在换行符前加反斜杠转义。</p>
<pre><code>var-kept:
export foo=bar; \
echo &quot;foo=[$$foo]&quot;
</code></pre>
<p>最后一个方法是加上.ONESHELL:命令。</p>
<pre><code>.ONESHELL:
var-kept:
export foo=bar; 
echo &quot;foo=[$$foo]&quot;
</code></pre>
</li>
<li>
<p><strong>Makefile文件的语法</strong></p>
<p>3.1 <strong>注释</strong><br>
井号（#）在Makefile中表示注释。</p>
<pre><code># 这是注释
result.txt: source.txt
# 这是注释
cp source.txt result.txt # 这也是注释
</code></pre>
<p>3.2 <strong>回声（echoing）</strong><br>
正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。</p>
<pre><code>test:
# 这是测试
</code></pre>
<p>执行上面的规则，会得到下面的结果。</p>
<pre><code>$ make test
# 这是测试
</code></pre>
<p>在命令的前面加上@，就可以关闭回声。</p>
<pre><code>test:
@# 这是测试
</code></pre>
<p>现在再执行make test，就不会有任何输出。
由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。</p>
<pre><code>test:
@# 这是测试
@echo TODO
</code></pre>
<p>3.3 <strong>通配符</strong><br>
通配符（wildcard）用来指定一组符合条件的文件名。Makefile 的通配符与 Bash 一致，主要有星号（*）、问号（？）和 [...] 。比如， *.o 表示所有后缀名为o的文件。</p>
<pre><code>clean:
    rm -f *.o
</code></pre>
<p>3.4 <strong>模式匹配</strong><br>
Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。</p>
<pre><code>%.o: %.c
</code></pre>
<p>等同于下面的写法。</p>
<pre><code>f1.o: f1.c
f2.o: f2.c
</code></pre>
<p>使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。</p>
<p>3.5 <strong>变量和赋值符</strong><br>
Makefile 允许使用等号自定义变量。</p>
<pre><code>txt = Hello World
test:
    @echo $(txt)
</code></pre>
<p>上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中。
调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。</p>
<pre><code>test:
    @echo $$HOME
</code></pre>
<p>有时，变量的值可能指向另一个变量。</p>
<pre><code>v1 = $(v2)
</code></pre>
<p>上面代码中，变量 v1 的值是另一个变量 v2。这时会产生一个问题，v1 的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。
为了解决类似问题，Makefile一共提供了四个赋值运算符 （=、:=、？=、+=），它们的区别请看StackOverflow。</p>
<pre><code>VARIABLE = value
# 在执行时扩展，允许递归扩展。

VARIABLE := value
# 在定义时扩展。

VARIABLE ?= value
# 只有在该变量为空时才设置值。

VARIABLE += value
# 将值追加到变量的尾端。
</code></pre>
<p>3.6 <strong>内置变量（Implicit Variables）</strong><br>
Make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性，详细的内置变量清单见手册。</p>
<pre><code>output:
$(CC) -o output input.c
</code></pre>
<p>3.7 <strong>自动变量（Automatic Variables）</strong><br>
Make命令还提供一些自动变量，它们的值与当前规则有关。主要有以下几个。</p>
<pre><code>（1）$@
$@指代当前目标，就是Make命令当前构建的那个目标。比如，make foo的 $@ 就指代foo。
a.txt b.txt: 
    touch $@
等同于下面的写法。
a.txt:
    touch a.txt
b.txt:
    touch b.txt
（2）$&lt;
$&lt; 指代第一个前置条件。比如，规则为 t: p1 p2，那么$&lt; 就指代p1。
a.txt: b.txt c.txt
    cp $&lt; $@ 
等同于下面的写法。
</code></pre>
</li>
<li>
<p><strong>Makefile 的实例</strong></p>
<pre><code>（1）执行多个目标
.PHONY: cleanall cleanobj cleandiff

cleanall : cleanobj cleandiff
        rm program

cleanobj :
        rm *.o

cleandiff :
        rm *.diff
</code></pre>
<p>上面代码可以调用不同目标，删除不同后缀名的文件，也可以调用一个目标（cleanall），删除所有指定类型的文件。</p>
<pre><code>（2）编译C语言项目
edit : main.o kbd.o command.o display.o 
    cc -o edit main.o kbd.o command.o display.o

main.o : main.c defs.h
    cc -c main.c
kbd.o : kbd.c defs.h command.h
    cc -c kbd.c
command.o : command.c defs.h command.h
    cc -c command.c
display.o : display.c defs.h
    cc -c display.c

clean :
     rm edit main.o kbd.o command.o display.o

.PHONY: edit clean
</code></pre>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/Linux/homework/Linux安装配置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/08/Linux/homework/Linux安装配置/" itemprop="url">Linux安装配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T14:22:13+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>1.安装Linux基本系统</h2>
<p>按照老师下发文档逐步完成即可。</p>
<h2>2.设置网卡</h2>
<p><img src="/2017/10/08/Linux/homework/Linux安装配置/21.jpg" alt="">
<img src="/2017/10/08/Linux/homework/Linux安装配置/22.jpg" alt=""></p>
<h2>3.双向ping通</h2>
<p><img src="/2017/10/08/Linux/homework/Linux安装配置/31.jpg" alt=""></p>
<h2>4.Secure安装登录</h2>
<p><img src="/2017/10/08/Linux/homework/Linux安装配置/41.jpg" alt=""></p>
<h2>5.中文显示</h2>
<p><img src="/2017/10/08/Linux/homework/Linux安装配置/51.jpg" alt=""></p>
<h2>6.配置数据库-登录启动</h2>
<p><img src="/2017/10/08/Linux/homework/Linux安装配置/61.jpg" alt=""></p>
<h2>7.配置数据库-字符集</h2>
<p><img src="/2017/10/08/Linux/homework/Linux安装配置/71.jpg" alt=""></p>
<p><img src="/2017/10/08/Linux/homework/Linux安装配置/72.jpg" alt=""></p>
<p><img src="/2017/10/08/Linux/homework/Linux安装配置/73.jpg" alt=""></p>
<p><img src="/2017/10/08/Linux/homework/Linux安装配置/74.jpg" alt=""></p>
<h2>8.安装配置 PHP Apache</h2>
<p>本次作业<a href="http://blog.btthly.com/rhel-configure-lamp-server-7-0-installation-apachephpmariadb.html" target="_blank" rel="external">参考链接</a>，其中包含了几乎所有安装配置过程，但是有些地方有误或不同，个人操作如下（红色代表不同）：</p>
<p><img src="/2017/10/08/Linux/homework/Linux安装配置/81.jpg" alt="">
<img src="/2017/10/08/Linux/homework/Linux安装配置/82.jpg" alt="">
<img src="/2017/10/08/Linux/homework/Linux安装配置/83.jpg" alt="">
<img src="/2017/10/08/Linux/homework/Linux安装配置/84.jpg" alt="">
<img src="/2017/10/08/Linux/homework/Linux安装配置/85.jpg" alt="">
<img src="/2017/10/08/Linux/homework/Linux安装配置/86.jpg" alt="">
<img src="/2017/10/08/Linux/homework/Linux安装配置/87.jpg" alt=""></p>
<h2>9.安装MySQL组件</h2>
<p><img src="/2017/10/08/Linux/homework/Linux安装配置/91.jpg" alt="">
<img src="/2017/10/08/Linux/homework/Linux安装配置/92.jpg" alt=""></p>
<h2>10.修改FLASHFXP配置</h2>
<p><img src="/2017/10/08/Linux/homework/Linux安装配置/101.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/Life/to be continued/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/08/Life/to be continued/" itemprop="url">To be continued ...</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T13:47:40+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p><strong>历史的进程还在继续...<br>
Life is continuing...</strong></p>
<h6>2018/1/29 16:01:07</h6>
<p>我说过，这个博客我会一直写下去，好久不见，这个学期本来就比较繁忙，有经历了一些事情，前段时间历经网络Final作业和考试周的洗礼，现在终于放假了。It's show Time :)</p>
<h6>2017/10/22 11:22:57</h6>
<p>不要强迫症，没有最完美的东西，绝对没有；
知识和技能的学习才是根本目的，但也要和作业区分开来。</p>
<h6>2017/10/14 13:40:18</h6>
<p>一周一晃又过了，大部分时间都在这上边了，如何节约时间呢？本周总结几点：先易后难，先大部分再小细节，先重要后次要；有时卡壳个别题目可以先留着，有时候前后呼应，有所启发，理解的也深入一些；不要着急写文档，先可以写个60分的草稿。</p>
<h6>2017/10/9 17:20:18</h6>
<p>听课后的小结</p>
<ol>
<li>在实际操作时，多想一下本质总是好的，比如安装Linux虚拟机时NAT模式、bridge、host only模式的区别是什么，选择任意模式连接虚拟机和宿主机时出现问题不懂，光看一些教程即使当时可能正确了，但是按部就班是没有任何收获的，多思考、多尝试非常重要。</li>
<li>很多教程知识并不是完全适用你所在的环境的，比如Linux下有很多版本，光RedHat版本就有几种，同一系列下系统的一些配置命令、文件不同，还有MySQL与MariaDB等类似兼容软件名字不同等等，所以，要学会思考关键词，搜索才会有效率。</li>
<li>对于未知的东西，都应该问为什么，思考、猜测、多尝试才会有收获，不要做一遍之后什么都忘得一干二净。</li>
</ol>
<h6>2017/10/8 13:57:49</h6>
<p>今天算是我的个人博客的开篇吧，其实从小学、初中、高中、大学以来我都没有记笔记或者写作等等习惯，除了高中时期会有一些个人总结、心得感悟之类。一年以前这个博客已经搭建好，也是在国庆期间，发了三遍一般性文章就没有再怎么用到Hexo、GitHub等工具，一直搁到现在...</p>
<p>这一年中，大部分时间其实都在刷数据结构和算法题，以前想写点什么，总是觉得没什么好写，其实完全可以把这一年做的大大小小的算法题目及解题心得放在博客上的，目前只是把部分的题解放在了GitHub中，等有时间回味和复习的时候，把一些比较好的题目整理再推送吧。</p>
<p>希望能够把这个博客写下去，BaiJia Come on !</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/Linux/homework/Linux gcc g++ 编译器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/08/Linux/homework/Linux gcc g++ 编译器/" itemprop="url">Linux gcc g++ 编译器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T11:58:07+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>GCC/G++编译器</h2>
<p>GCC是GNU项目中的一个子项目，最初为用于编译C语言的编译器。随着GNU项目的发展，GCC已经成为了能编译C、C++、Ada、Object C和Java等语言的GNU编译器家族，同时还可执&gt;行跨硬件平台的交叉编译工作。G++ 则是专门用于编译C、C++语言的编译器。C和C++语言正在不断发展，为了保持兼容程序语言的最新特性，开发者通常选择GCC来编译C语言编写的源代码，选择G++来编译C++源代码。</p>
<h2>GCC/G++编译器的安装</h2>
<p>安装或更新GCC和G++可在GNU项目的 <a href="www.gnu.org">官网- www.gnu.org </a> 下载相应的安装包，也可以使用YUM 软件包管理器安装。其安装命令如下：</p>
<pre><code>yum install make //安装make程序

yum install gcc //安装GCC编译器

yum install gcc-c++ //安装G++编译器
</code></pre>
<p>注意：如果安装过程中提示需要选择编译器版本，可根据当前硬件平台选择最新发布的版
本，如果提示需要安装其他相关软件包，请一并安装。</p>
<h2>GCC/G++编译命令</h2>
<p>GCC/G++编译器没有图形界面，只能在终端上以命令行的形式运行。编译命令由命令名、选项和源文件名组成，格式如下：</p>
<pre><code>gcc [-选项1-] [-选项2-] .... [-选项n-] &lt;源文件名&gt;

g++ [-选项1-] [-选项2-] .... [-选项n-] &lt;源文件名&gt;
</code></pre>
<p>命令名、选项和源文件名之间使用空格分隔，一行命令中可以有多个选项，也可以只有一个选项。文件名可以包含文件的绝对路径，也可以实用相对路径。如果文件名不包含路径，那么源文件被视为在于工作目录中。如果命令中不包含输出的可执行文件名称，那么默认情况下将在工作目录中生成后缀为.out的可执行文件。</p>
<h2>GCC/G++编译选项</h2>
<p>GCC拥有一百多个编译选项。对于C语言和C++语言，G++与GCC的编译选项基本相同。常用的一些编译选项如下：</p>
<pre><code>编译选项	说明
-c	只进行预处理、编译和汇编，生成.o文件
-S	只进行预处理和编译，生成.s文件
-E	只进行预处理，产生预处理后的结果到标准输出
-C	预处理时不删除注释信息，常与-E同时使用
-o	指定目标名称，常与-c、-S同时使用，默认是.out
-include file	插入一个文件，功能等同源代码中的#include
-Dmacro[=defval]	定义一个宏，功能等同源代码中的#define macro[defval]
-Umaacro	取消一个宏，功能等同源代码中的#undefine macro
-Idir	优先在选项后的目录中查找包含的头文件
-Iname	链接后缀为.out的动态链接库来编译程序
-Ldir	指定编译搜索库的路径
-g	编译器编译时加入debug信息
-pg	编译器编译时加入信息给gprof
-share	使用动态库
-static	禁止使用动态库
</code></pre>
<p>更多 GNU GCC 编译手册可查看官方文档，推荐**<a href="http://www.shanghai.ws/gnu/gcc_1.htm" target="_blank" rel="external">GNU GCC手册</a>**</p>
<h2>GCC/G++编译器的执行过程</h2>
<p>编译器的执行过程可总结为4步：预处理、编译、汇编和连接。在预处理过程中，编译器会对源代码中的头文件和预处理语句进行分析，生成以.i为后缀的预处理文件。编译过程是将输入的源代码编译为以.o为后缀的目标文件。汇编过程是针对汇编语言的步骤，在便已后成成以.o为后缀的目标文件。最后执行连接过程，所有的目标文件被安排在可执行程序中的恰当位置。同时，该陈旭所调用到的库函数也从各自所在的档案库中连到合适的地方。</p>
<hr>
<p>参考链接</p>
<blockquote>
<p><a href="http://www.cnblogs.com/banshine/p/5041584.html" target="_blank" rel="external">Linux GCC/G++编译器</a>
<a href="http://www.shanghai.ws/gnu/gcc_1.htm" target="_blank" rel="external">GNU GCC手册</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/Test/Markdown Test2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/08/Test/Markdown Test2/" itemprop="url">MarkDown 语法测试2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T10:07:49+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<h2>心心念念的Markdown</h2>
<ol>
<li>这是第一行列表项。</li>
<li>这是第二行列表项。</li>
</ol>
<p>给出一些例子代码：</p>
<pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);
</code></pre>
</blockquote>
<blockquote>
<p>This is the first level of quoting.</p>
<blockquote>
<p>This is nested blockquote.</p>
</blockquote>
<p>Back to the first level.</p>
</blockquote>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
<p>Here is an example of AppleScript:</p>
<pre><code>tell application &quot;Foo&quot;
    beep
end tell
</code></pre>
<hr>
<hr>
<hr>
<hr>
<hr>
<p>A single backtick in a code span: <code>`</code></p>
<p>A backtick-delimited string in a code span: <code>`foo`</code></p>
<p>Please don't use any <code>&lt;blink&gt;</code> tags.</p>
<p>I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank" rel="external">Google</a> than from
<a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="external">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="external">MSN</a>.</p>
<p><a href="http://example.com/" target="_blank" rel="external">http://example.com/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/Test/MarkDown Test1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/08/Test/MarkDown Test1/" itemprop="url">MarkDown 语法测试1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T10:07:49+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>MarkDown 语法测试</h1>
<hr>
<p><strong>粗体</strong></p>
<p><em>斜体</em></p>
<blockquote>
<p>引用</p>
</blockquote>
<p><code>代码块</code></p>
<h1>标题1</h1>
<h2>标题2</h2>
<p><a href="http://BaiJiazm.github.io" title="超链接" target="_blank" rel="external">超链接 http://BaiJiazm.github.io</a></p>
<ul>
<li>1</li>
<li>2</li>
<li>3</li>
</ul>
<ol>
<li>1</li>
<li>2</li>
<li>3</li>
</ol>
<hr>
<p>水平标尺</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/07/Other/命令行语法格式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/07/Other/命令行语法格式/" itemprop="url">命令行语法格式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-07T00:27:04+08:00">
                2016-10-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>各系统在描述命令行格式时各有区别，具体可参考具体文档说明，一般采用的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">命令 &lt;必选参数1|必选参数2&gt; [-option &#123;必选参数1|必选参数2|必选参数3&#125;] [可选参数...] &#123;(默认参数)|参数|参数&#125;</div></pre></td></tr></table></figure>
<p>命令格式中常用的几个符号含义如下：</p>
<p>尖括号&lt; &gt;：必选参数，使用时应将其替换为所指含义的参数</p>
<p>大括号{ }：必选参数，系统定义的参数，包含此处允许使用的参数</p>
<p>方括号[ ]：可选参数，系统定义的参数，在命令中根据需要加以取舍</p>
<p>小括号( )：指明参数的默认值，只用于{ }中</p>
<p>竖线|：用于分隔多个互斥参数，含义为“或”，使用时只能选择一个。</p>
<p>省略号...：以此类推前面，任意多个参数。</p>
<hr>
<p><strong>参考链接：</strong></p>
<ul>
<li><a href="http://man.chinaunix.net/linux/mandrake/101/zh_cn/Command-Line.html/convention.html#id2535998" target="_blank" rel="external">China Unix</a></li>
<li><a href="http://www.dewassoc.com/support/msdos/dos_commands.html" target="_blank" rel="external">MS-DOS Commands</a></li>
<li><a href="http://lavasoft.blog.51cto.com/62575/533131" target="_blank" rel="external">Linux命令格式</a></li>
<li><a href="https://support.ca.com/cadocs/0/CA%20ARCserve%20%20Backup%20r16-CHS/Bookshelf_Files/HTML/cmndline/index.htm?toc.htmcl_cmd_line_syntax_char.htm" target="_blank" rel="external">命令行语法字符</a></li>
<li><a href="http://publib.boulder.ibm.com/tividd/td/ITCM/SC23-4706-01/zh_CN/HTML/cmmcmst17.htm" target="_blank" rel="external">命令行语法</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/07/Life/从头再来/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/07/Life/从头再来/" itemprop="url">从头再来</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-07T00:18:36+08:00">
                2016-10-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><a href="http://music.163.com/song/109194/?userid=9727644" target="_blank" rel="external">《从头再来》</a></h1>
<hr>
<blockquote>
<p>演唱：刘欢
演唱：刘欢
填词：陈涛
谱曲：王晓锋
音乐风格：流行
歌曲语言：国语</p>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">昨天所有的荣誉，</div><div class="line">已变成遥远的回忆。</div><div class="line">勤勤苦苦已度过半生，</div><div class="line">今夜重又走进风雨。</div><div class="line">我不能随波浮沉，</div><div class="line">为了我致爱的亲人。</div><div class="line">再苦再难也要坚强，</div><div class="line">只为那些期待眼神。</div><div class="line">心若在梦就在，</div><div class="line">天地之间还有真爱</div><div class="line">看成败人生豪迈，</div><div class="line">只不过是从头再来</div><div class="line"></div><div class="line">昨天所有的荣誉，</div><div class="line">已变成遥远的回忆。</div><div class="line">勤勤苦苦已度过半生，</div><div class="line">今夜重又走入风雨。</div><div class="line">我不能随波浮沉，</div><div class="line">为了我致爱的亲人。</div><div class="line">再苦再难也要坚强，</div><div class="line">只为那些期待眼神。</div><div class="line">心若在梦就在，</div><div class="line">天地之间还有真爱</div><div class="line">看成败人生豪迈，</div><div class="line">只不过是从头再来</div><div class="line">心若在梦就在，</div><div class="line">天地之间还有真爱</div><div class="line">看成败人生豪迈，</div><div class="line">只不过是从头再来</div><div class="line">心若在梦就在，</div><div class="line">天地之间还有真爱</div><div class="line">看成败人生豪迈，</div><div class="line">只不过是从头再来</div><div class="line">心若在梦就在，</div><div class="line">天地之间还有真爱</div><div class="line">看成败人生豪迈，</div><div class="line">只不过是从头再来</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/headPhoto.png"
                alt="BaiJiazm" />
            
              <p class="site-author-name" itemprop="name">BaiJiazm</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">82</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/BaiJiazm" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:b110011@qq.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BaiJiazm</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
