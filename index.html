<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="BaiJiazm">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="BaiJiazm">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BaiJiazm">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>BaiJiazm</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BaiJiazm</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每一段路都是一种领悟</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/22/Linux/Linux-rpm制作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/22/Linux/Linux-rpm制作/" itemprop="url">Linux-rpm包的制作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-22T11:21:19+08:00">
                2017-10-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4>RPM相关知识准备</h4>
<hr>
<p><a href="https://fedoraproject.org/wiki/How_to_create_an_RPM_package/zh-cn#RPM_.E5.9F.BA.E7.A1.80.E7.9F.A5.E8.AF.86" target="_blank" rel="external">官方文档</a></p>
<h5>RPM 基础知识</h5>
<p>若要构建一个标准的 RPM 包，您需要创建 .spec 文件，其中包含软件打包的全部信息。然后，对此文件执行 rpmbuild 命令，经过这一步，系统会按照步骤生成最终的 RPM 包。</p>
<p>一般情况，您应该把源代码包，比如由开发者发布的以 .tar.gz 结尾的文件，放入 ~/rpmbuild/SOURCES 目录。将.spec 文件放入 ~/rpmbuild/SPECS 目录，并命名为 &quot;软件包名.spec&quot; 。当然， 软件包名 就是最终 RPM 包的名字。为了创建二进制（Binary RPM）和源码软件包（SRPM），您需要将目录切换至 ~/rpmbuild/SPECS 并执行：</p>
<pre><code> $ rpmbuild -ba NAME.spec   
</code></pre>
<p>当执行此命令时，rpmbuild 会自动读取 .spec 文件并按照下表列出的步骤完成构建。下表中，以 % 开头的语句为预定义宏，每个宏的作用如下：</p>
<p><img src="/2017/10/22/Linux/Linux-rpm制作/rpm1.jpg" alt=""></p>
<p>在 rpmbuild 中，对上表中的每个宏代码都有对应的目录：</p>
<p><img src="/2017/10/22/Linux/Linux-rpm制作/rpm2.jpg" alt=""></p>
<p>如果某一阶段失败，请查看输出信息以了解失败原因，并根据需要修改 .spec 文件。</p>
<p>做好准备打包一个特殊程序</p>
<p>如果这里有特殊的程序，它们需要被安装或者运行以便让您打包的普通程序正常工作，那么请先安装它们，然后记录下诸如软件包等相关信息。</p>
<p>不可以使用预编译代码进行打包。将源代码（通常是 .tar.gz 文件）放入 &quot;~/rpmbuild/SOURCES&quot; 目录（注意用户）。</p>
<p>仔细阅读该软件的安装说明。我们建议您先手工安装一次以了解具体情况。除少数情况外，所有二进制文件和程序库都必须由源码包中的源码编译而成。</p>
<h5>新建一个 .spec 文件</h5>
<p>现在，您需要在 ~/rpmbuild/SPECS 目录下，新建一个 SPEC 文件。文件应命名为 &quot;软件包名.spec&quot;。名称根据软件包名或通用名填写即可。但是，必须要遵守 软件包命名规定。</p>
<p>如果您首次创建 .spec 文件，vim 或 emacs 会自动生成模板：</p>
<pre><code> $ cd ~/rpmbuild/SPECS
 $ vim program.spec
</code></pre>
<p>示例（仅供参考）：</p>
<pre><code>Name:
Version:
Release:	1%{?dist}
Summary:
Group:
License:
URL:
Source0:
BuildRoot:	%{_tmppath}/%{name}-%{version}-%{release}-root-%(%{__id_u} -n)

BuildRequires:
Requires:

%description

%prep
%setup -q

%build
%configure
make %{?_smp_mflags}

%install
rm -rf %{buildroot}
make install DESTDIR=%{buildroot}

%clean
rm -rf %{buildroot}

%files
%defattr(-,root,root,-)
%doc

%changelog
</code></pre>
<p>您可以使用 $RPM_BUILD_ROOT 代替 %{buildroot}，两者都可以使用。
您也可以使用 rpmdev-newspec 命令来创建 SPEC 文件。rpmdev-newspec 软件包名 可以创建一个初始 SPEC 文件，该工具从软件包名判断使用哪个模板，支持指定模板。 /etc/rpmdevtools/spectemplate-*.spec 包含所有可用的模板，使用 rpmdev-newspec --help 命令了解更多信息。例如，为 python 模块创建 SPEC 文件：</p>
<pre><code>cd ~/rpmbuild/SPECS
rpmdev-newspec python-antigravity
vi python-antigravity.spec
</code></pre>
<h5>SPEC 文件综述</h5>
<p>您需要遵守这些规定：软件包命名规定，打包规定 和 软件包审核规定。</p>
<p>&quot;#&quot; 字符表示注释，但需要避免注释宏（以 % 开头），因为它们会首先被替换展开。使用 %% 注释宏。另外，还要避免在脚本命令的相同行中使用行内注释。</p>
<p>以下介绍了主要的标签。注意 %{name}，%{version} 和 %{release} 代表 Name, Version 和 Release 这三个标签。只要更改标签，宏就会使用新值。</p>
<p><img src="/2017/10/22/Linux/Linux-rpm制作/rpm3.jpg" alt="">
<img src="/2017/10/22/Linux/Linux-rpm制作/rpm4.jpg" alt=""></p>
<h5>SPEC 文件剖析</h5>
<ul>
<li>
<p><strong>%prep部分</strong></p>
<p>描述了解压源码包的方法。一般而言，其中包含 &quot;%autosetup&quot; 命令。另外，还可以使用 &quot;%setup&quot; 和 &quot;%patch&quot; 命令来指定操作 Source0 等标签的文件。</p>
</li>
<li>
<p><strong>%prep 部分：%autosetup 命令</strong></p>
<p>&quot;%autosetup&quot; 命令用于解压源码包。可用选项包括：<br>
-n name : 如果源码包解压后的目录名称与 RPM 名称不同，此选项用于指定正确的目录名称。例如，如果 tarball 解压目录为 FOO，则使用 &quot;%autosetup -n FOO&quot;。<br>
-c name : 如果源码包解压后包含多个目录，而不是单个目录时，此选项可以创建名为 name 的目录，并在其中解压。<br>
如果使用 &quot;%setup&quot; 命令，通常使用 -q' 抑止不必要的输出。</p>
</li>
<li>
<p><strong>%build 部分</strong></p>
<p>&quot;%build&quot; 部分有时会有点复杂；在这里你可以配置，并编译用于安装的文件。<br>
许多程序使用 GNU configure 进行配置。默认情况下，文件会安装到前缀为 &quot;/usr/local&quot; 的路径下，对于手动安装很合理。然而，打包时需要修改前缀为 &quot;/usr&quot;。共享库路径视架构而定，安装至 /usr/lib 或 /usr/lib64 目录。<br>
由于 GNU configure 很常见，可使用 &quot;%configure&quot; 宏来自动设置正确选项（例如，设置前缀为 /usr）。一般用法如下：</p>
<pre><code> %configure
 make %{?_smp_mflags}
</code></pre>
<p>若需要覆盖 makefile 变量，请将变量作为参数传递给 make：</p>
<pre><code>make %{?_smp_mflags} CFLAGS=&quot;%{optflags}&quot; BINDIR=%{_bindir}
</code></pre>
</li>
<li>
<p><strong>%install 部分</strong></p>
<p>此部分包含安装阶段需要执行的命令，即从 %{_builddir} 复制相关文件到 %{buildroot} 目录（通常表示从 ~/rpmbuild/BUILD 复制到 ~/rpmbuild/BUILDROOT) 目录，并根据需要在 %{buildroot} 中创建必要目录。</p>
<p>容易混淆的术语：<br>
&quot;build 目录&quot;，也称为 %{_builddir}，实际上与 &quot;build root&quot;，又称为 %{buildroot}，是不同的目录。在前者中进行编译，并将需要打包的文件从前者复制到后者。<br>
在 %build 阶段，当前目录为 %{buildsubdir}，是 %prep 阶段中在 %{_builddir} 下创建的子目录。这些目录通常名为 ~/rpmbuild/BUILD/%{name}-%{version}。<br>
%install 阶段的命令不会在用户安装 RPM 包时执行，此阶段仅在打包时执行。
一般，这里执行 &quot;make install&quot; 之类的命令：</p>
<pre><code>%install
rm -rf %{buildroot} # 仅用于 RHEL 5
%make_install
</code></pre>
<p>理想情况下，对于支持的程序，你应该使用 %make_install，它等同于 DESTDIR=%{buildroot}，它会将文件安装到 %{buildroot} 目录中。</p>
</li>
</ul>
<h5>Scriptlets</h5>
<p>当用户安装 RPM 时，您可能想要执行一些命令。这可以通过 scriptlets 完成。请查看 Packaging/ScriptletSnippets。</p>
<p>脚本片段可以：</p>
<ul>
<li>在软体包安装之前 (%pre) 或之后 (%post) 执行</li>
<li>在软体包卸载之前 (%preun) 或之后 (%postun) 执行</li>
<li>在事务开始 (%pretrans) 或结束 (%posttrans) 时执行</li>
</ul>
<hr>
<h4>test-1453381.rpm包的制作过程</h4>
<hr>
<ol>
<li>
<p>开始前的准备</p>
<p>安装rpmbuild软件包</p>
<pre><code>yum -y install rpm-build
</code></pre>
<p>Linux RedHat 7.4已经安装了。</p>
</li>
<li>
<p>生成相关目录</p>
<pre><code>mkdir -p $(rpmDir)/SOURCES $(rpmDir)/SPECS $(rpmDir)/BUILD $(rpmDir)/RPMS $(rpmDir)/SRPMS
</code></pre>
<p>目录结构如下：</p>
<pre><code>rpmbuild/
├── BUILD
├── BUILDROOT
├── RPMS
├── SOURCES
├── SPECS
└── SRPMS
</code></pre>
</li>
<li>
<p>编写.spec文件</p>
<pre><code>Name:	test-1453381
Version:	1.0
Release:	1%{?dist}
Summary:	test-rpm

Group:		none
License:	none
URL:		none
Source0:	test-1453381-1.0.tar.gz

%description
test-1453381-rpm

%prep
%setup -q 

%pre
echo &quot;准备安装test-1453381&quot;

%post
echo &quot;完成安装test-1453381&quot;

%build
make

%install
make install DESTDIR=%{buildroot}

%preun
echo &quot;准备卸载test-1453381&quot;

%postun
cd %{_builddir}/%{name}-%{version}/
make uninstall 
echo &quot;完成卸载test-1453381&quot;

%files
%doc

%changelog
</code></pre>
</li>
<li>
<p>拷贝相关文件到指定目录</p>
<pre><code>mkdir $(releaseName)
cp $(rpmSrcFile) $(releaseName)/
tar -zcvf $(rpmDir)/SOURCES/$(rpmGz) $(releaseName)
rm -rf $(releaseName)
cp $(rpmSpec) $(rpmDir)/SPECS
</code></pre>
</li>
<li>
<p>生成rpm包</p>
<pre><code>rpmbuild -bb $(rpmDir)/SPECS/$(rpmSpec)
cp $(rpmDir)/RPMS/x86_64/$(releaseName)-1.el7.x86_64.rpm $(binFinal).rpm
</code></pre>
</li>
<li>
<p>测试</p>
<p><img src="/2017/10/22/Linux/Linux-rpm制作/rpmp1.jpg" alt=""></p>
<p><img src="/2017/10/22/Linux/Linux-rpm制作/rpmp2.jpg" alt=""></p>
</li>
</ol>
<p>可供参考：<a href="http://www.cnblogs.com/postgres/p/5726339.html" target="_blank" rel="external">链接</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/22/Linux/Linux-service自定义/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/22/Linux/Linux-service自定义/" itemprop="url">Linux-service自定义</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-22T11:20:37+08:00">
                2017-10-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h5>制作service的基本知识</h5>
<ol>
<li>
<p><strong>服务权限</strong></p>
<p>systemd有系统和用户区分；系统（<code>/user/lib/systemd/system/</code>）、用户（<code>/etc/lib/systemd/user/</code>）.一般系统管理员手工创建的单元文件建议存放在<code>/etc/systemd/system/</code>目录下面。</p>
</li>
<li>
<p><strong>创建服务文件</strong></p>
<p><strong>[Unit]</strong><br>
<strong>Description</strong> : 服务的简单描述<br>
<strong>Documentation</strong> ： 服务文档<br>
<strong>Before、After</strong> :定义启动顺序。Before=xxx.service,代表本服务在xxx.service启动之前启动。After=xxx.service,代表本服务在xxx.service之后启动。<br>
<strong>Requires</strong>：这个单元启动了，它需要的单元也会被启动；它需要的单元被停止了，这个单元也停止了。<br>
<strong>Wants</strong>：这个单元启动了，它需要的单元也会被启动；它需要的单元被停止了，对本单元没有影响。</p>
<p><strong>[Service]</strong><br>
<strong>Type=simple（默认值）</strong>：systemd认为该服务将立即启动。服务进程不会fork。如果该服务要启动其他服务，不要使用此类型启动，除非该服务是socket激活型。<br>
<strong>Type=forking</strong>：systemd认为当该服务进程fork，且父进程退出后服务启动成功。对于常规的守护进程（daemon），除非你确定此启动方式无法满足需求，使用此类型启动即可。使用此启动类型应同时指定 PIDFile=，以便systemd能够跟踪服务的主进程。<br>
<strong>Type=oneshot</strong>：这一选项适用于只执行一项任务、随后立即退出的服务。可能需要同时设置 RemainAfterExit=yes 使得 systemd 在服务进程退出之后仍然认为服务处于激活状态。<br>
<strong>Type=notify</strong>：与 Type=simple 相同，但约定服务会在就绪后向 systemd 发送一个信号。这一通知的实现由 libsystemd-daemon.so 提供。<br>
<strong>Type=dbus</strong>：若以此方式启动，当指定的 BusName 出现在DBus系统总线上时，systemd认为服务就绪。<br>
<strong>Type=idle</strong>: systemd会等待所有任务(Jobs)处理完成后，才开始执行idle类型的单元。除此之外，其他行为和Type=simple 类似。<br>
<strong>PIDFile</strong>：pid文件路径<br>
<strong>ExecStart</strong>：指定启动单元的命令或者脚本，ExecStartPre和ExecStartPost节指定在ExecStart之前或者之后用户自定义执行的脚本。Type=oneshot允许指定多个希望顺序执行的用户自定义命令。<br>
<strong>ExecReload</strong>：指定单元停止时执行的命令或者脚本。<br>
<strong>ExecStop</strong>：指定单元停止时执行的命令或者脚本。<br>
<strong>PrivateTmp</strong>：True表示给服务分配独立的临时空间<br>
<strong>Restart</strong>：这个选项如果被允许，服务重启的时候进程会退出，会通过systemctl命令执行清除并重启的操作。<br>
<strong>RemainAfterExit</strong>：如果设置这个选择为真，服务会被认为是在激活状态，即使所以的进程已经退出，默认的值为假，这个选项只有在Type=oneshot时需要被配置。</p>
<p><strong>[Install]</strong><br>
<strong>Alias</strong>：为单元提供一个空间分离的附加名字。<br>
<strong>RequiredBy</strong>：单元被允许运行需要的一系列依赖单元，RequiredBy列表从Require获得依赖信息。<br>
<strong>WantBy</strong>：单元被允许运行需要的弱依赖性单元，Wantby从Want列表获得依赖信息。<br>
<strong>Also</strong>：指出和单元一起安装或者被协助的单元。<br>
<strong>DefaultInstance</strong>：实例单元的限制，这个选项指定如果单元被允许运行默认的实例。</p>
</li>
</ol>
<hr>
<h5>Linux test-1453381.service实际制作</h5>
<ol>
<li>
<p>编写service文件</p>
<p>test-1453381.service</p>
<pre><code># cp test-1453381.service /etc/systemd/system/

[Unit]
Description=test-1453381

[Service]
Type=forking
#下面这行对于此次的test.service需要注释掉
#PIDFile=/usr/local/test-1453381.pid
ExecStart=/usr/sbin/test-1453381 &amp;
ExecReload=/bin/kill -s HUP $MAINPID
ExecStop=/bin/kill -s QUIT $MAINPID

[Install]
WantedBy=multi-user.target
</code></pre>
<p>为避免<code>systemctl start</code> 时遇到<code>Warning: test-1453381.service changed on disk. Run 'systemctl daemon-reload' to reload units.</code>,可在start前先执行 <code>systemctl enable teset.service</code> 。</p>
</li>
<li>
<p>拷贝编写好的service文件至特定目录</p>
<pre><code>cp test-1453381.service /etc/systemd/system/
</code></pre>
</li>
<li>
<p>测试</p>
<p><img src="/2017/10/22/Linux/Linux-service自定义/1.jpg" alt=""></p>
</li>
</ol>
<p>参考链接：</p>
<ul>
<li><a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html#" target="_blank" rel="external">参考1</a></li>
<li><a href="https://wiki.archlinux.org/index.php/systemd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="external">参考2</a></li>
<li><a href="http://blog.chinaunix.net/uid-26790551-id-3189115.html" target="_blank" rel="external">参考3</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/18/Linux/Linux守护进程4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/18/Linux/Linux守护进程4/" itemprop="url">Linux守护进程4</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-18T19:44:25+08:00">
                2017-10-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4>Linux守护进程4 -- 杀掉守护进程及其子进程</h4>
<hr>
<ul>
<li>
<p><strong>在04 子目录下写test4-1.c，循环10 次，每隔3 秒产生一个子进程，循环完成后，自己进入
死循环操作，每5 秒打印&quot;父进程号+自己的进程号+你的学号+main&quot;信息即可；分裂出的子进
程进入死循环操作，要求每15 秒打印&quot;父进程号+自己的进程号+你的学号+sub&quot;；写配套的
makefile 文件，make 后可生成test4-1 可执行文件</strong></p>
<pre><code>//test4-1.c

#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/wait.h&gt;

#define FORK_NUM 10
#define FORK_SLEEP_TIME 3
#define MAIN_SLEEP_TIME 5
#define SUB_SLEEP_TIME 15

int daemon_init(void){
    pid_t pid;
    if ((pid = fork()) &lt; 0)
		return -1;
	else if (pid)   
		exit(0);	/* parent exit */

	/* child continues */
	setsid();	/* become session leader */
    chdir(&quot;/&quot;);	/* change working directory */
	umask(0);	/* clear file mode creation mask */
	close(0);    /* close stdin stdout stderr */
//	close(1);
	close(2);
	return 0;
}

int main(){
	if (daemon_init() == -1){
		printf(&quot;can't fork self\n&quot;);
		exit(0);
	}
	
	pid_t pid;
	int i;
	for (i=0; i&lt;FORK_NUM; ++i)
		if ((pid=fork()) &lt; 0){
			perror(&quot;fork error&quot;);
			exit(errno);
		}
		else if(pid==0)
			//子进程退出
			break;
		else 
			//父进程间隔3s
			sleep(FORK_SLEEP_TIME);	
	
	if(pid){	//父进程
		while(1){
			printf(&quot;%d %d 1453381 main\n&quot;, getppid(), getpid());
			sleep(MAIN_SLEEP_TIME);
		}
	}
	else{		//子进程
		while(1){
			printf(&quot;%d %d 1453381 sub\n&quot;, getppid(), getpid());
			sleep(SUB_SLEEP_TIME);
		}
	}
	
	return 0;
}
</code></pre>
<p>makefile :</p>
<pre><code>CC ?= gcc
CFLAGS =

srcNames :=test4-1 test4-2

all :
	@for src in $(srcNames) ; \
	do \
		$(CC) $(CFLAGS) -o $$src &quot;$$src&quot;.c ; \
	done

clean :
	rm -f *.o $(srcNames)

.PHONY : all clean
</code></pre>
<p>测试截图：</p>
<p><img src="/2017/10/18/Linux/Linux守护进程4/0.jpg" alt=""></p>
</li>
<li>
<p><strong>如何杀死test4-1 分裂出来的一个子进程？</strong></p>
<pre><code>kill -9 pid
</code></pre>
</li>
<li>
<p><strong>如何快速杀死test4-1 分裂出来的全部子进程？</strong></p>
<pre><code>ps -ef |grep test4-1 |grep -v grep|cut -c 9-15|xargs kill -9

# 批量杀死包含关键字&quot;test4-1&quot;的进程
# &quot;ps -ef&quot; ——查看所有进程
# &quot;grep test4-1&quot; ——列出所有含有关键字&quot;test4-1&quot;的进程
# &quot;grep -v grep&quot; ——在列出的进程中去除含有关键字&quot;grep&quot;的进程
# &quot;cut -c 9-15&quot; ——截取输入行的第9个字符到第15个字符，而这正好是进程号PID
# &quot;xargs kill -9&quot; ——xargs 命令是用来把前面命令的输出结果（PID）作为&quot;kill -9&quot;
  命令的参数，并执行该命令。&quot;kill -9&quot;会强行杀掉指定进程。
</code></pre>
<p>测试截图：</p>
<p><img src="/2017/10/18/Linux/Linux守护进程4/1.jpg" alt=""></p>
</li>
<li>
<p><strong>如果杀死test4-1，其子进程会发生哪些变化？</strong></p>
<p>子进程成为孤儿进程，被 pid=1 （RedHat7.4下名为systemd） 的进程收留，ppid成为1。</p>
<p>测试截图：</p>
<p><img src="/2017/10/18/Linux/Linux守护进程4/2.jpg" alt=""></p>
</li>
<li>
<p><strong>写test4-2.c，要求与test4-1 相同，但是要求杀死test4-2 后，它的全部子进程自动退出</strong></p>
<p>可以在父进程终止退出前，调用kill函数，kill函数相关用法如下:</p>
<pre><code>#include &lt;sys/types.h&gt; 
#include &lt;signal.h&gt;

int kill(pid_t pid, int sig);

作用：用于向任何进程组或进程发送信号。

参数： 
pid：可能选择有以下四种
1. pid大于零时，pid是信号欲送往的进程的标识。
2. pid等于零时，信号将送往所有与调用kill()的那个进程属同一个使用组的进程。
3. pid等于-1时，信号将送往所有调用进程有权给其发送信号的进程，除了进程1(init)。
4. pid小于-1时，信号将送往以-pid为组标识的进程。
</code></pre>
<p>需要在main函数中第一行添加<code>signal(SIGTERM, kill_child);</code>意在父进程退出时进入kill_child函数进行处理，kill_child函数如下：</p>
<pre><code>void kill_child(int sig){
	kill(0, SIGKILL);
	int status;
	while(waitpid(-1, &amp;status, WNOHANG)&gt;0)
		;
	exit(0);
}
</code></pre>
<p>test4-2.c最终代码如下：</p>
<pre><code>//test4-2.c

#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/wait.h&gt;

#define FORK_NUM 10
#define FORK_SLEEP_TIME 3
#define MAIN_SLEEP_TIME 5
#define SUB_SLEEP_TIME 15

int daemon_init(void){
    pid_t pid;
    if ((pid = fork()) &lt; 0)
		return -1;
	else if (pid)   
		exit(0);	/* parent exit */

	/* child continues */
	setsid();	/* become session leader */
    chdir(&quot;/&quot;);	/* change working directory */
	umask(0);	/* clear file mode creation mask */
	close(0);    /* close stdin stdout stderr */
//	close(1);
	close(2);
	return 0;
}

void kill_child(int sig){
	kill(0, SIGKILL);
	int status;
	while(waitpid(-1, &amp;status, WNOHANG)&gt;0)
		;
	exit(0);
}

int main(){
	if (daemon_init() == -1){
		printf(&quot;can't fork self\n&quot;);
		exit(0);
	}

	signal(SIGTERM, kill_child);

	pid_t pid;
	int i;
	for (i=0; i&lt;FORK_NUM; ++i)
		if ((pid=fork()) &lt; 0){
			perror(&quot;fork error&quot;);
			exit(errno);
		}
		else if(pid==0)
			//子进程退出
			break;
		else 
			//父进程间隔3s
			sleep(FORK_SLEEP_TIME);	
	
	pid_t selfid=getpid();
	pid_t faid=getppid();
	
	if(pid){	//父进程
		while(1){
			printf(&quot;%d %d 1453381 main\n&quot;, faid, selfid);
			sleep(MAIN_SLEEP_TIME);
		}
	}
	else{		//子进程
		while(1){
			printf(&quot;%d %d 1453381 sub\n&quot;, faid, selfid);
			sleep(SUB_SLEEP_TIME);
		}
	}
	
	return 0;
}
</code></pre>
<p>最后需要说明的是，杀掉父进程时，需要用<code>kill -15 pid</code>结束，此时定义在main函数中的<code>signal(SIGTERM, kill_child)</code>才会生效，如果用<code>kill -9 pid</code>结束父进程，分裂的子进程父进程变为1，成为孤儿进程。</p>
<p>测试截图：</p>
<p><img src="/2017/10/18/Linux/Linux守护进程4/3.jpg" alt=""></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/18/Linux/Linux守护进程2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/18/Linux/Linux守护进程2/" itemprop="url">Linux守护进程2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-18T19:44:25+08:00">
                2017-10-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4>Linux守护进程2——守护进程的作用、用途、父进程标识的特点</h4>
<hr>
<ul>
<li>
<p><strong>在02 子目录下写test2.c，写配套的makefile 文件，make 后可生成test2 可执行文件</strong></p>
<p>基本概念如下：<br>
<strong>进程组 ：</strong><br>
每个进程属于一个进程组<br>
每个进程都有一个进程组号，该号等于该进程组组长的PID号<br>
一个进程只能为它自己或子进程设置进程组ID号</p>
<p><strong>会话期：</strong><br>
会话期(session)是一个或多个进程组的集合<br>
setsid()函数可以建立一个对话期。如果调用setsid的进程不是一个进程组的组长，此函数创建一个新的会话期：<br>
(1)此进程变成该对话期的首进程<br>
(2)此进程变成一个新进程组的组长进程。<br>
(3)此进程没有控制终端，如果在调用setsid前，该进程有控制终端，那么与该终端的联系被解除。 如果该进程是一个进程组的组长，此函数返回错误。<br>
(4)为了保证这一点，我们先调用fork()然后exit()，此时只有子进程在运行</p>
<p><strong>编写守护进程的一般步骤步骤：</strong><br>
（1）在父进程中执行fork并exit推出；<br>
（2）在子进程中调用setsid函数创建新的会话；<br>
（3）在子进程中调用chdir函数，让根目录 ”/” 成为子进程的工作目录；<br>
（4）在子进程中调用umask函数，设置进程的umask为0；<br>
（5）在子进程中关闭任何不需要的文件描述符</p>
<pre><code>//test2.c
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;syslog.h&gt;
#include &lt;signal.h&gt;

int daemon_init(void){
    pid_t pid;
    if ((pid = fork()) &lt; 0)
		return -1;
	else if (pid)   
		exit(0);	/* parent exit */

	/* child continues */
	/* become session leader */
	setsid();
	/* change working directory */
    chdir(&quot;\n&quot;);
	/* clear file mode creation mask */
	umask(0);
    /* close stdin stdout stderr */
	close(0);
	close(1);
	close(2);

	return 0;
}       

void sig_term(int signo){
	if(signo==SIGTERM){
		syslog(LOG_INFO, &quot;program terminated&quot;);
		closelog();
		exit(0);
	}
}

#define SLEEP_TIME 5

int main(){
	
	if (daemon_init() == -1){
		printf(&quot;can't fork self\n&quot;);
		exit(0);
	}

	//以下三行不是必须的，仅提供log信息
	openlog(&quot;daemontest&quot;, LOG_PID, LOG_USER);
	syslog(LOG_INFO, &quot;program started&quot;);
	signal(SIGTERM, sig_term);

	while(1){
		printf(&quot;1453381\n&quot;);
		sleep(SLEEP_TIME);
	}
	
	return 0;
}
</code></pre>
<p>makefile :</p>
<pre><code>CC=gcc
CFLAGS=

BIN=test2
SRC=$(wildcard *.c)
OBJ=$(SRC:.c=.o)

$(BIN):$(OBJ)
	$(CC) $(OBJ) -o $(BIN)

.PHONY :clean
clean:
	rm -f $(BIN) $(OBJ)
</code></pre>
<p>说明：</p>
<ol>
<li>在后台运行
为避免挂起控制终端将Daemon放入后台执行。方法是在进程中调用fork使父进程终止，让Daemo在子
进程中后台执行。
if(pid=fork())
exit(0);//是父进程，结束父进程，子进程继续</li>
<li>脱离控制终端，登录会话和进程组
登录会话和进程组之间的关系：进程属于一个进程组，进程组号（GID）就是进程组长的进程号（PID
）。登录会话可以包含多个进程组。这些进程组共享一个控制终端。这个控制终端通常是创建进程的
登录终端。 控制终端，登录会话和进程组通常是从父进程继承下来的。我们的目的就是要摆脱它们，
使之不受它们的影响。方法是在第1点的基础上，调用setsid()使进程成为会话组长：
setsid();
说明：当进程是会话组长时setsid()调用失败。但第一点已经保证进程不是会话组长。setsid()调
用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。由于会话过
程对控制终端的独占性，进程同时与控制终端脱离。</li>
<li>禁止进程重新打开控制终端
现在，进程已经成为无终端的会话组长。但它可以重新申请打开一个控制终端。可以通过使进程不再
成为会话组长来禁止进程重新打开控制终端：
if(pid=fork())
exit(0);//结束第一子进程，第二子进程继续（第二子进程不再是会话组长）</li>
<li>关闭打开的文件描述符
进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在
的文件系统无法卸下以及引起无法预料的错误。</li>
<li>改变当前工作目录
进程活动时，其工作目录所在的文件系统不能卸下。一般需要将工作目录改变到根目录。对于需要转
储核心，写运行日志的进程将工作目录改变到特定目录如/tmpchdir(&quot;/&quot;)</li>
<li>重设文件创建掩模
进程从创建它的父进程那里继承了文件创建掩模。它可能修改守护进程所创建的文件的存取位。为防
止这一点，将文件创建掩模清除：umask(0);</li>
</ol>
</li>
<li>
<p><strong>用./test2 运行后直接成为守护进程</strong></p>
</li>
<li>
<p><strong>test2 的进程标识、父进程标识是谁？如何查看？</strong></p>
<p>进程 test2 的 ppid 为1，在 RedHat7.4 下为 systemd</p>
<pre><code>ps -ef |grep test2
pstree 1
ps -ef |grep -E &quot;test2|systemd&quot;
</code></pre>
<p>测试截图：</p>
<p><img src="/2017/10/18/Linux/Linux守护进程2/1.jpg" alt="">
<img src="/2017/10/18/Linux/Linux守护进程2/2.jpg" alt=""></p>
</li>
<li>
<p><strong>在另一个控制台中能否查看到test2 进程的相关信息？</strong></p>
<p>能，完全一样。<br>
测试截图：</p>
<p><img src="/2017/10/18/Linux/Linux守护进程2/3.jpg" alt=""></p>
</li>
<li>
<p><strong>当test2 在后台运行时，如果CTRL+D 退出控制台登录，test2 会怎样？</strong></p>
<p>test2 是守护进程，即使 [CTRL] + D 退出登录，只要操作系统保持运行，则 test2 会保持运行。</p>
</li>
<li>
<p><strong>再次登录控制台后，test2 是否仍在运行？此时打印信息能否继续出现在新登录的终端上？</strong></p>
<p>再次登陆，test2 仍在运行，打印信息不能出现在终端，原因上个题目已说。</p>
</li>
<li>
<p><strong>引申问题：如果想在进程中打印信息并保证始终能被查看到，应该如何做？</strong></p>
<p>守护进程没有控制终端进行信息的输出，而有些情况还需要根据进程提供的信息进行系统管理和维护工作。因此Linux提供了syslogd守护进程，专门用于接受其他守护进程提供的信息记录在指定位置来解决日志记录的问题。</p>
<p>在 RedHat7.4 中没有syslogd，但是有rsyslogd守护进程，rsyslog的配置文件是<code>/etc/rsyslog.conf</code></p>
<p>下面说明一下相关syslog函数：</p>
<pre><code>// 函数说明
#include &lt;syslog.h&gt;
vodi openlog(const char *ident, int option, int facility);
void syslog(int priority, const char *format, ...);
void closelog(void);

openlog函数原型如下：
1）void openlog(const char* ident, int option, int facility);
        //打开系统日志链接，必须步骤。
ident   :信息来源，哪个可执行程序
option  :控制标志的参数，多个可以同时使用，用|操作合并
facility:指定消息类型，与配置文件对应，日志会写入配置文件指定位置。

2）void syslog(int priority,const char* format,....);
priority：消息级别，与openlog中的facility可以共同决定日志写入位置。
format  ：消息格式，再后面为格式对应的参数，类似printf的使用
 
3）void closelog();
关闭系统日志链接，可选步骤。
</code></pre>
<p>在原来的程序中打印学号的地方添加一行：</p>
<pre><code>syslog(LOG_INFO, &quot;1453381\n&quot;);
</code></pre>
<p>执行后，查看新增信息</p>
<pre><code>tail -f /var/log/messages
</code></pre>
<p>测试截图：</p>
<p><img src="/2017/10/18/Linux/Linux守护进程2/4.jpg" alt=""></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/18/Linux/Linux守护进程3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/18/Linux/Linux守护进程3/" itemprop="url">Linux守护进程3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-18T19:44:25+08:00">
                2017-10-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4>Linux守护进程3 —— 守护进程分裂子进程</h4>
<hr>
<ul>
<li>
<p><strong>在03 子目录下写test3-1.c，循环10 次，每隔3 秒产生一个子进程，循环完成后，自己进入
死循环操作，每5 秒打印&quot;父进程号+自己的进程号+你的学号+main&quot;信息即可；分裂出的子进
程要求每25 秒打印&quot;父进程号+自己的进程号+你的学号+sub&quot;，打印三次后子进程退出；写配
套的makefile 文件，make 后可生成test3-1 可执行文件</strong></p>
<pre><code>//test3-1.c

#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/wait.h&gt;

#define FORK_NUM 10
#define SUB_NUM 3
#define MAIN_SLEEP_TIME 5
#define SUB_SLEEP_TIME 25

int daemon_init(void){
    pid_t pid;
    if ((pid = fork()) &lt; 0)
		return -1;
	else if (pid)   
		exit(0);	/* parent exit */

	/* child continues */
	setsid();	/* become session leader */
    chdir(&quot;/&quot;);	/* change working directory */
	umask(0);	/* clear file mode creation mask */
	close(0);    /* close stdin stdout stderr */
//	close(1);
	close(2);
	return 0;
}

int main(){
	if (daemon_init() == -1){
		printf(&quot;can't fork self\n&quot;);
		exit(0);
	}

	pid_t pid;
	int i;
	for (i=0; i&lt;FORK_NUM; ++i)
		if ((pid=fork()) &lt; 0){
			perror(&quot;fork error&quot;);
			exit(errno);
		}
		else if(pid==0)
			break;
	
	if(pid){
		while(1){
			printf(&quot;%5d %5d 1453381 main\n&quot;, getppid(), getpid());
			sleep(MAIN_SLEEP_TIME);
		}
	}
	else{
		for (i=1; i&lt;=SUB_NUM; ++i){
			printf(&quot;%5d %5d 1453381 sub\n&quot;, getppid(), getpid());
			sleep(SUB_SLEEP_TIME);
		}
	}
	
	return 0;
}
</code></pre>
<p>测试截图：</p>
<p><img src="/2017/10/18/Linux/Linux守护进程3/1.jpg" alt=""></p>
</li>
<li>
<p><strong>分裂出的子进程和守护进程之间的进程id 有何关联？</strong></p>
<p>子进程的ppid为父进程的pid。</p>
<p>测试截图：</p>
<p><img src="/2017/10/18/Linux/Linux守护进程3/2.jpg" alt=""></p>
</li>
<li>
<p><strong>什么叫僵尸进程？僵尸进程的产生原因？</strong></p>
<p><strong>僵尸进程：</strong> 一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</p>
<p><strong>原因：</strong> 在Linux进程的状态中，僵尸进程是非常特殊的一种，它需要它的父进程来为它收尸，如果他的父进程没安装SIGCHLD信号处理函数调用wait或waitpid（）等待子进程结束，又没有显式忽略该信号，那么它就一直保持僵尸状态，如果这时父进程结束了，那么init进程自动会接手这个子进程，为它收尸，它还是能被清除的。但是如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是为什么系统中有时会有很多的僵尸进程。</p>
</li>
<li>
<p><strong>如何杀死僵尸进程？</strong></p>
<p>一般杀掉进程可用 <code>kill -9 pid</code>命令，但是有些僵尸进程通过此命令不行。可以通过杀掉父进程结束。</p>
<p>测试截图：</p>
<p><img src="/2017/10/18/Linux/Linux守护进程3/3.jpg" alt=""></p>
</li>
<li>
<p><strong>写test3-2.c，要求同test3-1，但是子进程退出后不能存在僵尸进程</strong></p>
<p><strong>僵尸进程解决办法</strong></p>
<p>（1）通过信号机制<br>
子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。</p>
<pre><code>//test3-2.c 新增函数
void sig_child(int signo){
	int status;
	pid_t pid;
	while((pid=waitpid(-1, &amp;status, WNOHANG))&gt;0)
		;
}

//在main函数第一行添加
signal(SIGCHLD, sig_child);
</code></pre>
<p>在Linux下 可以简单地将 SIGCHLD信号的操作设为SIG_IGN。</p>
<pre><code>signal(SIGCHLD,SIG_IGN);
</code></pre>
<p>（2）fork两次<br>
原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。</p>
<p>基于第一种方法实现：</p>
<pre><code>//test3-2.c

#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/wait.h&gt;

#define FORK_NUM 10
#define SUB_NUM 3
#define MAIN_SLEEP_TIME 5
#define SUB_SLEEP_TIME 25

int daemon_init(void){
    pid_t pid;
    if ((pid = fork()) &lt; 0)
		return -1;
	else if (pid)   
		exit(0);	/* parent exit */

	/* child continues */
	setsid();	/* become session leader */
    chdir(&quot;/&quot;);	/* change working directory */
	umask(0);	/* clear file mode creation mask */
	close(0);    /* close stdin stdout stderr */
//	close(1);
	close(2);
	return 0;
}

void sig_child(int signo){
	int status;
	pid_t pid;
	while((pid=waitpid(-1, &amp;status, WNOHANG))&gt;0)
		;
}

int main(){
	if (daemon_init() == -1){
		printf(&quot;can't fork self\n&quot;);
		exit(0);
	}
	
	signal(SIGCHLD, sig_child);

	pid_t pid;
	int i;
	
	for (i=0; i&lt;FORK_NUM; ++i)
		if ((pid=fork()) &lt; 0){
			perror(&quot;fork error&quot;);
			exit(errno);
		}
		else if(pid==0)
			break;
	
	if(pid){
		while(1){
			printf(&quot;%5d %5d 1453381 main\n&quot;, getppid(), getpid());
			sleep(MAIN_SLEEP_TIME);
		}
	}
	else{
		for (i=1; i&lt;=SUB_NUM; ++i){
			printf(&quot;%5d %5d 1453381 sub\n&quot;, getppid(), getpid());
			sleep(SUB_SLEEP_TIME);
		}
	}
	
	return 0;
}
</code></pre>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/18/Linux/Linux守护进程0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/18/Linux/Linux守护进程0/" itemprop="url">Linux守护进程0</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-18T19:44:25+08:00">
                2017-10-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>signal函数</p>
<pre><code>#include &lt;signal.h&gt;

typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);

作用1：站在应用程序的角度，注册一个信号处理函数
作用2：忽略信号，设置信号默认处理 信号的安装和回复

参数
--  signal是一个带signum和handler两个参数的函数，准备捕捉或屏蔽的信号由参数signum
    给出，接收到指定信号时将要调用的函数有handler给出
--  handler这个函数必须有一个int类型的参数（即接收到的信号代码），它本身的类型是void
--  handler也可以是下面两个特殊值：① SIG_IGN 屏蔽该信号  ② SIG_DFL 恢复默认行为

SIGABRT        进程停止运行    6
SIGALRM        警告钟    
SIGFPE        算述运算例外
SIGHUP        系统挂断
SIGILL        非法指令
SIGINT        终端中断   2
SIGKILL        停止进程（此信号不能被忽略或捕获）
SIGPIPE        向没有读的管道写入数据
SIGSEGV        无效内存段访问
SIGQOUT        终端退出    3
SIGTERM        终止
SIGUSR1        用户定义信号1
SIGUSR2        用户定义信号2
SIGCHLD        子进程已经停止或退出
SIGCONT        如果被停止则继续执行
SIGSTOP        停止执行
SIGTSTP        终端停止信号
SIGTOUT        后台进程请求进行写操作
SIGTTIN        后台进程请求进行读操作
</code></pre>
<p>kill函数</p>
<pre><code>#include &lt;sys/types.h&gt; 
#include &lt;signal.h&gt;

int kill(pid_t pid, int sig);

作用：用于向任何进程组或进程发送信号。

参数： 
pid：可能选择有以下四种
1. pid大于零时，pid是信号欲送往的进程的标识。
2. pid等于零时，信号将送往所有与调用kill()的那个进程属同一个使用组的进程。
3. pid等于-1时，信号将送往所有调用进程有权给其发送信号的进程，除了进程1(init)。
4. pid小于-1时，信号将送往以-pid为组标识的进程。

sig：准备发送的信号代码，假如其值为零则没有任何信号送出，但是系统会执行错误检查，通常
会利用sig值为零来检验某个进程是否仍在执行。

返回值说明： 成功执行时，返回0。失败返回-1，errno被设为以下的某个值
EINVAL：指定的信号码无效（参数 sig 不合法） 
EPERM；权限不够无法传送信号给指定进程 
ESRCH：参数 pid 所指定的进程或进程组不存在
</code></pre>
<p>wait和waitpid函数</p>
<pre><code>#include &lt;sys/types.h&gt;   
#include &lt;sys/wait.h&gt;  

pid_t waitpid(pid_t pid,int *status,int options);  

1）wait()函数用于使父进程（也就是调用wait()的进程）阻塞，直到一个子进程结束或者该进程
接收到了一个指定的信号为止。如果该父进程没有子进程或者它的子进程已经结束，则wait()函数
就会立即返回。
2) waitpid()的作用和wait()一样，但它并不一定要等待第一个终止的子进程（它可以指定需要
等待终止的子进程），它还有若干选项，如可提供一个非阻塞版本的 wait()功能，也能支持作业
控制。实际上，wait()函数只是 waitpid()函数的一个特例，在Linux 内部实现 wait()函数
时直接调用的就是waitpid()函数。

1）pid_t pid
参数pid为欲等待的子进程识别码，其具体含义如下：
参数值	说明
pid&lt;-1	等待进程组号为pid绝对值的任何子进程。
pid=-1	等待任何子进程，此时的waitpid()函数就退化成了普通的wait()函数。
pid=0	等待进程组号与目前进程相同的任何子进程，也就是说任何和调用waitpid()函数的进
        程在同一个进程组的进程。
pid&gt;0	等待进程号为pid的子进程。 

2）int *status
这个参数将保存子进程的状态信息，有了这个信息父进程就可以了解子进程为什么会推出，是正常
退出还是出了什么错误。也可以传入空指针。

3）int options
参数options提供了一些另外的选项来控制waitpid()函数的行为。如果不想使用这些选项，则可
以把这个参数设为0。
主要使用的有以下两个选项：
参数	说明
WNOHANG	    如果pid指定的子进程没有结束，则waitpid()函数立即返回0，而不是阻塞在这
            个函数上等待；如果结束了，则返回该子进程的进程号。
WUNTRACED	如果子进程进入暂停状态，则马上返回。</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/18/Linux/Linux守护进程1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/18/Linux/Linux守护进程1/" itemprop="url">Linux守护进程1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-18T19:44:25+08:00">
                2017-10-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4>Linux守护进程1——程序前后台切换</h4>
<hr>
<ul>
<li>
<p><strong>写test1-1.c/test1-2.c 两个程序，都是死循环操作，每5 秒打印一句话，写配套的makefile 文件，make 后可生成test1-1和test1-2 两个可执行文件</strong></p>
<pre><code>//test1-1.c
#include&lt;stdio.h&gt;
#include&lt;unistd.h&gt;

#define SLEEP_TIME 5

int main(){
        while(1){
                printf(&quot;1453381\n&quot;);
                sleep(SLEEP_TIME);
        }
        return 0;
}

//test1-2.c

#include&lt;stdio.h&gt;
#include&lt;unistd.h&gt;

#define SLEEP_TIME 5

int main(){
        while(1){
                printf(&quot;曾鸣\n&quot;);
                sleep(SLEEP_TIME);
        }
        return 0;
}
</code></pre>
<p>makefile ：</p>
<pre><code>cc ?= gcc

srcNames :=test1-1 test1-2

all :
	@for src in $(srcNames) ; \
	do \
		$(cc) -o $$src &quot;$$src&quot;.c ; \
	done

clean :
	rm -f *.o $(srcNames)

.PHONY : all clean
</code></pre>
</li>
<li>
<p><strong>用SecureCRT登录系统（简称控制台），然后./test1-1 运行test1-1 程序，控制台进入死循环，不再出现#或$提示符</strong></p>
</li>
<li>
<p><strong>如何将test1-1 放入后台运行？</strong></p>
<p>程序运行时在终端按下 [Ctrl] + z，使工作转入后台，但此时工作停止，需要使用 bg 来使之运行。</p>
</li>
<li>
<p><strong>如何查看在后台的test1-1 程序的信息？</strong></p>
<ul>
<li>
<p>jobs命令<br>
功能：查看当前终端后台运行的任务<br>
<code>jobs -l</code>选项可显示当前终端所有任务的PID，jobs的状态可以是running，stopped，Terminated。+ 号表示当前任务，- 号表示后一个任务。</p>
</li>
<li>
<p>ps命令<br>
功能：ps命令用于报告当前系统的进程状态<br>
<code>ps -ef | grep &quot;test1-1&quot;</code><br>
-a：显示所有终端机下执行的程序<br>
-f：显示UID,PPIP,C与STIME栏位。</p>
</li>
</ul>
<p>测试截图</p>
<p><img src="/2017/10/18/Linux/Linux守护进程1/1.jpg" alt=""></p>
</li>
<li>
<p><strong>如何使test1-1 重新切换到前台来？</strong></p>
<p>fg 命令</p>
</li>
<li>
<p><strong>再次将test1-1 放入后台，./test1-2 运行test1-2 程序，然后将test1-2 也放入后台如何控制将test1-1/test1-2 中的某一个切换到前台来？</strong></p>
<p>fg + 工作序号。如 fg 2 会让 test1-2 回到前台。<br>
同理，如果后台有多个工作停止，则使用 bg + 工作序号可以使指定工作开始后台运行。</p>
<p><code>[1]- [2]+</code>，加号代表当前工作为<code>[2]</code>，减号代表当前工作的下一个工作为<code>[1]</code>。它们表明了工作执行的顺序，如果你使用不加序号的 fg 命令，则默认把带加号的工作提到前台。</p>
<p>测试截图</p>
<p><img src="/2017/10/18/Linux/Linux守护进程1/2.jpg" alt=""></p>
</li>
<li>
<p><strong>test1-1/test1-2 的父进程标识是谁？如何查看？</strong></p>
<pre><code>ps -ef | grep test1-1   #查看test1-1进程信息
pstree pid  #查看pid进程树
ps -ef | grep pid #筛选出包含与pid有关的进程，其中第二列为pid，第三列为ppid
</code></pre>
<p>测试截图</p>
<p><img src="/2017/10/18/Linux/Linux守护进程1/3.jpg" alt=""><br>
<img src="/2017/10/18/Linux/Linux守护进程1/4.jpg" alt=""></p>
</li>
<li>
<p><strong>用SecureCRT 再登录一个控制台，用什么命令可以看到test1-1/test1-2 的信息？此时父进
程标识是谁？如何查看？</strong></p>
<p>同上，一样的命令可以查看，原进程pid及ppid不变，此时的bash进程pid不同。</p>
</li>
<li>
<p><strong>当test1-1/test1-2 在后台运行时，如果CTRL+D 退出该控制台登录，在另一个控制台再查看test1-1/test1-2 的信息，此时父进程标识是谁？</strong></p>
<p>父进程PID 是 1。</p>
<p>测试截图</p>
<p><img src="/2017/10/18/Linux/Linux守护进程1/5.jpg" alt=""></p>
</li>
<li>
<p><strong>能否使test1-1/test1-2 在终端退出登录后继续运行（不是再次运行）？此时打印信息能否继续出现在新登录的终端上？</strong></p>
<ol>
<li>
<p>setsid命令，用setsid来启动程序，使启动的进程在新的session中，并且终端关闭时，进程不退出。</p>
<pre><code>setsid ./test1-1 &amp;
setsid ./test1-2 &amp;
</code></pre>
</li>
<li>
<p>nohup命令，被nohup启动的程序会忽略SIGHUP信号。</p>
<pre><code>nohup ./test1-1 &amp;
nohup ./test1-2 &amp;
</code></pre>
<p>nohup命令可以将程序以忽略挂起信号的方式运行起来，被运行的程序的输出信息将不会显示到终端。 无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中。如果当前目录的 nohup.out 文件不可写，输出重定向到$HOME/nohup.out文件中。</p>
</li>
<li>
<p>对于jobs中的后台程序，通过disown命令</p>
<pre><code>disown -h %id   #id表示jobs中的id
</code></pre>
</li>
</ol>
<p>打印信息不会继续出现在新的终端上。<br>
会不会出现在新的终端上取决于新的 shell 的标准输出/错误输出的文件描述符是否与 test1-1 test1-2 进程相同。在原来终端未退出时，默认情况下（没有使用重定向）它们继承了父进程（即原来 shell）的文件描述符。在原来 shell 结束后，它们继承新的父进程的文件描述符，而新的文件描述符和原来文件描述符是不同的，所以不会。</p>
<p>我们可以用重定向将输出重定向为指定设备。</p>
<pre><code>tty #获取某个终端的控制台
setsid ./test1-1 &gt;/dev/pts/1    #/dev/pts/1 是上面的结果
</code></pre>
</li>
<li>
<p><strong>如何将一个正常程序直接放入后台运行？（不要通过按键切换）</strong></p>
<p>执行程序时，在命令后加上 &amp;，比如 <code>./test1-1 &amp;</code></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/18/Linux/Linux守护进程5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/18/Linux/Linux守护进程5/" itemprop="url">Linux守护进程5</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-18T19:44:25+08:00">
                2017-10-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4>Linux守护进程5 — 守护进程分裂子进程极限测试</h4>
<hr>
<ul>
<li>
<p><strong>在05 子目录下写test5-1.c，用main 函数带参数方式带入一个参数表示循环次数，然后循环
指定参数产生子进程，每个子进程中定义一个大小为1024 的字符数组，任意赋值，然后进入
死循环（为了屏幕干净，不用打印信息）；主进程每分裂若干个子进程（例如：10 个/100 个
等，可自行决定）后打印一次&quot;已分裂***个子进程&quot;，循环结束后/或分裂子进程失败后打印
分裂成功的总数，然后进入死循环；写配套的makefile 文件，make 后可生成test5-1 可执行
文件，执行方法为 ./test5-1 1000 表示分裂1000 个子进程</strong></p>
<pre><code>//test5-1.c

#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/wait.h&gt;

#define DEFAULT_NUMS 500
#define PRINT_CYCLE 1000
#define SUB_STR_SIZE 1024
#define SUB_SLEEP_TIME 1
#define MAIN_SLEEP_TIME 1

int daemon_init(void){
    pid_t pid;
    if ((pid = fork()) &lt; 0)
		return -1;
	else if (pid)   
		exit(0);	/* parent exit */

	/* child continues */
	setsid();	/* become session leader */
    chdir(&quot;/&quot;);	/* change working directory */
	umask(0);	/* clear file mode creation mask */
	close(0);    /* close stdin stdout stderr */
//	close(1);
	close(2);
	return 0;
}

void sig_child(int signo){
	while(waitpid(-1, NULL, WNOHANG)&gt;0)
		;
}

int main(int argc, char **argv){
	if (daemon_init() == -1){
		printf(&quot;can't fork self\n&quot;);
		exit(0);
	}
	signal(SIGCHLD, sig_child);
	signal(SIGINT, sig_child);
    signal(SIGTERM, sig_child);
	
	int forkNums=argc&gt;1 ? atoi(argv[1]): DEFAULT_NUMS;
	int i;
	
	pid_t pid;
	
	for (i=0; i&lt;forkNums; ++i){
		if (i%PRINT_CYCLE==0)
			printf(&quot;已分裂 %6d 个子进程\n&quot;, i);
		
		if ((pid=fork()) &lt; 0){
			perror(&quot;fork error&quot;);
			break;
		}
		else if(pid==0)		//子进程退出
			break;
	}

	if (pid==0) {	//子进程
		char str [SUB_STR_SIZE];
		//初始随机，算是随机赋值了吧
		while (1)
			sleep(SUB_SLEEP_TIME);
	}
	else {
		printf(&quot;目标分裂:%d 成功分裂:%d \n&quot;, forkNums, i);
		while (1)
			sleep(MAIN_SLEEP_TIME);
	}
	
	return 0;
}
</code></pre>
<p>makefile</p>
<pre><code>CC ?= gcc
CFLAGS =

srcNames :=test5-1 test5-2 test5-3

all :
	@for src in $(srcNames) ; \
	do \
		$(CC) $(CFLAGS) -o $$src &quot;$$src&quot;.c ; \
	done

clean :
	rm -f *.o $(srcNames)

.PHONY : all clean
</code></pre>
</li>
<li>
<p><strong>虚拟机的内存设置为512MB，分裂数量达到多少时，分裂子进程会失败？</strong></p>
<p><img src="/2017/10/18/Linux/Linux守护进程5/1.jpg" alt=""></p>
</li>
<li>
<p><strong>虚拟机的内存为1024MB、2048MB 时，分裂最大数量又是多少？</strong></p>
<p><img src="/2017/10/18/Linux/Linux守护进程5/2.jpg" alt=""></p>
<p><img src="/2017/10/18/Linux/Linux守护进程5/3.jpg" alt=""></p>
</li>
<li>
<p><strong>把<code>char str[1024]</code>改为<code>char str[1024*10]</code>，再次测试三种内存下的最大分裂数量</strong></p>
<p>512M：</p>
<p><img src="/2017/10/18/Linux/Linux守护进程5/4.jpg" alt=""></p>
<p>1024M：</p>
<p><img src="/2017/10/18/Linux/Linux守护进程5/5.jpg" alt=""></p>
<p>2048M：</p>
<p><img src="/2017/10/18/Linux/Linux守护进程5/6.jpg" alt=""></p>
</li>
<li>
<p><strong>写test5-2.c，要求与test5-1 相同，但是子进程给str 赋值完后，不要死循环，等待20 秒
后子进程退出，在这种情况下，如何做到在小内存的情况下分裂完成指定大数量的子进程？（例如：在512MB 内存情况下，分别100000 个子进程且必须都分裂成功）</strong></p>
<p>要做到在限定内存下同时存在大数量子进程是不行的，但是因为一些子进程会在一定时间推出，只要做到能够收到子进程退出信号回收内存，同时父进程在不能成功fork时休眠一段时间再尝试fork，这样总能成功，完成分裂指定大数量的子进程。测试截图见下一题。</p>
<pre><code>//test5-2.c

#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/wait.h&gt;

#define DEFAULT_NUMS 500
#define PRINT_CYCLE 1000
#define SUB_STR_SIZE 1024
#define SUB_SLEEP_TIME 20
#define MAIN_SLEEP_TIME 1

int daemon_init(void){
    pid_t pid;
    if ((pid = fork()) &lt; 0)
		return -1;
	else if (pid)   
		exit(0);	/* parent exit */

	/* child continues */
	setsid();	/* become session leader */
    chdir(&quot;/&quot;);	/* change working directory */
	umask(0);	/* clear file mode creation mask */
	close(0);   /* close stdin stdout stderr */
//	close(1);
	close(2);
	return 0;
}

void sig_child(int signo){
	while(waitpid(-1, NULL, WNOHANG)&gt;0)
		;
}

int main(int argc, char **argv){
	if (daemon_init() == -1){
		printf(&quot;can't fork self\n&quot;);
		exit(0);
	}
	signal(SIGCHLD, sig_child);
	signal(SIGINT, sig_child);
    signal(SIGTERM, sig_child);
	
	int forkNums=argc&gt;1 ? atoi(argv[1]): DEFAULT_NUMS;
	int i, max_pid=0;
	
	pid_t pid;
	
	for (i=0; i&lt;forkNums; ){
		if (i%PRINT_CYCLE==0)
			printf(&quot;已分裂 %6d 个子进程\n&quot;, i);
		
		pid=fork();
		if(pid==0)
			break;
		else if(pid&gt;0)
			++i;
		else
			sleep(MAIN_SLEEP_TIME);

		max_pid= max_pid&lt;pid? pid :max_pid;
	}

	if (pid==0) {	//子进程
		char str [SUB_STR_SIZE];
		//初始随机，算是随机赋值了吧
		sleep(SUB_SLEEP_TIME);
		exit(0);
	}
	else {			//父进程
		printf(&quot;目标分裂:%d 成功分裂:%d \n&quot;, forkNums, i);
		printf(&quot;max_pid = %d \n&quot;, max_pid);
		while (1)
			sleep(MAIN_SLEEP_TIME);
	}
	
	return 0;
}
</code></pre>
</li>
<li>
<p><strong>在test5-2.c 中加适当的语句，看分裂的子进程的最大进程号是多少？</strong></p>
<p>测试1截图（10w）：</p>
<p><img src="/2017/10/18/Linux/Linux守护进程5/70.jpg" alt=""></p>
<p>测试2截图(10w)：</p>
<p><img src="/2017/10/18/Linux/Linux守护进程5/71.jpg" alt=""></p>
<p>测试3截图(100w)：</p>
<p><img src="/2017/10/18/Linux/Linux守护进程5/72.jpg" alt=""></p>
<p>测试4截图(100w)：</p>
<p><img src="/2017/10/18/Linux/Linux守护进程5/73.jpg" alt=""></p>
</li>
<li>
<p><strong>写test5-3.c，基本要求同test5-2，但是由守护进程负责回收每个子进程退出信号，设置两
个全局变量做为计数器，一个记录分裂成功的数量，一个记录回收成功的数量，要求全部分
裂完成后，且所有子进程都退出后，两个计数器的值要相同（测试数量≧50000）</strong></p>
<p>在test5-2.c的基础上，只要做到子进程退出时，通知到父进程，父进程调用函数处理即可。</p>
<pre><code>//test5-3.c

#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/wait.h&gt;

#define DEFAULT_NUMS 500
#define PRINT_CYCLE 1000
#define SUB_STR_SIZE 1024
#define SUB_SLEEP_TIME 1
#define MAIN_SLEEP_TIME 1
#define ERROR_SLEEP_TIME SUB_SLEEP_TIME

int daemon_init(void){
    pid_t pid;
    if ((pid = fork()) &lt; 0)
		return -1;
	else if (pid)   
		exit(0);	/* parent exit */

	/* child continues */
	setsid();	/* become session leader */
    chdir(&quot;/&quot;);	/* change working directory */
	umask(0);	/* clear file mode creation mask */
	close(0);   /* close stdin stdout stderr */
//	close(1);
	close(2);
	return 0;
}

int exitNums=0;

void sig_child(int signo){
	while(waitpid(-1, NULL, WNOHANG)&gt;0)
		++exitNums;
}

int main(int argc, char **argv){
	if (daemon_init() == -1){
		printf(&quot;can't fork self\n&quot;);
		exit(0);
	}
	
	signal(SIGCHLD, sig_child);
	signal(SIGINT, sig_child);
    signal(SIGTERM, sig_child);
	
	int forkNums=argc&gt;1 ? atoi(argv[1]): DEFAULT_NUMS;
	int i, max_pid=0;
	
	pid_t pid;
	
	for (i=0; i&lt;forkNums; ){
		if (i%PRINT_CYCLE==0)
			printf(&quot;已分裂 %6d 个子进程\n&quot;, i);
		
		pid=fork();
		if(pid==0)
			break;
		else if(pid&gt;0)
			++i;
		else
			sleep(MAIN_SLEEP_TIME);

		max_pid= max_pid&lt;pid? pid :max_pid;
	}

	if (pid==0) {	//子进程
		char str [SUB_STR_SIZE];
		//初始随机，算是随机赋值了吧
		sleep(SUB_SLEEP_TIME);
		exit(0);
	}
	else {			//父进程
		printf(&quot;目标分裂:%d 成功分裂:%d \n&quot;, forkNums, i);
		printf(&quot;max_pid = %d \n&quot;, max_pid);
		while (1){
			printf(&quot;成功分裂%d个， 成功回收%d个\n&quot;, i, exitNums);
			sleep(MAIN_SLEEP_TIME);
		}
	}
	
	return 0;
}
</code></pre>
<p>测试截图</p>
<p><img src="/2017/10/18/Linux/Linux守护进程5/80.jpg" alt="">
<img src="/2017/10/18/Linux/Linux守护进程5/81.jpg" alt=""></p>
</li>
<li>
<p><strong>提示：当极限测试导致子进程分裂失败后，Linux 系统还能正常操作吗？</strong></p>
<p>已经不能正常工作。</p>
<p><img src="/2017/10/18/Linux/Linux守护进程5/9.jpg" alt=""></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/Linux/LinuxMySQL静态编译/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/08/Linux/LinuxMySQL静态编译/" itemprop="url">Linux-MySQL的静态编译</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T23:26:12+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<ol>
<li>
<p><strong>准备</strong></p>
<p>1.1 <strong>libc 静态库文件</strong><br>
若缺少libc静态库文件，则会失败，如下信息。</p>
<p><img src="/2017/10/08/Linux/LinuxMySQL静态编译/1.png" alt=""></p>
<p>安装如下：
首先下载相应安装包，<a href="https://centos.pkgs.org/7/centos-x86_64/glibc-static-2.17-196.el7.x86_64.rpm.html" target="_blank" rel="external">下载地址</a>，放置到任意目录下（此处为/home），进入该目录，</p>
<p>执行如下命令，升级安装完成。</p>
<p><img src="/2017/10/08/Linux/LinuxMySQL静态编译/2.jpg" alt=""></p>
<p>可查看系统安装的GLIBC包，如下</p>
<p><img src="/2017/10/08/Linux/LinuxMySQL静态编译/3.png" alt=""></p>
<p>1.2 <strong>获取libmysqlclient.a静态库</strong><br>
<strong>下载源码编译方式</strong></p>
<p>获取MariaDB源码
下载相应源码，下载地址https://downloads.mariadb.org/mariadb/5.5.56/ 下载后传到虚拟机中，解压然后编译。</p>
<p><img src="/2017/10/08/Linux/LinuxMySQL静态编译/4.png" alt=""></p>
<p>准备安装环境</p>
<pre><code>yum –y groupinstall Development tools
yum –y install ncurses-devel
yum –y install cmake
</code></pre>
<p>编译MariaDB得到libmysqlclient.a</p>
<pre><code>tar –zxvf mariadb-5.5.56.tar.gz
cd mariadb-5.5.56
cmake . –LH		#查看cmake的可用选项
cmake . -DCMAKE_INSTALL_PREFIX=/home/mysql
        -DMYSQL_DATADIR=/home/mysqldata -DSYSCONFDIR=/etc 
        -DWITHOUT_TOKUDB=1 -DMYSQL_UNIX_ADDR=/home/tmp/mysql.sock 
        -DDEFAULT_CHARSET=gbk -DDEFAULT_COLLATION=gbk_general_ci
make
make install
</code></pre>
<p>完成上述命令后，在/home/mysql/lib/目录下可得到libmysqlclient.a静态库文件</p>
<p><strong>直接获取libmysqlclient.a方式</strong><br>
下载编译后的MariaDB文件，<a href="https://downloads.mariadb.org/mariadb/5.5.56/" target="_blank" rel="external">下载地址</a></p>
<p><img src="/2017/10/08/Linux/LinuxMySQL静态编译/5.jpg" alt=""></p>
<p>解压</p>
<pre><code>tar -zxvf mariadb-5.5.56-linux-x86_64.tar.gz
</code></pre>
<p>在mariadb-5.5.56-linux-x86_64目录下的lib文件夹下得到libmysqlclient.a文件</p>
<p><img src="/2017/10/08/Linux/LinuxMySQL静态编译/6.png" alt=""></p>
</li>
<li>
<p><strong>编译</strong></p>
<p><strong>编译说明：</strong></p>
<pre><code> 这里采用的是半静态半动态编译方法。libmysqlclient.a库用静态连接，一些常用的库用动态连接。
 因为程序是运行在linux中的，常用库系统默认都会有的。  
</code></pre>
<p><strong>编译命令：</strong></p>
<pre><code> g++ mysql_demo.cpp -o mysql_demo -I/usr/include/mysql -Wl,-dn -L. 
  -lmysqlclient  -Wl,-dy -lpthread -lm -ldl -lcrypt
</code></pre>
<p><strong>命令解释：</strong></p>
<pre><code> -Idir
 编译时优先在选项后的目录中查找包含的头文件,然后将到系统缺省的头文件目录查找
 -Ldir
 指定编译搜索库的路径
 -llibrary
 制定编译的时候使用的库
 -Wl,-dn
 后面是静态链接
 -Wl,-dy
 后面是动态连接
</code></pre>
<p><strong>库解释：</strong></p>
<pre><code> -lpthread
 使用POSIX线程库添加对多线程的支持
 -lm 
 链接的是数学函数库
 -ldl
 显式加载动态库的动态函数库（dlopen(),dlclose() , dlerror() , dlsym()）
</code></pre>
</li>
<li>
<p><strong>运行</strong></p>
<p>ln命令用来为文件创件连接，连接类型分为硬连接和符号连接两种，默认的连接类型是硬连接。如果要创建符号连接必须使用&quot;-s&quot;选项。</p>
<pre><code>ln -s /var/lib/mysql/mysql.sock /tmp/mysql.sock
</code></pre>
<p><img src="/2017/10/08/Linux/LinuxMySQL静态编译/7.jpg" alt=""></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/Linux/Linux动态编译/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/08/Linux/Linux动态编译/" itemprop="url">Linux动态编译</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T22:16:50+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<pre><code>前几周的做的，懒得重新编辑，图较多，直接截图了。
</code></pre>
<p><img src="/2017/10/08/Linux/Linux动态编译/11.jpg" alt="11">
<img src="/2017/10/08/Linux/Linux动态编译/12.jpg" alt="12">
<img src="/2017/10/08/Linux/Linux动态编译/13.jpg" alt="13">
<img src="/2017/10/08/Linux/Linux动态编译/14.jpg" alt="14">
<img src="/2017/10/08/Linux/Linux动态编译/15.jpg" alt="15">
<img src="/2017/10/08/Linux/Linux动态编译/16.jpg" alt="16"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/Linux/Linux静态编译/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/08/Linux/Linux静态编译/" itemprop="url">Linux静态编译</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T21:45:01+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<pre><code>前几周的做的，懒得重新编辑，图较多，直接截图了。
</code></pre>
<p><img src="/2017/10/08/Linux/Linux静态编译/11.jpg" alt="11">
<img src="/2017/10/08/Linux/Linux静态编译/12.jpg" alt="12">
<img src="/2017/10/08/Linux/Linux静态编译/13.jpg" alt="13">
<img src="/2017/10/08/Linux/Linux静态编译/14.jpg" alt="14">
<img src="/2017/10/08/Linux/Linux静态编译/15.jpg" alt="15"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/Linux/Linux-Makefile的基本使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/08/Linux/Linux-Makefile的基本使用/" itemprop="url">Linux-Makefile的基本使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T20:59:27+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3>Makefile之我见</h3>
<ol>
<li>
<p><strong>Makefile文件的作用</strong></p>
<p>Linux内核中 Makefile 的作用是根据配置的情况，构造出需要编译的源文件列表，然后分别编译，并把目标代码链接到一起，最终形成 linux 内核二进制文件。</p>
<p>一个工程中的源文件不计其数，按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p>
<p>makefile文件保存了编译器和连接器的参数选项,还表述了所有源文件之间的关系(源代码文件需要的特定的包含文件,可执行文件要求包含的目标文件模块及库等).创建程序(make程序)首先读取makefile文件,然后再激活编译器,汇编器,资源编译器和连接器以便产生最后的输出,最后输出并生成的通常是可执行文件.创建程序利用内置的推理规则来激活编译器,以便通过对特定CPP文件的编译来产生特定的OBJ文件.</p>
</li>
<li>
<p><strong>作业中用到的基本语法</strong></p>
<p><strong>Makefile基本格式：</strong></p>
<pre><code>target ... : prerequisites ...
command
...
...
</code></pre>
<p>target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label）。
prerequisites就是，要生成那个target所需要的文件或是目标。
command也就是make需要执行的命令。（任意的Shell命令）
这是一个文件的依赖关系，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。</p>
<p><strong>关于依赖关系</strong><br>
make会一层一层的去找文件的依赖关系，最终编译出第一个目标文件。</p>
<p><strong>关于重新编译</strong><br>
只要任何prerequisite 比 target新，那么这个目标文件就会被下面的命令重新生成。每一个命令都会被传递到shell中，并在自己的子shell里面执行。</p>
<p><strong>关于错误</strong><br>
如果在寻找过程中出现错误，如文件找不到，则make会直接退出并报错。对于所定义的命令错误或者编译不成功，make是不会理会的，它只负责文件的依赖性。</p>
<p><strong>变量的基本使用</strong><br>
在Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是Makefile的其它部分中。
变量在声明时需要给予初值，而在使用时，需要给在变量名前加上“$”符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来。</p>
<p><strong>伪目标</strong><br>
伪目标是这样一个目标：它不代表一个真正的文件名，在执行make时可以指定这个目标来执行其所在规则定义的命令，有时我们也可以将一个伪目标称为标签。
将一个目标声明为伪目标需要将它作为特殊目标.PHONY的依赖。如下：</p>
<pre><code>.PHONY : clean 
clean: 
rm *.o temp 
</code></pre>
<p>这样目标clean就是一个伪目标，无论当前目录下是否存在clean这个文件。我们输入make clean之后。rm命令都会被执行。而且，当一个目标被声明为伪目标后，make在执行此规则时不会试图去查找隐含规则来创建这个目标。这样也提高了make的执行效率，同时我们也不用担心由于目标和文件名重名而使我们的期望失败。</p>
<p><strong>Makefile自动推导</strong><br>
GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来。</p>
<p><strong>嵌套执行make</strong><br>
在Makefile中使用“make”作为一个命令来执行本身或者其它makefile文件。递归调用在一个村在有多级子目录的项目中非常有用。例如，当前目录下存在一个“subdir”子目录，这个子目录中有描述这个目录编译规则的makefile文件，在执行make时需要从上层目录（当前目录）开始并完成它所有子目录的编译。那么在当前目录下可以使用这样一个规则来实现对它的子目录的编译：</p>
<pre><code>subsystem:
   $(MAKE) -C subdir
</code></pre>
<p>规则中“$(MAKE)”是对变量“MAKE”的引用，在make的递归调用中，需要了解变量“CURDIR”，此变量代表了make当前的工作路径。如果使用“-C”选项进入一个子目录后，此变量将被重新赋值。总之，如果在Makefile中没有对此变量进行显式的赋值操作，那么它代表make的当前工作目录。我们也可以在Makefile为这个变量赋一个新的值。此时这变量将不再代表make的工作目录。</p>
<p><strong>Shell函数</strong><br>
shell函数也不像其它的函数。它的参数应该就是操作系统Shell的命令。它和反引号“`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：</p>
<pre><code>contents := $(shell cat foo) 
files := $(shell echo *.c) 
</code></pre>
<p>注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。</p>
<p><strong>for循环</strong><br>
在makefile中使用for语句，其行结束要使用“；\”do的前后用空格分开用\结尾；for语句内循环要用2个Tab。形如：</p>
<pre><code>@(for i in $(files); do \
echo &quot;$$i &quot;;\
done
</code></pre>
</li>
</ol>
<hr>
<h3>系统概述Makefile</h3>
<ol>
<li>
<p><strong>Make的概念</strong></p>
<p>Make这个词，英语的意思是&quot;制作&quot;。Make命令直接用了这个意思，就是要做出某个文件。比如，要做出文件a.txt，就可以执行下面的命令。</p>
<pre><code>$ make a.txt
</code></pre>
<p>但是，如果你真的输入这条命令，它并不会起作用。因为Make命令本身并不知道，如何做出a.txt，需要有人告诉它，如何调用其他命令完成这个目标。
比如，假设文件 a.txt 依赖于 b.txt 和 c.txt ，是后面两个文件连接（cat命令）的产物。那么，make 需要知道下面的规则。</p>
<pre><code>a.txt: b.txt c.txt
cat b.txt c.txt &gt; a.txt
</code></pre>
<p>也就是说，make a.txt 这条命令的背后，实际上分成两步：第一步，确认 b.txt 和 c.txt 必须已经存在，第二步使用 cat 命令 将这个两个文件合并，输出为新文件。
像这样的规则，都写在一个叫做Makefile的文件中，Make命令依赖这个文件进行构建。Makefile文件也可以写为makefile， 或者用命令行参数指定为其他文件名。</p>
<pre><code>$ make -f rules.txt
# 或者
$ make --file=rules.txt
</code></pre>
<p>上面代码指定make命令依据rules.txt文件中的规则，进行构建。
总之，make只是一个根据指定的Shell命令进行构建的工具。它的规则很简单，你规定要构建哪个文件、它依赖哪些源文件，当那些文件有变动时，如何重新构建它。</p>
</li>
<li>
<p><strong>Makefile文件的格式</strong></p>
<p>2.1 <strong>概述</strong><br>
Makefile文件由一系列规则（rules）构成。每条规则的形式如下。</p>
<pre><code>&lt;target&gt; : &lt;prerequisites&gt; 
[tab]  &lt;commands&gt;
</code></pre>
<p>上面第一行冒号前面的部分，叫做&quot;目标&quot;（target），冒号后面的部分叫做&quot;前置条件&quot;（prerequisites）；第二行必须由一个tab键起首，后面跟着&quot;命令&quot;（commands）。
&quot;目标&quot;是必需的，不可省略；&quot;前置条件&quot;和&quot;命令&quot;都是可选的，但是两者之中必须至少存在一个。
每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。</p>
<p>2.2 <strong>目标（target）</strong><br>
一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。
除了文件名，目标还可以是某个操作的名字，这称为&quot;伪目标&quot;（phony target）。
clean:
rm *.o</p>
<p>上面代码的目标是clean，它不是文件名，而是一个操作的名字，属于&quot;伪目标 &quot;，作用是删除对象文件。</p>
<pre><code>$ make  clean
</code></pre>
<p>但是，如果当前目录中，正好有一个文件叫做clean，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。
为了避免这种情况，可以明确声明clean是&quot;伪目标&quot;，写法如下。</p>
<pre><code>.PHONY: clean
clean:
rm *.o temp
</code></pre>
<p>声明clean是&quot;伪目标&quot;之后，make就不会去检查是否存在一个叫做clean的文件，而是每次运行都执行对应的命令。像.PHONY这样的内置目标名还有不少，可以查看手册。
如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。</p>
<pre><code>$ make
</code></pre>
<p>上面代码执行Makefile文件的第一个目标。</p>
<p>2.3 <strong>前置条件（prerequisites）</strong><br>
前置条件通常是一组文件名，之间用空格分隔。它指定了&quot;目标&quot;是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），&quot;目标&quot;就需要重新构建。</p>
<pre><code>result.txt: source.txt
cp source.txt result.txt
</code></pre>
<p>上面代码中，构建 result.txt 的前置条件是 source.txt 。如果当前目录中，source.txt 已经存在，那么make result.txt可以正常运行，否则必须再写一条规则，来生成 source.txt 。</p>
<pre><code>source.txt:
echo &quot;this is the source&quot; &gt; source.txt
</code></pre>
<p>上面代码中，source.txt后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件还不存在，每次调用make source.txt，它都会生成。
$ make result.txt
$ make result.txt</p>
<p>上面命令连续执行两次make result.txt。第一次执行会先新建 source.txt，然后再新建 result.txt。第二次执行，Make发现 source.txt 没有变动（时间戳晚于 result.txt），就不会执行任何操作，result.txt 也不会重新生成。
如果需要生成多个文件，往往采用下面的写法。</p>
<pre><code>source: file1 file2 file3
</code></pre>
<p>上面代码中，source 是一个伪目标，只有三个前置文件，没有任何对应的命令。</p>
<pre><code>$ make source
</code></pre>
<p>执行make source命令后，就会一次性生成 file1，file2，file3 三个文件。这比下面的写法要方便很多。</p>
<pre><code>$ make file1
$ make file2
$ make file3
</code></pre>
<p>2.4 <strong>命令（commands）</strong><br>
命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建&quot;目标&quot;的具体指令，它的运行结果通常就是生成目标文件。
每行命令之前必须有一个tab键。如果想用其他键，可以用内置变量.RECIPEPREFIX声明。</p>
<pre><code>.RECIPEPREFIX = &gt;
all:
&gt; echo Hello, world
</code></pre>
<p>上面代码用.RECIPEPREFIX指定，大于号（&gt;）替代tab键。所以，每一行命令的起首变成了大于号，而不是tab键。
需要注意的是，每行命令在一个单独的shell中执行。这些Shell之间没有继承关系。</p>
<pre><code>var-lost:
export foo=bar
echo &quot;foo=[$$foo]&quot;
</code></pre>
<p>上面代码执行后（make var-lost），取不到foo的值。因为两行命令在两个不同的进程执行。一个解决办法是将两行命令写在一行，中间用分号分隔。</p>
<pre><code>var-kept:
export foo=bar; echo &quot;foo=[$$foo]&quot;
</code></pre>
<p>另一个解决办法是在换行符前加反斜杠转义。</p>
<pre><code>var-kept:
export foo=bar; \
echo &quot;foo=[$$foo]&quot;
</code></pre>
<p>最后一个方法是加上.ONESHELL:命令。</p>
<pre><code>.ONESHELL:
var-kept:
export foo=bar; 
echo &quot;foo=[$$foo]&quot;
</code></pre>
</li>
<li>
<p><strong>Makefile文件的语法</strong></p>
<p>3.1 <strong>注释</strong><br>
井号（#）在Makefile中表示注释。</p>
<pre><code># 这是注释
result.txt: source.txt
# 这是注释
cp source.txt result.txt # 这也是注释
</code></pre>
<p>3.2 <strong>回声（echoing）</strong><br>
正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。</p>
<pre><code>test:
# 这是测试
</code></pre>
<p>执行上面的规则，会得到下面的结果。</p>
<pre><code>$ make test
# 这是测试
</code></pre>
<p>在命令的前面加上@，就可以关闭回声。</p>
<pre><code>test:
@# 这是测试
</code></pre>
<p>现在再执行make test，就不会有任何输出。
由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。</p>
<pre><code>test:
@# 这是测试
@echo TODO
</code></pre>
<p>3.3 <strong>通配符</strong><br>
通配符（wildcard）用来指定一组符合条件的文件名。Makefile 的通配符与 Bash 一致，主要有星号（*）、问号（？）和 [...] 。比如， *.o 表示所有后缀名为o的文件。</p>
<pre><code>clean:
    rm -f *.o
</code></pre>
<p>3.4 <strong>模式匹配</strong><br>
Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。</p>
<pre><code>%.o: %.c
</code></pre>
<p>等同于下面的写法。</p>
<pre><code>f1.o: f1.c
f2.o: f2.c
</code></pre>
<p>使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。</p>
<p>3.5 <strong>变量和赋值符</strong><br>
Makefile 允许使用等号自定义变量。</p>
<pre><code>txt = Hello World
test:
    @echo $(txt)
</code></pre>
<p>上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中。
调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。</p>
<pre><code>test:
    @echo $$HOME
</code></pre>
<p>有时，变量的值可能指向另一个变量。</p>
<pre><code>v1 = $(v2)
</code></pre>
<p>上面代码中，变量 v1 的值是另一个变量 v2。这时会产生一个问题，v1 的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。
为了解决类似问题，Makefile一共提供了四个赋值运算符 （=、:=、？=、+=），它们的区别请看StackOverflow。</p>
<pre><code>VARIABLE = value
# 在执行时扩展，允许递归扩展。

VARIABLE := value
# 在定义时扩展。

VARIABLE ?= value
# 只有在该变量为空时才设置值。

VARIABLE += value
# 将值追加到变量的尾端。
</code></pre>
<p>3.6 <strong>内置变量（Implicit Variables）</strong><br>
Make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性，详细的内置变量清单见手册。</p>
<pre><code>output:
$(CC) -o output input.c
</code></pre>
<p>3.7 <strong>自动变量（Automatic Variables）</strong><br>
Make命令还提供一些自动变量，它们的值与当前规则有关。主要有以下几个。</p>
<pre><code>（1）$@
$@指代当前目标，就是Make命令当前构建的那个目标。比如，make foo的 $@ 就指代foo。
a.txt b.txt: 
    touch $@
等同于下面的写法。
a.txt:
    touch a.txt
b.txt:
    touch b.txt
（2）$&lt;
$&lt; 指代第一个前置条件。比如，规则为 t: p1 p2，那么$&lt; 就指代p1。
a.txt: b.txt c.txt
    cp $&lt; $@ 
等同于下面的写法。
</code></pre>
</li>
<li>
<p><strong>Makefile 的实例</strong></p>
<pre><code>（1）执行多个目标
.PHONY: cleanall cleanobj cleandiff

cleanall : cleanobj cleandiff
        rm program

cleanobj :
        rm *.o

cleandiff :
        rm *.diff
</code></pre>
<p>上面代码可以调用不同目标，删除不同后缀名的文件，也可以调用一个目标（cleanall），删除所有指定类型的文件。</p>
<pre><code>（2）编译C语言项目
edit : main.o kbd.o command.o display.o 
    cc -o edit main.o kbd.o command.o display.o

main.o : main.c defs.h
    cc -c main.c
kbd.o : kbd.c defs.h command.h
    cc -c kbd.c
command.o : command.c defs.h command.h
    cc -c command.c
display.o : display.c defs.h
    cc -c display.c

clean :
     rm edit main.o kbd.o command.o display.o

.PHONY: edit clean
</code></pre>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/Test/Markdown/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/08/Test/Markdown/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T18:39:18+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<h2>心心念念的Markdown</h2>
<ol>
<li>这是第一行列表项。</li>
<li>这是第二行列表项。</li>
</ol>
<p>给出一些例子代码：</p>
<pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);
</code></pre>
</blockquote>
<blockquote>
<p>This is the first level of quoting.</p>
<blockquote>
<p>This is nested blockquote.</p>
</blockquote>
<p>Back to the first level.</p>
</blockquote>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
<p>Here is an example of AppleScript:</p>
<pre><code>tell application &quot;Foo&quot;
    beep
end tell
</code></pre>
<hr>
<hr>
<hr>
<hr>
<hr>
<p>A single backtick in a code span: <code>`</code></p>
<p>A backtick-delimited string in a code span: <code>`foo`</code></p>
<p>Please don't use any <code>&lt;blink&gt;</code> tags.</p>
<p>I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank" rel="external">Google</a> than from
<a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="external">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="external">MSN</a>.</p>
<p><a href="http://example.com/" target="_blank" rel="external">http://example.com/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/Linux/Linux安装配置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/08/Linux/Linux安装配置/" itemprop="url">Linux安装配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T14:22:13+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>1.安装Linux基本系统</h2>
<p>按照老师下发文档逐步完成即可。</p>
<h2>2.设置网卡</h2>
<p><img src="/2017/10/08/Linux/Linux安装配置/21.jpg" alt="">
<img src="/2017/10/08/Linux/Linux安装配置/22.jpg" alt=""></p>
<h2>3.双向ping通</h2>
<p><img src="/2017/10/08/Linux/Linux安装配置/31.jpg" alt=""></p>
<h2>4.Secure安装登录</h2>
<p><img src="/2017/10/08/Linux/Linux安装配置/41.jpg" alt=""></p>
<h2>5.中文显示</h2>
<p><img src="/2017/10/08/Linux/Linux安装配置/51.jpg" alt=""></p>
<h2>6.配置数据库-登录启动</h2>
<p><img src="/2017/10/08/Linux/Linux安装配置/61.jpg" alt=""></p>
<h2>7.配置数据库-字符集</h2>
<p><img src="/2017/10/08/Linux/Linux安装配置/71.jpg" alt=""></p>
<p><img src="/2017/10/08/Linux/Linux安装配置/72.jpg" alt=""></p>
<p><img src="/2017/10/08/Linux/Linux安装配置/73.jpg" alt=""></p>
<p><img src="/2017/10/08/Linux/Linux安装配置/74.jpg" alt=""></p>
<h2>8.安装配置 PHP Apache</h2>
<p>本次作业<a href="http://blog.btthly.com/rhel-configure-lamp-server-7-0-installation-apachephpmariadb.html" target="_blank" rel="external">参考链接</a>，其中包含了几乎所有安装配置过程，但是有些地方有误或不同，个人操作如下（红色代表不同）：</p>
<p><img src="/2017/10/08/Linux/Linux安装配置/81.jpg" alt="">
<img src="/2017/10/08/Linux/Linux安装配置/82.jpg" alt="">
<img src="/2017/10/08/Linux/Linux安装配置/83.jpg" alt="">
<img src="/2017/10/08/Linux/Linux安装配置/84.jpg" alt="">
<img src="/2017/10/08/Linux/Linux安装配置/85.jpg" alt="">
<img src="/2017/10/08/Linux/Linux安装配置/86.jpg" alt="">
<img src="/2017/10/08/Linux/Linux安装配置/87.jpg" alt=""></p>
<h2>9.安装MySQL组件</h2>
<p><img src="/2017/10/08/Linux/Linux安装配置/91.jpg" alt="">
<img src="/2017/10/08/Linux/Linux安装配置/92.jpg" alt=""></p>
<h2>10.修改FLASHFXP配置</h2>
<p><img src="/2017/10/08/Linux/Linux安装配置/101.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/Life/to be continued/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/08/Life/to be continued/" itemprop="url">to be continued ...</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T13:47:40+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p><strong>历史的进程还在继续...<br>
Life is continuing...</strong></p>
<h6>2017/10/22 11:22:57</h6>
<p>不要强迫症，没有最完美的东西，绝对没有；
知识和技能的学习才是根本目的，但也要和作业区分开来。</p>
<h6>2017/10/14 13:40:18</h6>
<p>一周一晃又过了，大部分时间都在这上边了，如何节约时间呢？本周总结几点：先易后难，先大部分再小细节，先重要后次要；有时卡壳个别题目可以先留着，有时候前后呼应，有所启发，理解的也深入一些；不要着急写文档，先可以写个60分的草稿。</p>
<h6>2017/10/9 17:20:18</h6>
<p>听课后的小结</p>
<ol>
<li>在实际操作时，多想一下本质总是好的，比如安装Linux虚拟机时NAT模式、bridge、host only模式的区别是什么，选择任意模式连接虚拟机和宿主机时出现问题不懂，光看一些教程即使当时可能正确了，但是按部就班是没有任何收获的，多思考、多尝试非常重要。</li>
<li>很多教程知识并不是完全适用你所在的环境的，比如Linux下有很多版本，光RedHat版本就有几种，同一系列下系统的一些配置命令、文件不同，还有MySQL与MariaDB等类似兼容软件名字不同等等，所以，要学会思考关键词，搜索才会有效率。</li>
<li>对于未知的东西，都应该问为什么，思考、猜测、多尝试才会有收获，不要做一遍之后什么都忘得一干二净。</li>
</ol>
<h6>2017/10/8 13:57:49</h6>
<p>今天算是我的个人博客的开篇吧，其实从小学、初中、高中、大学以来我都没有记笔记或者写作等等习惯，除了高中时期会有一些个人总结、心得感悟之类。一年以前这个博客已经搭建好，也是在国庆期间，发了三遍一般性文章就没有再怎么用到Hexo、GitHub等工具，一直搁到现在...</p>
<p>这一年中，大部分时间其实都在刷数据结构和算法题，以前想写点什么，总是觉得没什么好写，其实完全可以把这一年做的大大小小的算法题目及解题心得放在博客上的，目前只是把部分的题解放在了GitHub中，等有时间回味和复习的时候，把一些比较好的题目整理再推送吧。</p>
<p>希望能够把这个博客写下去，BaiJia Come on !</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/Linux/Linux gcc g++ 编译器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/08/Linux/Linux gcc g++ 编译器/" itemprop="url">Linux gcc g++ 编译器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T11:58:07+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>GCC/G++编译器</h2>
<p>GCC是GNU项目中的一个子项目，最初为用于编译C语言的编译器。随着GNU项目的发展，GCC已经成为了能编译C、C++、Ada、Object C和Java等语言的GNU编译器家族，同时还可执&gt;行跨硬件平台的交叉编译工作。G++ 则是专门用于编译C、C++语言的编译器。C和C++语言正在不断发展，为了保持兼容程序语言的最新特性，开发者通常选择GCC来编译C语言编写的源代码，选择G++来编译C++源代码。</p>
<h2>GCC/G++编译器的安装</h2>
<p>安装或更新GCC和G++可在GNU项目的 <a href="www.gnu.org">官网- www.gnu.org </a> 下载相应的安装包，也可以使用YUM 软件包管理器安装。其安装命令如下：</p>
<pre><code>yum install make //安装make程序

yum install gcc //安装GCC编译器

yum install gcc-c++ //安装G++编译器
</code></pre>
<p>注意：如果安装过程中提示需要选择编译器版本，可根据当前硬件平台选择最新发布的版
本，如果提示需要安装其他相关软件包，请一并安装。</p>
<h2>GCC/G++编译命令</h2>
<p>GCC/G++编译器没有图形界面，只能在终端上以命令行的形式运行。编译命令由命令名、选项和源文件名组成，格式如下：</p>
<pre><code>gcc [-选项1-] [-选项2-] .... [-选项n-] &lt;源文件名&gt;

g++ [-选项1-] [-选项2-] .... [-选项n-] &lt;源文件名&gt;
</code></pre>
<p>命令名、选项和源文件名之间使用空格分隔，一行命令中可以有多个选项，也可以只有一个选项。文件名可以包含文件的绝对路径，也可以实用相对路径。如果文件名不包含路径，那么源文件被视为在于工作目录中。如果命令中不包含输出的可执行文件名称，那么默认情况下将在工作目录中生成后缀为.out的可执行文件。</p>
<h2>GCC/G++编译选项</h2>
<p>GCC拥有一百多个编译选项。对于C语言和C++语言，G++与GCC的编译选项基本相同。常用的一些编译选项如下：</p>
<pre><code>编译选项	说明
-c	只进行预处理、编译和汇编，生成.o文件
-S	只进行预处理和编译，生成.s文件
-E	只进行预处理，产生预处理后的结果到标准输出
-C	预处理时不删除注释信息，常与-E同时使用
-o	指定目标名称，常与-c、-S同时使用，默认是.out
-include file	插入一个文件，功能等同源代码中的#include
-Dmacro[=defval]	定义一个宏，功能等同源代码中的#define macro[defval]
-Umaacro	取消一个宏，功能等同源代码中的#undefine macro
-Idir	优先在选项后的目录中查找包含的头文件
-Iname	链接后缀为.out的动态链接库来编译程序
-Ldir	指定编译搜索库的路径
-g	编译器编译时加入debug信息
-pg	编译器编译时加入信息给gprof
-share	使用动态库
-static	禁止使用动态库
</code></pre>
<p>更多 GNU GCC 编译手册可查看官方文档，推荐**<a href="http://www.shanghai.ws/gnu/gcc_1.htm" target="_blank" rel="external">GNU GCC手册</a>**</p>
<h2>GCC/G++编译器的执行过程</h2>
<p>编译器的执行过程可总结为4步：预处理、编译、汇编和连接。在预处理过程中，编译器会对源代码中的头文件和预处理语句进行分析，生成以.i为后缀的预处理文件。编译过程是将输入的源代码编译为以.o为后缀的目标文件。汇编过程是针对汇编语言的步骤，在便已后成成以.o为后缀的目标文件。最后执行连接过程，所有的目标文件被安排在可执行程序中的恰当位置。同时，该陈旭所调用到的库函数也从各自所在的档案库中连到合适的地方。</p>
<hr>
<p>参考链接</p>
<blockquote>
<p><a href="http://www.cnblogs.com/banshine/p/5041584.html" target="_blank" rel="external">Linux GCC/G++编译器</a>
<a href="http://www.shanghai.ws/gnu/gcc_1.htm" target="_blank" rel="external">GNU GCC手册</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/Test/MarkDown Test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/08/Test/MarkDown Test/" itemprop="url">MarkDown 语法测试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T10:07:49+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>MarkDown 语法测试</h1>
<hr>
<p><strong>粗体</strong></p>
<p><em>斜体</em></p>
<blockquote>
<p>引用</p>
</blockquote>
<p><code>代码块</code></p>
<h1>标题1</h1>
<h2>标题2</h2>
<p><a href="http://BaiJiazm.github.io" title="超链接" target="_blank" rel="external">超链接 http://BaiJiazm.github.io</a></p>
<ul>
<li>1</li>
<li>2</li>
<li>3</li>
</ul>
<ol>
<li>1</li>
<li>2</li>
<li>3</li>
</ol>
<hr>
<p>水平标尺</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/07/命令行语法格式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/07/命令行语法格式/" itemprop="url">命令行语法格式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-07T00:27:04+08:00">
                2016-10-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>各系统在描述命令行格式时各有区别，具体可参考具体文档说明，一般采用的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">命令 &lt;必选参数1|必选参数2&gt; [-option &#123;必选参数1|必选参数2|必选参数3&#125;] [可选参数...] &#123;(默认参数)|参数|参数&#125;</div></pre></td></tr></table></figure>
<p>命令格式中常用的几个符号含义如下：</p>
<p>尖括号&lt; &gt;：必选参数，使用时应将其替换为所指含义的参数</p>
<p>大括号{ }：必选参数，系统定义的参数，包含此处允许使用的参数</p>
<p>方括号[ ]：可选参数，系统定义的参数，在命令中根据需要加以取舍</p>
<p>小括号( )：指明参数的默认值，只用于{ }中</p>
<p>竖线|：用于分隔多个互斥参数，含义为“或”，使用时只能选择一个。</p>
<p>省略号...：以此类推前面，任意多个参数。</p>
<hr>
<p>参考链接：</p>
<blockquote>
<p><a href="http://man.chinaunix.net/linux/mandrake/101/zh_cn/Command-Line.html/convention.html#id2535998" target="_blank" rel="external">China Unix</a>
<a href="http://www.dewassoc.com/support/msdos/dos_commands.html" target="_blank" rel="external">MS-DOS Commands</a>
<a href="http://lavasoft.blog.51cto.com/62575/533131" target="_blank" rel="external">Linux命令格式</a>
<a href="https://support.ca.com/cadocs/0/CA%20ARCserve%20%20Backup%20r16-CHS/Bookshelf_Files/HTML/cmndline/index.htm?toc.htmcl_cmd_line_syntax_char.htm" target="_blank" rel="external">命令行语法字符</a>
<a href="http://publib.boulder.ibm.com/tividd/td/ITCM/SC23-4706-01/zh_CN/HTML/cmmcmst17.htm" target="_blank" rel="external">命令行语法</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/07/Life/从头再来/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/07/Life/从头再来/" itemprop="url">从头再来</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-07T00:18:36+08:00">
                2016-10-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><a href="http://music.163.com/song/109194/?userid=9727644" target="_blank" rel="external">《从头再来》</a></h1>
<hr>
<blockquote>
<p>演唱：刘欢
演唱：刘欢
填词：陈涛
谱曲：王晓锋
音乐风格：流行
歌曲语言：国语</p>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">昨天所有的荣誉，</div><div class="line">已变成遥远的回忆。</div><div class="line">勤勤苦苦已度过半生，</div><div class="line">今夜重又走进风雨。</div><div class="line">我不能随波浮沉，</div><div class="line">为了我致爱的亲人。</div><div class="line">再苦再难也要坚强，</div><div class="line">只为那些期待眼神。</div><div class="line">心若在梦就在，</div><div class="line">天地之间还有真爱</div><div class="line">看成败人生豪迈，</div><div class="line">只不过是从头再来</div><div class="line"></div><div class="line">昨天所有的荣誉，</div><div class="line">已变成遥远的回忆。</div><div class="line">勤勤苦苦已度过半生，</div><div class="line">今夜重又走入风雨。</div><div class="line">我不能随波浮沉，</div><div class="line">为了我致爱的亲人。</div><div class="line">再苦再难也要坚强，</div><div class="line">只为那些期待眼神。</div><div class="line">心若在梦就在，</div><div class="line">天地之间还有真爱</div><div class="line">看成败人生豪迈，</div><div class="line">只不过是从头再来</div><div class="line">心若在梦就在，</div><div class="line">天地之间还有真爱</div><div class="line">看成败人生豪迈，</div><div class="line">只不过是从头再来</div><div class="line">心若在梦就在，</div><div class="line">天地之间还有真爱</div><div class="line">看成败人生豪迈，</div><div class="line">只不过是从头再来</div><div class="line">心若在梦就在，</div><div class="line">天地之间还有真爱</div><div class="line">看成败人生豪迈，</div><div class="line">只不过是从头再来</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">BaiJiazm</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BaiJiazm</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
