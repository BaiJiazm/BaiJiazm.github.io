<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="BaiJiazm">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="BaiJiazm">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BaiJiazm">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"right","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>BaiJiazm</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BaiJiazm</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每一段路都是一种领悟:)</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/05/Review/C++对象模型：类的大小/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/05/Review/C++对象模型：类的大小/" itemprop="url">C++对象模型：类的大小</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-05T09:23:49+08:00">
                2018-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4>参考以下博文：</h4>
<ul>
<li><a href="http://glgjing.github.io/blog/2015/03/23/shen-du-tan-suo-c-plus-plus-dui-xiang-mo-xing-:lei-de-da-xiao/" target="_blank" rel="external">深度探索C++对象模型：类的大小</a></li>
<li><a href="http://blog.csdn.net/u010921682/article/details/43529305" target="_blank" rel="external">C++ 空类的大小及相关继承类的大小</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//以下测试环境为GCC 32bit-Release模式</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A &#123;&#125;;</div><div class="line"><span class="keyword">class</span> B &#123;&#125;;</div><div class="line"><span class="keyword">class</span> C : <span class="keyword">public</span> A &#123;</div><div class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">c_fun</span><span class="params">()</span></span>=<span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> D : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(A):"</span>&lt;&lt;<span class="keyword">sizeof</span>(A)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(B):"</span>&lt;&lt;<span class="keyword">sizeof</span>(B)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(C):"</span>&lt;&lt;<span class="keyword">sizeof</span>(C)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(D):"</span>&lt;&lt;<span class="keyword">sizeof</span>(D)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 结果为： 1	1	4	4</div><div class="line"> * 最后一个可能与编译器有关，可能8</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		<span class="keyword">int</span> data;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B &#123;</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		<span class="keyword">int</span> data;</div><div class="line">		<span class="keyword">static</span> <span class="keyword">int</span> data1;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">int</span> B::data1=<span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">//注：void main()会编译报错</span></div><div class="line">main() &#123;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(A) = "</span>&lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sizeof(B) = "</span>&lt;&lt; <span class="keyword">sizeof</span>(B) &lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 结果为： 4	4</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		A(<span class="keyword">int</span> a) &#123;</div><div class="line">			a=x;</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">		~A() &#123;&#125;</div><div class="line"></div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		<span class="keyword">int</span> x;</div><div class="line">		<span class="keyword">int</span> g;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> B &#123;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		<span class="keyword">int</span> data;</div><div class="line">		<span class="keyword">int</span> data2;</div><div class="line">		<span class="keyword">static</span> <span class="keyword">int</span> xs;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">int</span> B::xs=<span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="function">A <span class="title">s</span><span class="params">(<span class="number">10</span>)</span></span>;</div><div class="line">	s.f(<span class="number">10</span>);</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(a): "</span>&lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(b): "</span>&lt;&lt; <span class="keyword">sizeof</span>(B) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 结果为： 8	8</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> X &#123;&#125;;</div><div class="line"><span class="keyword">class</span> Y : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;</div><div class="line"><span class="keyword">class</span> Z : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;</div><div class="line"><span class="keyword">class</span> A : <span class="keyword">public</span> Y, <span class="keyword">public</span> Z &#123;&#125;;</div><div class="line"><span class="comment">// 上述为经典的钻石继承</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(X): "</span> &lt;&lt; <span class="keyword">sizeof</span>(X) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Y): "</span> &lt;&lt; <span class="keyword">sizeof</span>(Y) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Z): "</span> &lt;&lt; <span class="keyword">sizeof</span>(Z) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(A): "</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 结果为： 1	4	4	8</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> X &#123;</div><div class="line">		<span class="keyword">int</span> a;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> Y : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;</div><div class="line"><span class="keyword">class</span> Z : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;</div><div class="line"><span class="keyword">class</span> A : <span class="keyword">public</span> Y, <span class="keyword">public</span> Z &#123;&#125;;</div><div class="line"><span class="comment">// 上述为经典的钻石继承</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(X): "</span> &lt;&lt; <span class="keyword">sizeof</span>(X) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Y): "</span> &lt;&lt; <span class="keyword">sizeof</span>(Y) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Z): "</span> &lt;&lt; <span class="keyword">sizeof</span>(Z) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(A): "</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 结果为： 4	8	8	12</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> X &#123;</div><div class="line">		<span class="keyword">int</span> a;</div><div class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>=<span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> Y : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;</div><div class="line"><span class="keyword">class</span> Z : <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;</div><div class="line"><span class="keyword">class</span> A : <span class="keyword">public</span> Y, <span class="keyword">public</span> Z &#123;&#125;;</div><div class="line"><span class="comment">// 上述为经典的钻石继承</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(X): "</span> &lt;&lt; <span class="keyword">sizeof</span>(X) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Y): "</span> &lt;&lt; <span class="keyword">sizeof</span>(Y) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Z): "</span> &lt;&lt; <span class="keyword">sizeof</span>(Z) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(A): "</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 结果为： 8	12	12	16</div><div class="line"> */</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/05/Review/C语言中的main写法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/05/Review/C语言中的main写法/" itemprop="url">C语言中的main写法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-05T09:08:10+08:00">
                2018-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4>参考以下博文：</h4>
<ul>
<li><a href="http://blog.csdn.net/kangjianwei101/article/details/50363359" target="_blank" rel="external">探寻main函数的标准写法，以及获取main函数的参数、返回值</a></li>
<li><a href="http://blog.csdn.net/piaojun_pj/article/details/5986516" target="_blank" rel="external">细谈C语言中的main返回值</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/04/Review/数据库索引、主键、约束/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/04/Review/数据库索引、主键、约束/" itemprop="url">数据库索引、主键、约束</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-04T14:50:17+08:00">
                2018-03-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4>参考以下博文：</h4>
<ul>
<li><a href="https://www.jianshu.com/p/394f8aa724f4" target="_blank" rel="external">SQL的主键和外键的作用</a></li>
<li><a href="http://blog.csdn.net/wushuang5566110/article/details/8069997" target="_blank" rel="external">主键约束和唯一性约束的区别</a></li>
<li><a href="http://blog.csdn.net/suifeng3051/article/details/52669644" target="_blank" rel="external">数据库索引原理及优化</a></li>
<li><a href="http://www.runoob.com/mysql/mysql-index.html" target="_blank" rel="external">MySQL 索引</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/04/Review/TCP三次握手与四次挥手分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/04/Review/TCP三次握手与四次挥手分析/" itemprop="url">TCP三次握手与四次挥手分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-04T14:50:17+08:00">
                2018-03-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4>参考以下博文：</h4>
<ul>
<li><a href="http://www.cnblogs.com/kesal/p/3285415.html" target="_blank" rel="external">TCP\IP三次握手连接，四次握手断开分析</a></li>
<li><a href="http://www.cnblogs.com/tonyluis/p/5729531.html" target="_blank" rel="external">TCP三次握手与四次挥手</a></li>
<li><a href="http://www.cnblogs.com/newwy/p/3234536.html" target="_blank" rel="external">TCP连接的建立与终止</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/22/C++/C++常见语法错误：cannot have cv-qualifier/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/22/C++/C++常见语法错误：cannot have cv-qualifier/" itemprop="url">C++常见语法错误：cannot have cv-qualifier</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-22T19:22:39+08:00">
                2018-02-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在C++中CV指const和volatile</p>
<ol>
<li>
<p>非成员函数不能有CV限定，友元函数不是类的成员函数声明友元函数不能用const限定。
friend voin fun(classname &amp;ref)const;
//编译器会给错误error: non-member function ‘xxxxxxxxx’ cannot have cv-qualifier</p>
</li>
<li>
<p>静态成员函数不能有CV限定</p>
</li>
</ol>
<h4>在C++中，非成员函数不能含有CV限定，即const和volatile限定</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">0.0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> arg,<span class="keyword">char</span> *argv[])</span> </span>&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; getArea() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译产生错误:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">test.cpp	[Error] non-member function 'double getArea()'</div><div class="line">cannot have cv-qualifier//不能有CV限定，非成员函数不能有cv限定符。</div></pre></td></tr></table></figure>
<h4>在C++中，静态成员函数不能有CV限定，即const和volatile限定</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> CStatic &#123;</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		<span class="keyword">static</span> <span class="keyword">int</span> static_value;</div><div class="line"></div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_static_value</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">		<span class="comment">//当不是static方法时，可以用const进行限定。</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> CStatic::get_static_value() <span class="keyword">const</span> &#123;</div><div class="line">	<span class="keyword">return</span> static_value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> CStatic::static_value = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> </span>&#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; CStatic::get_static_value()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译出现的错误:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[Error] static member function 'static int CStatic::get_static_value()' </div><div class="line">cannot have cv-qualifier</div></pre></td></tr></table></figure>
<h4>友元函数同普通函数一样</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Animal &#123;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">showRes</span><span class="params">(Animal &amp;ref)</span><span class="keyword">const</span></span>;</div><div class="line">		<span class="comment">//这行编译器会给错误non-member function ‘void showRes(Animal&amp;)’</span></div><div class="line">		<span class="comment">//cannot have cv-qualifier</span></div><div class="line"></div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		<span class="keyword">int</span> age;</div><div class="line">		<span class="built_in">string</span> name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">showRes</span><span class="params">(Animal &amp;ref)</span> </span>&#123;</div><div class="line">	ref.age=<span class="number">15</span>;</div><div class="line">	ref.name=<span class="string">"panda"</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; ref.age &lt;&lt; ref.name &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译出现的错误:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[Error] non-member function 'void showRes(Animal&amp;)' cannot have cv-qualifier</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/10/Other/正则表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/10/Other/正则表达式/" itemprop="url">正则表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-10T23:55:41+08:00">
                2018-02-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>参考文档：</strong></p>
<ul>
<li><a href="http://www.regexlab.com/zh/regref.htm" target="_blank" rel="external">揭开正则表达式的神秘面纱</a></li>
</ul>
<h3>1. 正则表达式规则</h3>
<h4>1.1 普通字符</h4>
<p>字母、数字、汉字、下划线、以及后边章节中没有特殊定义的标点符号，都是&quot;普通字符&quot;。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。</p>
<p>举例1：表达式 &quot;c&quot;，在匹配字符串 &quot;abcde&quot; 时，匹配结果是：成功；匹配到的内容是：&quot;c&quot;；匹配到的位置是：开始于2，结束于3。（注：下标从0开始还是从1开始，因当前编程语言的不同而可能不同）</p>
<p>举例2：表达式 &quot;bcd&quot;，在匹配字符串 &quot;abcde&quot; 时，匹配结果是：成功；匹配到的内容是：&quot;bcd&quot;；匹配到的位置是：开始于1，结束于4。</p>
<h4>1.2 简单的转义字符</h4>
<p>一些不便书写的字符，采用在前面加 &quot;&quot; 的方法。这些字符其实我们都已经熟知了。</p>
<p>表达式 可匹配</p>
<p>\r, \n  代表回车和换行符</p>
<p>\t  制表符</p>
<p>\  代表 &quot;&quot; 本身</p>
<p>还有其他一些在后边章节中有特殊用处的标点符号，在前面加 &quot;&quot; 后，就代表该符号本身。比如：^, $ 都有特殊意义，如果要想匹配字符串中 &quot;^&quot; 和 &quot;$&quot; 字符，则表达式就需要写成 &quot;^&quot; 和 &quot;$&quot;。</p>
<p>表达式 可匹配</p>
<p>^  匹配 ^ 符号本身</p>
<p>$  匹配 $ 符号本身</p>
<p>.  匹配小数点（.）本身</p>
<p>这些转义字符的匹配方法与 &quot;普通字符&quot; 是类似的。也是匹配与之相同的一个字符。</p>
<p>举例1：表达式 &quot;$d&quot;，在匹配字符串 &quot;abc$de&quot; 时，匹配结果是：成功；匹配到的内容是：&quot;$d&quot;；匹配到的位置是：开始于3，结束于5。</p>
<h4>1.3 能够与 '多种字符' 匹配的表达式</h4>
<p>正则表达式中的一些表示方法，可以匹配 '多种字符' 其中的任意一个字符。比如，表达式 &quot;\d&quot; 可以匹配任意一个数字。虽然可以匹配其中任意字符，但是只能是一个，不是多个。这就好比玩扑克牌时候，大小王可以代替任意一张牌，但是只能代替一张牌。</p>
<p>表达式 可匹配</p>
<p>\d  任意一个数字，0~9 中的任意一个</p>
<p>\w  任意一个字母或数字或下划线，也就是 A~Z,a~z,0~9,_ 中任意一个</p>
<p>\s  包括空格、制表符、换页符等空白字符的其中任意一个</p>
<p>.   小数点可以匹配除了换行符（\n）以外的任意一个字符</p>
<p>举例1：表达式 &quot;\d\d&quot;，在匹配 &quot;abc123&quot; 时，匹配的结果是：成功；匹配到的内容是：&quot;12&quot;；匹配到的位置是：开始于3，结束于5。</p>
<p>举例2：表达式 &quot;a.\d&quot;，在匹配 &quot;aaa100&quot; 时，匹配的结果是：成功；匹配到的内容是：&quot;aa1&quot;；匹配到的位置是：开始于1，结束于4。</p>
<h4>1.4 自定义能够匹配 '多种字符' 的表达式</h4>
<p>使用方括号 [ ] 包含一系列字符，能够匹配其中任意一个字符。用 [^ ] 包含一系列字符，则能够匹配其中字符之外的任意一个字符。同样的道理，虽然可以匹配其中任意一个，但是只能是一个，不是多个。</p>
<p>表达式 可匹配</p>
<p>[ab5@]  匹配 &quot;a&quot; 或 &quot;b&quot; 或 &quot;5&quot; 或 &quot;@&quot;</p>
<p>[^abc]  匹配 &quot;a&quot;,&quot;b&quot;,&quot;c&quot; 之外的任意一个字符</p>
<p>[f-k]   匹配 &quot;f&quot;~&quot;k&quot; 之间的任意一个字母</p>
<p>[^A-F0-3] 匹配 &quot;A&quot;~&quot;F&quot;,&quot;0&quot;~&quot;3&quot; 之外的任意一个字符</p>
<p>举例1：表达式 &quot;[bcd][bcd]&quot; 匹配 &quot;abc123&quot; 时，匹配的结果是：成功；匹配到的内容是：&quot;bc&quot;；匹配到的位置是：开始于1，结束于3。</p>
<p>举例2：表达式 &quot;[^abc]&quot; 匹配 &quot;abc123&quot; 时，匹配的结果是：成功；匹配到的内容是：&quot;1&quot;；匹配到的位置是：开始于3，结束于4。</p>
<h4>1.5 修饰匹配次数的特殊符号</h4>
<p>前面章节中讲到的表达式，无论是只能匹配一种字符的表达式，还是可以匹配多种字符其中任意一个的表达式，都只能匹配一次。如果使用表达式再加上修饰匹配次数的特殊符号，那么不用重复书写表达式就可以重复匹配。</p>
<p>使用方法是：&quot;次数修饰&quot;放在&quot;被修饰的表达式&quot;后边。比如：&quot;[bcd][bcd]&quot; 可以写成 &quot;[bcd]{2}&quot;。</p>
<p>表达式 作用</p>
<p>{n}   表达式重复n次，比如：&quot;\w{2}&quot; 相当于 &quot;\w\w&quot;；&quot;a{5}&quot; 相当于 &quot;aaaaa&quot;</p>
<p>{m,n} 表达式至少重复m次，最多重复n次，比如：&quot;ba{1,3}&quot;可以匹配 &quot;ba&quot;或&quot;baa&quot;或&quot;baaa&quot;</p>
<p>{m,}  表达式至少重复m次，比如：&quot;\w\d{2,}&quot;可以匹配 &quot;a12&quot;,&quot;_456&quot;,&quot;M12344&quot;...</p>
<p>?   匹配表达式0次或者1次，相当于 {0,1}，比如：&quot;a[cd]?&quot;可以匹配 &quot;a&quot;,&quot;ac&quot;,&quot;ad&quot;</p>
<p>+  表达式至少出现1次，相当于 {1,}，比如：&quot;a+b&quot;可以匹配 &quot;ab&quot;,&quot;aab&quot;,&quot;aaab&quot;...</p>
<p>*  表达式不出现或出现任意次，相当于 {0,}，比如：&quot;^*b&quot;可以匹配 &quot;b&quot;,&quot;^^^b&quot;...</p>
<p>举例1：表达式 &quot;\d+.?\d*&quot; 在匹配 &quot;It costs $12.5&quot; 时，匹配的结果是：成功；匹配到的内容是：&quot;12.5&quot;；匹配到的位置是：开始于10，结束于14。</p>
<p>举例2：表达式 &quot;go{2,8}gle&quot; 在匹配 &quot;Ads by goooooogle&quot; 时，匹配的结果是：成功；匹配到的内容是：&quot;goooooogle&quot;；匹配到的位置是：开始于7，结束于17。</p>
<h4>1.6 其他一些代表抽象意义的特殊符号</h4>
<p>一些符号在表达式中代表抽象的特殊意义：</p>
<p>表达式   作用</p>
<p>^   与字符串开始的地方匹配，不匹配任何字符</p>
<p>$   与字符串结束的地方匹配，不匹配任何字符</p>
<p>\b  匹配一个单词边界，也就是单词和空格之间的位置，不匹配任何字符</p>
<p>进一步的文字说明仍然比较抽象，因此，举例帮助大家理解。</p>
<p>举例1：表达式 &quot;^aaa&quot; 在匹配 &quot;xxx aaa xxx&quot; 时，匹配结果是：失败。因为 &quot;^&quot; 要求与字符串开始的地方匹配，因此，只有当 &quot;aaa&quot; 位于字符串的开头的时候，&quot;^aaa&quot; 才能匹配，比如：&quot;aaa xxx xxx&quot;。</p>
<p>举例2：表达式 &quot;aaa$&quot; 在匹配 &quot;xxx aaa xxx&quot; 时，匹配结果是：失败。因为 &quot;$&quot; 要求与字符串结束的地方匹配，因此，只有当 &quot;aaa&quot; 位于字符串的结尾的时候，&quot;aaa$&quot; 才能匹配，比如：&quot;xxx xxx aaa&quot;。</p>
<p>举例3：表达式 &quot;.\b.&quot; 在匹配 &quot;@@@abc&quot; 时，匹配结果是：成功；匹配到的内容是：&quot;@a&quot;；匹配到的位置是：开始于2，结束于4。
进一步说明：&quot;\b&quot; 与 &quot;^&quot; 和 &quot;$&quot; 类似，本身不匹配任何字符，但是它要求它在匹配结果中所处位置的左右两边，其中一边是 &quot;\w&quot; 范围，另一边是 非&quot;\w&quot; 的范围。</p>
<p>举例4：表达式 &quot;\bend\b&quot; 在匹配 &quot;weekend,endfor,end&quot; 时，匹配结果是：成功；匹配到的内容是：&quot;end&quot;；匹配到的位置是：开始于15，结束于18。</p>
<p>一些符号可以影响表达式内部的子表达式之间的关系：</p>
<p>表达式   作用</p>
<p>|   左右两边表达式之间 &quot;或&quot; 关系，匹配左边或者右边</p>
<p>( ) (1). 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰   (2). 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到</p>
<p>举例5：表达式 &quot;Tom|Jack&quot; 在匹配字符串 &quot;I'm Tom, he is Jack&quot; 时，匹配结果是：成功；匹配到的内容是：&quot;Tom&quot;；匹配到的位置是：开始于4，结束于7。匹配下一个时，匹配结果是：成功；匹配到的内容是：&quot;Jack&quot;；匹配到的位置时：开始于15，结束于19。</p>
<p>举例6：表达式 &quot;(go\s*)+&quot; 在匹配 &quot;Let's go go go!&quot; 时，匹配结果是：成功；匹配到内容是：&quot;go go go&quot;；匹配到的位置是：开始于6，结束于14。</p>
<p>举例7：表达式 &quot;￥(\d+.?\d*)&quot; 在匹配 &quot;＄10.9,￥20.5&quot; 时，匹配的结果是：成功；匹配到的内容是：&quot;￥20.5&quot;；匹配到的位置是：开始于6，结束于10。单独获取括号范围匹配到的内容是：&quot;20.5&quot;。</p>
<h3>2. 正则表达式中的一些高级规则</h3>
<h4>2.1 匹配次数中的贪婪与非贪婪</h4>
<p>在使用修饰匹配次数的特殊符号时，有几种表示方法可以使同一个表达式能够匹配不同的次数，比如：&quot;{m,n}&quot;, &quot;{m,}&quot;, &quot;?&quot;, &quot;*&quot;, &quot;+&quot;，具体匹配的次数随被匹配的字符串而定。这种重复匹配不定次数的表达式在匹配过程中，总是尽可能多的匹配。比如，针对文本 &quot;dxxxdxxxd&quot;，举例如下：</p>
<p>表达式   匹配结果</p>
<p>(d)(\w+)  &quot;\w+&quot; 将匹配第一个 &quot;d&quot; 之后的所有字符 &quot;xxxdxxxd&quot;</p>
<p>(d)(\w+)(d)   &quot;\w+&quot; 将匹配第一个 &quot;d&quot; 和最后一个 &quot;d&quot; 之间的所有字符 &quot;xxxdxxx&quot;。虽然 &quot;\w+&quot; 也能够匹配上最后一个 &quot;d&quot;，但是为了使整个表达式匹配成功，&quot;\w+&quot; 可以 &quot;让出&quot; 它本来能够匹配的最后一个 &quot;d&quot;</p>
<p>由此可见，&quot;\w+&quot; 在匹配的时候，总是尽可能多的匹配符合它规则的字符。虽然第二个举例中，它没有匹配最后一个 &quot;d&quot;，但那也是为了让整个表达式能够匹配成功。同理，带 &quot;*&quot; 和 &quot;{m,n}&quot; 的表达式都是尽可能地多匹配，带 &quot;?&quot; 的表达式在可匹配可不匹配的时候，也是尽可能的 &quot;要匹配&quot;。这 种匹配原则就叫作 &quot;贪婪&quot; 模式 。</p>
<p>非贪婪模式：</p>
<p>在修饰匹配次数的特殊符号后再加上一个 &quot;?&quot; 号，则可以使匹配次数不定的表达式尽可能少的匹配，使可匹配可不匹配的表达式，尽可能的 &quot;不匹配&quot;。这种匹配原则叫作 &quot;非贪婪&quot; 模式，也叫作 &quot;勉强&quot; 模式。如果少匹配就会导致整个表达式匹配失败的时候，与贪婪模式类似，非贪婪模式会最小限度的再匹配一些，以使整个表达式匹配成功。举例如下，针对文本 &quot;dxxxdxxxd&quot; 举例：</p>
<p>表达式   匹配结果</p>
<p>(d)(\w+?)   &quot;\w+?&quot; 将尽可能少的匹配第一个 &quot;d&quot; 之后的字符，结果是：&quot;\w+?&quot; 只匹配了一个 &quot;x&quot;</p>
<p>(d)(\w+?)(d)  为了让整个表达式匹配成功，&quot;\w+?&quot; 不得不匹配 &quot;xxx&quot; 才可以让后边的 &quot;d&quot; 匹配，从而使整个表达式匹配成功。因此，结果是：&quot;\w+?&quot; 匹配 &quot;xxx&quot;</p>
<p>更多的情况，举例如下：</p>
<p>举例1：表达式 &quot;<td>(.*)</td>&quot; 与字符串 &quot;<td><p>aa</p></td> <td><p>bb</p></td>&quot; 匹配时，匹配的结果是：成功；匹配到的内容是 &quot;<td><p>aa</p></td> <td><p>bb</p></td>&quot; 整个字符串， 表达式中的 &quot;&quot; 将与字符串中最后一个 &quot;&quot; 匹配。</p>
<p>举例2：相比之下，表达式 &quot;<td>(.*?)</td>&quot; 匹配举例1中同样的字符串时，将只得到 &quot;<td><p>aa</p></td>&quot;， 再次匹配下一个时，可以得到第二个 &quot;<td><p>bb</p></td>&quot;。</p>
<h4>2.2 反向引用 \1, \2...</h4>
<p>表达式在匹配时，表达式引擎会将小括号 &quot;( )&quot; 包含的表达式所匹配到的字符串记录下来。在获取匹配结果的时候，小括号包含的表达式所匹配到的字符串可以单独获取。这一点，在前面的举例中，已经多次展示了。在实际应用场合中，当用某种边界来查找，而所要获取的内容又不包含边界时，必须使用小括号来指定所要的范围。比如前面的 &quot;<td>(.*?)</td>&quot;。</p>
<p>其实，&quot;小括号包含的表达式所匹配到的字符串&quot; 不仅是在匹配结束后才可以使用，在匹配过程中也可以使用。表达式后边的部分，可以引用前面 &quot;括号内的子匹配已经匹配到的字符串&quot;。引用方法是 &quot;&quot; 加上一个数字。&quot;\1&quot; 引用第1对括号内匹配到的字符串，&quot;\2&quot; 引用第2对括号内匹配到的字符串……以此类推，如果一对括号内包含另一对括号，则外层的括号先排序号。换句话说，哪一对的左括号 &quot;(&quot; 在前，那这一对就先排序号。</p>
<p>举例如下：</p>
<p>举例1：表达式 &quot;('|&quot;)(.*?)(\1)&quot; 在匹配 &quot; 'Hello', &quot;World&quot; &quot; 时，匹配结果是：成功；匹配到的内容是：&quot; 'Hello' &quot;。再次匹配下一个时，可以匹配到 &quot; &quot;World&quot; &quot;。</p>
<p>举例2：表达式 &quot;(\w)\1{4,}&quot; 在匹配 &quot;aa bbbb abcdefg ccccc 111121111 999999999&quot; 时，匹配结果是：成功；匹配到的内容是 &quot;ccccc&quot;。再次匹配下一个时，将得到 999999999。这个表达式要求 &quot;\w&quot; 范围的字符至少重复5次，注意与 &quot;\w{5,}&quot; 之间的区别。</p>
<p>举例3：表达式 &quot;&lt;(\w+)\s*(\w+(=('|&quot;).<em>?\4)?\s</em>)<em>&gt;.</em>?&lt;/\1&gt;&quot; 在匹配 &quot;<td id="td1" style="bgcolor:white"></td>&quot; 时，匹配结果是成功。如果 &quot;<td>&quot; 与 &quot;</td>&quot; 不配对，则会匹配失败；如果改成其他配对，也可以匹配成功。</p>
<h4>2.3 预搜索，不匹配；反向预搜索，不匹配</h4>
<p>前面的章节中，我讲到了几个代表抽象意义的特殊符号：&quot;^&quot;，&quot;$&quot;，&quot;\b&quot;。它们都有一个共同点，那就是：它们本身不匹配任何字符，只是对 &quot;字符串的两头&quot; 或者 &quot;字符之间的缝隙&quot; 附加了一个条件。理解到这个概念以后，本节将继续介绍另外一种对 &quot;两头&quot; 或者 &quot;缝隙&quot; 附加条件的，更加灵活的表示方法。</p>
<p>正向预搜索：&quot;(?=xxxxx)&quot;，&quot;(?!xxxxx)&quot;</p>
<p>格式：&quot;(?=xxxxx)&quot;，在被匹配的字符串中，它对所处的 &quot;缝隙&quot; 或者 &quot;两头&quot; 附加的条件是：所在缝隙的右侧，必须能够匹配上 xxxxx 这部分的表达式。因为它只是在此作为这个缝隙上附加的条件，所以它并不影响后边的表达式去真正匹配这个缝隙之后的字符。这就类似 &quot;\b&quot;，本身不匹配任何字符。&quot;\b&quot; 只是将所在缝隙之前、之后的字符取来进行了一下判断，不会影响后边的表达式来真正的匹配。</p>
<p>举例1：表达式 &quot;Windows (?=NT|XP)&quot; 在匹配 &quot;Windows 98, Windows NT, Windows 2000&quot; 时，将只匹配 &quot;Windows NT&quot; 中的 &quot;Windows &quot;，其他的 &quot;Windows &quot; 字样则不被匹配。</p>
<p>举例2：表达式 &quot;(\w)((?=\1\1\1)(\1))+&quot; 在匹配字符串 &quot;aaa ffffff 999999999&quot; 时，将可以匹配6个&quot;f&quot;的前4个，可以匹配9个&quot;9&quot;的前7个。这个表达式可以读解成：重复4次以上的字母数字，则匹配其剩下最后2位之前的部分。当然，这个表达式可以不这样写，在此的目的是作为演示之用。</p>
<p>格式：&quot;(?!xxxxx)&quot;，所在缝隙的右侧，必须不能匹配 xxxxx 这部分表达式。</p>
<p>举例3：表达式 &quot;((?!\bstop\b).)+&quot; 在匹配 &quot;fdjka ljfdl stop fjdsla fdj&quot; 时，将从头一直匹配到 &quot;stop&quot; 之前的位置，如果字符串中没有 &quot;stop&quot;，则匹配整个字符串。</p>
<p>举例4：表达式 &quot;do(?!\w)&quot; 在匹配字符串 &quot;done, do, dog&quot; 时，只能匹配 &quot;do&quot;。在本条举例中，&quot;do&quot; 后边使用 &quot;(?!\w)&quot; 和使用 &quot;\b&quot; 效果是一样的。</p>
<p>反向预搜索：&quot;(?&lt;=xxxxx)&quot;，&quot;(?&lt;!xxxxx)&quot;</p>
<p>这两种格式的概念和正向预搜索是类似的，反向预搜索要求的条件是：所在缝隙的 &quot;左侧&quot;，两种格式分别要求必须能够匹配和必须不能够匹配指定表达式，而不是去判断右侧。与 &quot;正向预搜索&quot; 一样的是：它们都是对所在缝隙的一种附加条件，本身都不匹配任何字符。</p>
<p>举例5：表达式 &quot;(?&lt;=\d{4})\d+(?=\d{4})&quot; 在匹配 &quot;1234567890123456&quot; 时，将匹配除了前4个数字和后4个数字之外的中间8个数字。由于 JScript.RegExp 不支持反向预搜索，因此，本条举例不能够进行演示。很多其他的引擎可以支持反向预搜索，比如：Java 1.4 以上的 java.util.regex 包，.NET 中System.Text.RegularExpressions 命名空间，以及本站推荐的最简单易用的 DEELX 正则引擎。</p>
<h3>3. 其他通用规则</h3>
<p>还有一些在各个正则表达式引擎之间比较通用的规则，在前面的讲解过程中没有提到。</p>
<h4>3.1 表达式中，可以使用 &quot;\xXX&quot; 和 &quot;\uXXXX&quot; 表示一个字符（&quot;X&quot; 表示一个十六进制数）</h4>
<p>形式    字符范围</p>
<p>\xXX  编号在  ~ 255 范围的字符，比如：空格可以使用 &quot;\x20&quot; 表示</p>
<p>\uXXXX  任何字符可以使用 &quot;\u&quot; 再加上其编号的4位十六进制数表示，比如：&quot;\u4E2D&quot;</p>
<h4>3.2 在表达式 &quot;\s&quot;，&quot;\d&quot;，&quot;\w&quot;，&quot;\b&quot; 表示特殊意义的同时，对应的大写字母表示相反的意义</h4>
<p>表达式   可匹配</p>
<p>\S    匹配所有非空白字符（&quot;\s&quot; 可匹配各个空白字符）</p>
<p>\D    匹配所有的非数字字符</p>
<p>\W    匹配所有的字母、数字、下划线以外的字符</p>
<p>\B    匹配非单词边界，即左右两边都是 &quot;\w&quot; 范围或者左右两边都不是 &quot;\w&quot; 范围时的字符缝隙</p>
<h4>3.3 在表达式中有特殊意义，需要添加 &quot;&quot; 才能匹配该字符本身的字符汇总</h4>
<p>字符  说明</p>
<p>^   匹配输入字符串的开始位置。要匹配 &quot;^&quot; 字符本身，请使用 &quot;^&quot;</p>
<p>$   匹配输入字符串的结尾位置。要匹配 &quot;$&quot; 字符本身，请使用 &quot;$&quot;</p>
<p>( ) 标记一个子表达式的开始和结束位置。要匹配小括号，请使用 &quot;(&quot; 和 &quot;)&quot;</p>
<p>[ ] 用来自定义能够匹配 '多种字符' 的表达式。要匹配中括号，请使用 &quot;[&quot; 和 &quot;]&quot;</p>
<p>{ } 修饰匹配次数的符号。要匹配大括号，请使用 &quot;{&quot; 和 &quot;}&quot;</p>
<p>.   匹配除了换行符（\n）以外的任意一个字符。要匹配小数点本身，请使用 &quot;.&quot;</p>
<p>?   修饰匹配次数为 0 次或 1 次。要匹配 &quot;?&quot; 字符本身，请使用 &quot;?&quot;</p>
<p>+  修饰匹配次数为至少 1 次。要匹配 &quot;+&quot; 字符本身，请使用 &quot;+&quot;</p>
<p>*  修饰匹配次数为 0 次或任意次。要匹配 &quot;*&quot; 字符本身，请使用 &quot;*&quot;</p>
<p>|   左右两边表达式之间 &quot;或&quot; 关系。匹配 &quot;|&quot; 本身，请使用 &quot;|&quot;</p>
<h4>3.4 括号 &quot;( )&quot; 内的子表达式，如果希望匹配结果不进行记录供以后使用，可以使用 &quot;(?:xxxxx)&quot; 格式</h4>
<p>举例1：表达式 &quot;(?:(\w)\1)+&quot; 匹配 &quot;a bbccdd efg&quot; 时，结果是 &quot;bbccdd&quot;。括号 &quot;(?:)&quot; 范围的匹配结果不进行记录，因此 &quot;(\w)&quot; 使用 &quot;\1&quot; 来引用。</p>
<h4>3.5 常用的表达式属性设置简介：Ignorecase，Singleline，Multiline，Global</h4>
<p>表达式属性   说明</p>
<p>Ignorecase  默认情况下，表达式中的字母是要区分大小写的。配置为 Ignorecase 可使匹配时不区分大小写。有的表达式引擎，把 &quot;大小写&quot; 概念延伸至 UNICODE 范围的大小写。</p>
<p>Singleline  默认情况下，小数点 &quot;.&quot; 匹配除了换行符（\n）以外的字符。配置为 Singleline 可使小数点可匹配包括换行符在内的所有字符。</p>
<p>Multiline   默认情况下，表达式 &quot;^&quot; 和 &quot;$&quot; 只匹配字符串的开始 ① 和结尾 ④ 位置。如：</p>
<p>①xxxxxxxxx②\n
③xxxxxxxxx④ 配置为 Multiline 可以使 &quot;^&quot; 匹配 ① 外，还可以匹配换行符之后，下一行开始前 ③ 的位置，使 &quot;$&quot; 匹配 ④ 外，还可以匹配换行符之前，一行结束 ② 的位置。</p>
<p>Global  主要在将表达式用来替换时起作用，配置为 Global 表示替换所有的匹配。</p>
<h3>4. 其他提示</h3>
<h4>4.1 如果想要了解高级的正则引擎还支持那些复杂的正则语法，可参见本站 DEELX 正则引擎的说明文档。</h4>
<h4>4.2 如果要要求表达式所匹配的内容是整个字符串，而不是从字符串中找一部分，那么可以在表达式的首尾使用 &quot;^&quot; 和 &quot;$&quot;，比如：&quot;^\d+$&quot; 要求整个字符串只有数字。</h4>
<h4>4.3 如果要求匹配的内容是一个完整的单词，而不会是单词的一部分，那么在表达式首尾使用 &quot;\b&quot;，比如：使用 &quot;\b(if|while|else|void|int……)\b&quot; 来匹配程序中的关键字。</h4>
<h4>4.4 表达式不要匹配空字符串。否则会一直得到匹配成功，而结果什么都没有匹配到。比如：准备写一个匹配 &quot;123&quot;、&quot;123.&quot;、&quot;123.5&quot;、&quot;.5&quot; 这几种形式的表达式时，整数、小数点、小数数字都可以省略，但是不要将表达式写成：&quot;\d*.?\d*&quot;，因为如果什么都没有，这个表达式也可以匹配成功。更好的写法是：&quot;\d+.?\d*|.\d+&quot;。</h4>
<h4>4.5 能匹配空字符串的子匹配不要循环无限次。如果括号内的子表达式中的每一部分都可以匹配 0 次，而这个括号整体又可以匹配无限次，那么情况可能比上一条所说的更严重，匹配过程中可能死循环。虽然现在有些正则表达式引擎已经通过办法避免了这种情况出现死循环了，比如 .NET 的正则表达式，但是我们仍然应该尽量避免出现这种情况。如果我们在写表达式时遇到了死循环，也可以从这一点入手，查找一下是否是本条所说的原因。</h4>
<h4>4.6 合理选择贪婪模式与非贪婪模式，参见话题讨论。</h4>
<h4>4.7 或 &quot;|&quot; 的左右两边，对某个字符最好只有一边可以匹配，这样，不会因为 &quot;|&quot; 两边的表达式因为交换位置而有所不同。</h4>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/08/Github/Github新建本地仓库并同步远程仓库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/08/Github/Github新建本地仓库并同步远程仓库/" itemprop="url">Github新建本地仓库并同步远程仓库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-08T21:09:20+08:00">
                2018-02-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3>如何直接在本地创建仓库并提交到远程仓库?</h3>
<p>前提：在github上手动创建仓库gitRepo，且没有其它任何提交，包括readme.md。</p>
<p><strong>步骤如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mkdir gitRepo #如果是已存在的工程项目，则直接cd到项目根目录下，不需要新建。</div><div class="line">cd gitRepo</div><div class="line">git init #初始化本地仓库</div><div class="line">git add xxx #添加要push到远程仓库的文件或文件夹</div><div class="line">git commit -m ‘first commit’</div><div class="line">git remote add origin https://github.com/yourgithubID/gitRepo.git #建立远程仓库</div><div class="line">git push -u origin master #将本地仓库push到远程仓库</div></pre></td></tr></table></figure>
<p><strong>有关问题：</strong></p>
<ul>
<li>
<p>如果没有创建gitRepo，则会报以下错误: <code>ERROR:Repository not found.</code></p>
</li>
<li>
<p>由于在github上手动创建的仓库包括：README.md文件，本地仓库没有此文件，则在执行git push -u origin master命令时报如下的错误: <code>ERROR:failed to push some refs to ...</code>
解决方法为：
第一步：可以通过如下命令进行代码合并[注：pull=fetch+merge]
<code>git pull --rebase origin master</code>
执行上面代码后可以看到本地代码库中多了README.md文件
第二步：此时再执行语句 <code>git push -u origin master</code>即可完成代码上传到github</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/07/Java/Spring MVC 常用注解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/07/Java/Spring MVC 常用注解/" itemprop="url">Spring MVC 常用注解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-07T15:13:41+08:00">
                2018-02-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3>@Controller</h3>
<p>在SpringMVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在SpringMVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。</p>
<p>@Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。</p>
<hr>
<h3>@RequestMapping</h3>
<p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<p>RequestMapping注解有六个属性，分成三类进行说明（下面有相应示例）。</p>
<p>1、 value， method；
value：     指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；
method：  指定请求的method类型， GET、POST、PUT、DELETE等；</p>
<p>2、consumes，produces
consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;
produces:    指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</p>
<p>3、params，headers
params： 指定request中必须包含某些参数值是，才让该方法处理。
headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p>
<h4>使用 @RequestMapping 来映射 Request 请求与处理器</h4>
<p>方式一、通过常见的类路径和方法路径结合访问controller方法
方式二、使用url模板</p>
<pre><code>@Controller
@RequestMapping ( &quot;/test/{variable1}&quot; )
public class MyController {

    @RequestMapping ( &quot;/showView/{variable2}&quot; )
    public ModelAndView showView( @PathVariable String variable1, @PathVariable ( &quot;variable2&quot; ) int variable2) {
       ModelAndView modelAndView = new ModelAndView();
       modelAndView.setViewName( &quot;viewName&quot; );
       modelAndView.addObject( &quot; 需要放到 model 中的属性名称 &quot; , &quot; 对应的属性值，它是一个对象 &quot; );
       return modelAndView;
    }
} 
</code></pre>
<p>URI 模板就是在URI 中给定一个变量，然后在映射的时候动态的给该变量赋值。如URI 模板http://localhost/app/{variable1}/index.html ，这个模板里面包含一个变量variable1 ，那么当我们请求http://localhost/app/hello/index.html 的时候，该URL 就跟模板相匹配，只是把模板中的variable1 用hello 来取代。这个变量在SpringMVC 中是使用@PathVariable 来标记的。在SpringMVC 中，我们可以使用@PathVariable 来标记一个Controller 的处理方法参数，表示该参数的值将使用URI 模板中对应的变量的值来赋值。</p>
<p>代码中我们定义了两个URI 变量，一个是控制器类上的variable1 ，一个是showView 方法上的variable2 ，然后在showView 方法的参数里面使用@PathVariable 标记使用了这两个变量。所以当我们使用/test/hello/showView/2.do 来请求的时候就可以访问到MyController 的showView 方法，这个时候variable1 就被赋予值hello ，variable2 就被赋予值2 ，然后我们在showView 方法参数里面标注了参数variable1 和variable2 是来自访问路径的path 变量，这样方法参数variable1 和variable2 就被分别赋予hello 和2 。方法参数variable1 是定义为String 类型，variable2 是定义为int 类型，像这种简单类型在进行赋值的时候Spring 是会帮我们自动转换的。</p>
<p>在标记variable1 为path 变量的时候我们使用的是@PathVariable ，而在标记variable2 的时候使用的是@PathVariable(“variable2”) 。这两者有什么区别呢？
第一种情况就默认去URI 模板中找跟参数名相同的变量，但是这种情况只有在使用debug 模式进行编译的时候才可以;
第二种情况是明确规定使用的就是URI 模板中的variable2 变量。当不是使用debug 模式进行编译，或者是所需要使用的变量名跟参数名不相同的时候，就要使用第二种方式明确指出使用的是URI 模板中的哪个变量。</p>
<h4>使用 @RequestMapping 的一些高级用法</h4>
<p>（1）params属性</p>
<pre><code>@RequestMapping (value= &quot;testParams&quot; , params={ &quot;param1=value1&quot; , &quot;param2&quot; , &quot;!param3&quot; })
    public String testParams() {
       System. out .println( &quot;test Params...........&quot; );
       return &quot;testParams&quot; ;
    }
</code></pre>
<p>用@RequestMapping 的params 属性指定了三个参数，这些参数都是针对请求参数而言的，它们分别表示参数param1 的值必须等于value1 ，参数param2 必须存在，值无所谓，参数param3 必须不存在，只有当请求/testParams.do 并且满足指定的三个参数条件的时候才能访问到该方法。所以当请求/testParams.do?param1=value1&amp;param2=value2 的时候能够正确访问到该testParams 方法，当请求/testParams.do?param1=value1&amp;param2=value2&amp;param3=value3 的时候就不能够正常的访问到该方法，因为在@RequestMapping 的params 参数里面指定了参数param3 是不能存在的。</p>
<p>（2）method属性</p>
<pre><code>@RequestMapping (value= &quot;testMethod&quot; , method={RequestMethod. GET , RequestMethod. DELETE })
    public String testMethod() {
       return &quot;method&quot; ;
    }
</code></pre>
<p>在上面的代码中就使用method 参数限制了以GET 或DELETE 方法请求/testMethod 的时候才能访问到该Controller 的testMethod 方法。</p>
<p>（3）headers属性</p>
<pre><code>@RequestMapping (value= &quot;testHeaders&quot; , headers={ &quot;host=localhost&quot; , &quot;Accept&quot; })
    public String testHeaders() {
       return &quot;headers&quot; ;
    }
</code></pre>
<p>headers 属性的用法和功能与params 属性相似。在上面的代码中当请求/testHeaders.do 的时候只有当请求头包含Accept 信息，且请求的host 为localhost 的时候才能正确的访问到testHeaders 方法。</p>
<h4>@RequestMapping 标记的处理器方法支持的方法参数和返回类型</h4>
<ol>
<li>
<p>支持的方法参数类型
（1）HttpServlet 对象，主要包括HttpServletRequest 、HttpServletResponse 和HttpSession 对象。 这些参数Spring 在调用处理器方法的时候会自动给它们赋值，所以当在处理器方法中需要使用到这些对象的时候，可以直接在方法上给定一个方法参数的申明，然后在方法体里面直接用就可以了。但是有一点需要注意的是在使用HttpSession 对象的时候，如果此时HttpSession 对象还没有建立起来的话就会有问题。
（2）Spring 自己的WebRequest 对象。 使用该对象可以访问到存放在HttpServletRequest 和HttpSession 中的属性值。
（3）InputStream 、OutputStream 、Reader 和Writer 。 InputStream 和Reader 是针对HttpServletRequest 而言的，可以从里面取数据；OutputStream 和Writer 是针对HttpServletResponse 而言的，可以往里面写数据。
（4）使用@PathVariable 、@RequestParam 、@CookieValue 和@RequestHeader 标记的参数。
（5）使用@ModelAttribute 标记的参数。
（6）java.util.Map 、Spring 封装的Model 和ModelMap 。 这些都可以用来封装模型数据，用来给视图做展示。
（7）实体类。 可以用来接收上传的参数。
（8）Spring 封装的MultipartFile 。 用来接收上传文件的。
（9）Spring 封装的Errors 和BindingResult 对象。 这两个对象参数必须紧接在需要验证的实体对象参数之后，它里面包含了实体对象的验证结果。</p>
</li>
<li>
<p>支持的返回类型
（1）一个包含模型和视图的ModelAndView 对象。
（2）一个模型对象，这主要包括Spring 封装好的Model 和ModelMap ，以及java.util.Map ，当没有视图返回的时候视图名称将由RequestToViewNameTranslator 来决定。
（3）一个View 对象。这个时候如果在渲染视图的过程中模型的话就可以给处理器方法定义一个模型参数，然后在方法体里面往模型中添加值。
（4）一个String 字符串。这往往代表的是一个视图名称。这个时候如果需要在渲染视图的过程中需要模型的话就可以给处理器方法一个模型参数，然后在方法体里面往模型中添加值就可以了。
（5）返回值是void 。这种情况一般是我们直接把返回结果写到HttpServletResponse 中了，如果没有写的话，那么Spring 将会利用RequestToViewNameTranslator 来返回一个对应的视图名称。如果视图中需要模型的话，处理方法与返回字符串的情况相同。
（6）如果处理器方法被注解@ResponseBody 标记的话，那么处理器方法的任何返回类型都会通过HttpMessageConverters 转换之后写到HttpServletResponse 中，而不会像上面的那些情况一样当做视图或者模型来处理。
（7）除以上几种情况之外的其他任何返回类型都会被当做模型中的一个属性来处理，而返回的视图还是由RequestToViewNameTranslator 来决定，添加到模型中的属性名称可以在该方法上用@ModelAttribute(“attributeName”) 来定义，否则将使用返回类型的类名称的首字母小写形式来表示。使用@ModelAttribute 标记的方法会在@RequestMapping 标记的方法执行之前执行。</p>
</li>
</ol>
<hr>
<h3>@Resource和@Autowired</h3>
<p>@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p>
<p>1、共同点
两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p>
<p>2、不同点</p>
<p>（1）@Autowired</p>
<p>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p>
<pre><code>public class TestServiceImpl {
    // 下面两种@Autowired只要使用一种即可
    @Autowired
    private UserDao userDao; // 用于字段上
    
    @Autowired
    public void setUserDao(UserDao userDao) { // 用于属性的方法上
        this.userDao = userDao;
    }
}
</code></pre>
<p>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。如下：</p>
<pre><code>public class TestServiceImpl {
    @Autowired
    @Qualifier(&quot;userDao&quot;)
    private UserDao userDao; 
}
</code></pre>
<p>（2）@Resource</p>
<p>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p>
<pre><code>public class TestServiceImpl {
    // 下面两种@Resource只要使用一种即可
    @Resource(name=&quot;userDao&quot;)
    private UserDao userDao; // 用于字段上
    
    @Resource(name=&quot;userDao&quot;)
    public void setUserDao(UserDao userDao) { // 用于属性的setter方法上
        this.userDao = userDao;
    }
}
</code></pre>
<p>注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。</p>
<p>@Resource装配顺序：</p>
<p>①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。
②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。
③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。
④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。
@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。</p>
<hr>
<h3>@ModelAttribute和 @SessionAttributes</h3>
<p>@ModelAttribute代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。</p>
<p>@SessionAttributes即将值放到session作用域中，写在class上面。</p>
<hr>
<h3>@PathVariable</h3>
<p>用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数。如：</p>
<pre><code>@Controller  
public class TestController {  
     @RequestMapping(value=&quot;/user/{userId}/roles/{roleId}&quot;,method = RequestMethod.GET)  
     public String getLogin(@PathVariable(&quot;userId&quot;) String userId,  
         @PathVariable(&quot;roleId&quot;) String roleId){  
         System.out.println(&quot;User Id : &quot; + userId);  
         System.out.println(&quot;Role Id : &quot; + roleId);  
         return &quot;hello&quot;;  
     }  
     @RequestMapping(value=&quot;/product/{productId}&quot;,method = RequestMethod.GET)  
     public String getProduct(@PathVariable(&quot;productId&quot;) String productId){  
           System.out.println(&quot;Product Id : &quot; + productId);  
           return &quot;hello&quot;;  
     }  
     @RequestMapping(value=&quot;/javabeat/{regexp1:[a-z-]+}&quot;,  
           method = RequestMethod.GET)  
     public String getRegExp(@PathVariable(&quot;regexp1&quot;) String regexp1){  
           System.out.println(&quot;URI Part 1 : &quot; + regexp1);  
           return &quot;hello&quot;;  
     }  
}
</code></pre>
<hr>
<h3>@requestParam</h3>
<p>@requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(&quot;name&quot;)，它有三个常用参数：defaultValue = &quot;0&quot;, required = false, value = &quot;isApp&quot;；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。</p>
<hr>
<h3>@ResponseBody</h3>
<p>作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。</p>
<p>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；</p>
<hr>
<h3>@Component</h3>
<p>相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。</p>
<hr>
<h3>@Repository</h3>
<p>用于注解dao层，在daoImpl类上面注解。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/05/Linux/Linux 局域网localhost/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/05/Linux/Linux 局域网localhost/" itemprop="url">Linux 局域网localhost</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-05T16:01:29+08:00">
                2018-02-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>背景：有一个部署在Linux虚拟机中的web应用，但是虚拟机没有安装图形界面只有字符界面，Linux作为服务器部署web应用，但是不能通过其自身localhost访问，不方便调试，如何能够让主机通过访问Linux虚拟机的局域网IP+端口访问web应用呢？</p>
<p>步骤如下：</p>
<p>Linux虚拟机为NAT或桥接模式，确保主机能够ping通；</p>
<pre><code># vi /etc/hosts
  127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4  
  ::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
</code></pre>
<p>修改为：</p>
<pre><code>  192.168.80.21   localhost localhost.localdomain localhost4 localhost4.localdomain4
  ::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
</code></pre>
<p>其中192.168.80.21是Linux虚拟机的局域网IP;</p>
<p>将web应用部署在localhost中；</p>
<p>打开主机浏览器，输入192.168.80.21:端口 即可访问；</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/05/Linux/Linux shell 脚本参数传递/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/05/Linux/Linux shell 脚本参数传递/" itemprop="url">Linux shell 脚本参数传递</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-05T10:59:19+08:00">
                2018-02-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 Shell中，调用函数时可以向其传递参数。在函数体内部，通过 n的形式来获取参数的值，例如，1 表示第一个参数，$2 表示第二个参数...</p>
<p>特殊变量	说明
<code>$0</code> 当前脚本文件名
<code>$n</code> 传递给脚本或函数的参数，n是一个数字，表示第几个参数，$1表示第一个参数，$2表示第二个参数 ...
<code>$#</code> 传递给脚本或函数的参数个数
<code>$*</code> 传递给脚本或函数的所有参数，当它被双引号（&quot; &quot;）包含时，<code>&quot;$*&quot;</code> 会将所有的参数作为一个整体，以<code>&quot;$1 $2 ... $n&quot;</code>的形式输出所有参数
<code>$@</code> 传递给脚本或函数的所有参数，当它被双引号（&quot; &quot;）包含时，与<code>$*</code>稍有不同，<code>&quot;$@&quot;</code> 会将各个参数分开，以<code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;</code> 的形式输出所有参数
<code>$*</code>和<code>$@</code>不被双引号(&quot; &quot;)包含时，都以<code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;</code> 的形式输出所有参数</p>
<p>另外还有：
<code>$?</code> 上一个命令的退出状态，或函数的返回值，如果正常退出则返回0，反之为非0值
<code>$$</code> 当前shell进程pid，对于shell脚本，就是这些脚本所在的进程ID
<code>$!</code> 上一个命令的pid</p>
<p>写一个测试脚本：
#!/bin/bash
echo &quot;$<em>=&quot; $</em>
echo &quot;$@=&quot; $@</p>
<pre><code>echo &quot;print each param from \$*&quot; 
for var in $*
do
    echo $var
done

echo &quot;print each param from \$@&quot;
for var in $@
do
    echo $var
done

echo &quot;print each param from \&quot;\$*\&quot;&quot;
for var in &quot;$*&quot;
do
    echo $var
done

echo &quot;print each param from \&quot;\$@\&quot;&quot;
for var in &quot;$@&quot;
do
    echo $var
done
</code></pre>
<p>结果如下：
# sh test.sh a b c d
$<em>= a b c d
$@= a b c d
print each param from $</em>
a
b
c
d
print each param from $@
a
b
c
d
print each param from &quot;$*&quot;
a b c d
print each param from &quot;$@&quot;
a
b
c
d</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/03/Java/Java内部类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/03/Java/Java内部类/" itemprop="url">Java内部类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-03T09:51:07+08:00">
                2018-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文章转自:<a href="http://liuzxc.github.io/blog/java-advance-02/" target="_blank" rel="external">链接</a></p>
<h3>什么是内部类</h3>
<p>定义在其他类（outer class）中的类被称作内部类。内部类可以有访问修饰服，甚至可以被标记为 abstract 或 final。 内部类与外部类实例有特殊的关系，这种关系允许内部类访问外部类的成员，也包括私有成员。</p>
<p>内部类分为以下四种：</p>
<ul>
<li>inner class</li>
<li>局部内部类</li>
<li>匿名内部类</li>
<li>静态嵌套类</li>
</ul>
<h3>Inner Class</h3>
<p>一个内部类被声明在另外一个类当中：</p>
<pre><code>//Top level class definition
class MyOuterClassDemo {
   private int myVar= 1;

   // inner class definition
   class MyInnerClassDemo {
      public void seeOuter () {
         System.out.println(&quot;Value of myVar is :&quot; + myVar);
      }
    } // close inner class definition

} // close Top level class definitio
</code></pre>
<p>实例化一个内部类</p>
<p>为了实例化一个内部类的实例，需要一个外部类的实例。内部类的实例只能通过外部类的实例来创建。</p>
<pre><code>//Top level class definition
class MyOuterClassDemo {
 private int myVar= 1;

 // inner class definition
 class MyInnerClassDemo {
    public void seeOuter () {
       System.out.println(&quot;Value of myVar is :&quot; + myVar);
    }
  } // close inner class definition

 void innerInstance(){
	MyInnerClassDemo inner = new MyInnerClassDemo();
	inner.seeOuter();
 }
 public static void main(String[] args){
	 MyOuterClassDemo outer = new MyOuterClassDemo();
	 outer.innerInstance();
 }
} // close Top level class definitio

Output: Outer Value of x is :1
</code></pre>
<p>上面的例子 mian 方法也可以这样写：</p>
<pre><code> public static void main(String[] args){
	 MyOuterClassDemo.MyInnerClassDemo inner = new MyOuterClassDemo().new MyInnerClassDemo();
	 inner.seeOuter();
 }
</code></pre>
<h3>局部内部类</h3>
<p>局部内部类被定义在外部类的方法当中。</p>
<p>如果你想使用内部类，必须同一方法中实例化内部类
只有 abstract 和 final 这两个修饰符被允许修饰局部内部类
只有在方法的局部变量被标记为 final 或 局部变量是 effectively final的， 内部类才能使用它们。
什么是 effectively final？ “Starting in Java SE 8, a local class can access local variables and parameters of the enclosing block that are final or effectively final. A variable or parameter whose value is never changed after it is initialized is effectively final.” 因此当变量或参数在初始化之后，值再也没有改变过，那么就说明该变量或参数是 effectively final。</p>
<pre><code>//Top level class definition
class MyOuterClassDemo {
 private int x= 1;

 public void doThings(){
    String name =&quot;local variable&quot;; // name is effectively final
    // inner class defined inside a method of outer class
    class MyInnerClassDemo {
      public void seeOuter() {
         System.out.println(&quot;Outer Value of x is :&quot; + x);
         System.out.println(&quot;Value of name is :&quot; + name);
      } //close inner class method
    } // close inner class definition
    MyInnerClassDemo inner = new MyInnerClassDemo();
    inner.seeOuter();
 } //close Top level class method
 public static void main(String[] args){
	 MyOuterClassDemo outer = new MyOuterClassDemo();
	 outer.doThings();
 }
} // close Top level class

Output:

Outer Value of x is :1
Value of name is :local variable
</code></pre>
<h3>匿名内部类</h3>
<p>匿名内部类有以下特点：</p>
<ul>
<li>没有名字</li>
<li>只能被实例化一次</li>
<li>通常被声明在方法或代码块的内部，以一个带有分号的花括号结尾</li>
<li>因为没有名字，所以没有构造函数</li>
<li>不能是静态的（static)</li>
</ul>
<p>为什么要使用匿名类，我们先看一个例子：</p>
<pre><code>abstract class Animal {
	abstract void play();
}

class Dog extends Animal{
	void play(){
		System.out.println(&quot;play with human&quot;);
	}
}

class Demo{
	public static void main(String[] args){
		Animal d = new Dog();
		d.play();
	}
}

Output:  play with human
</code></pre>
<p>如果此处的 Dog 类只使用了一次，那么单独定义一个Dog类是否会显得有点麻烦？ 这个时候我们可以引入匿名类：</p>
<pre><code>abstract class Animal {
	abstract void play();
}

class Person{
	public static void main(String[] args){
		Animal d = new Animal(){
			void play(){
				System.out.println(&quot;play with human&quot;);
			}
		};
		d.play();
	}
}

Output:  play with human
</code></pre>
<p>由上面的例子可以看出，匿名类的一个重要作用就是简化代码。</p>
<p>匿名类的常用场景：</p>
<p>事件监听
普通的实现方式：</p>
<pre><code> public class WindowClosingAdapter extends WindowAdapter {
     public void windowClosing( WindowEvent e ) {
         System.exit(0);
     }
 }

 ...

  addWindowListener( new WindowClosingAdapter() );
</code></pre>
<p>匿名内部类的实现方式：</p>
<pre><code> addWindowListener(
     new WindowAdapter() {
         public void windowClosing( WindowEvent e ) {
             System.exit(0);
         }
     });
</code></pre>
<p>Thread 类的匿名内部类实现
public class Demo {
public static void main(String[] args) {
Thread t = new Thread() {
public void run() {
for (int i = 1; i &lt;= 5; i++) {
System.out.print(i + &quot; &quot;);
}
}
};
t.start();
}
}
Runnable 接口的匿名内部类实现
public class Demo {
public static void main(String[] args) {
Runnable r = new Runnable() {
public void run() {
for (int i = 1; i &lt;= 5; i++) {
System.out.print(i + &quot; &quot;);
}
}
};
Thread t = new Thread(r);
t.start();
}
}</p>
<h3>静态嵌套类</h3>
<p>一个静态嵌套类是被标记为 static 的内部类。
静态嵌套类无法访问外部类的非静态成员。
嵌套类被分为两类：静态和非静态的。被声明为 static 的被称作静态嵌套类，非静态嵌套类就是内部类</p>
<p>例如：</p>
<pre><code>class Outer{
   static class Nested{}
}
静态嵌套类可以被这样实例化：

class Outer{// outer class
   static class Nested{}// static nested class
}

class Demo{
   public static void main(string[] args){
      // use both class names
      Outer.Nested n= new Outer.Nested();
   }
}</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/03/Java/final关键字用法2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/03/Java/final关键字用法2/" itemprop="url">final关键字用法2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-03T09:40:37+08:00">
                2018-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文转自：<a href="http://wiki.jikexueyuan.com/project/java-enhancement/java-fifteen.html" target="_blank" rel="external">原文链接</a></p>
<p>在程序设计中，我们有时可能希望某些数据是不能够改变的，这个时候 final 就有用武之地了。final 是 Java 的关键字，它所表示的是“这部分是无法修改的”。不想被改变的原因有两个：效率、设计。使用到 final 的有三种情况：数据、方法、类。</p>
<p><strong>一、final 数据</strong>
有时候数据的恒定不变是很有用的，它能够减轻系统运行时的负担。对于这些恒定不变的数据我可以叫做“常量”。“常量”主要应用与以下两个地方：</p>
<p>1、编译期常量，永远不可改变。</p>
<p>2、运行期初始化时，我们希望它不会被改变。</p>
<p>对于编译期常量，它在类加载的过程就已经完成了初始化，所以当类加载完成后是不可更改的，编译期可以将它代入到任何用到它的计算式中，也就是说可以在编译期执行计算式。当然对于编译期常量，只能使用基本类型，而且必须要在定义时进行初始化。</p>
<p>有些变量，我们希望它可以根据对象的不同而表现不同，但同时又不希望它被改变，这个时候我们就可以使用运行期常量。对于运行期常量，它既可是基本数据类型，也可是引用数据类型。基本数据类型不可变的是其内容，而引用数据类型不可变的是其引用，引用所指定的对象内容是可变的。</p>
<pre><code>public class Person {
    private String name;

    Person(String name){
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

public class FinalTest {
    private final String final_01 = &quot;chenssy&quot;;    //编 译期常量，必须要进行初始化，且不可更改
    private final String final_02;                //构造器常量，在实例化一个对象时被初始化

    private static Random random = new Random();
    private final int final_03 = random.nextInt(50);    //使用随机数来进行初始化

    //引用
    public final Person final_04 = new Person(&quot;chen_ssy&quot;);    //final指向引用数据类型

    FinalTest(String final_02){
        this.final_02 = final_02;
    }

    public String toString(){
        return &quot;final_01 = &quot; + final_01 +&quot;   final_02  = &quot; + final_02 + &quot;   final_03 = &quot; + final_03 +
               &quot;   final_04 = &quot; + final_04.getName();
    }

    public static void main(String[] args) {
        System.out.println(&quot;------------第一次创建对象------------&quot;);
        FinalTest final1 = new FinalTest(&quot;cm&quot;);
        System.out.println(final1);
        System.out.println(&quot;------------第二次创建对 象------------&quot;);
        FinalTest final2 = new FinalTest(&quot;zj&quot;);
        System.out.println(final2);
        System.out.println(&quot;------------修改引用对 象--------------&quot;);
        final2.final_04.setName(&quot;chenssy&quot;);
        System.out.println(final2);
    }
}

------------------
Output:
------------第一次创建对象------------
final_01 = chenssy   final_02 = cm   final_03 = 34    final_04 = chen_ssy
------------第二次创建对象------------
final_01 = chenssy   final_02 = zj   final_03 = 46   final_04 = chen_ssy
------------修改引用对象--------------
final_01 = chenssy   final_02 = zj   final_03 = 46   final_04 = chenssy
</code></pre>
<p>这里只阐述一点就是：不要以为某些数据是 final 就可以在编译期知道其值，通过 final_03 我们就知道了，在这里是使用随机数其进行初始化，他要在运行期才能知道其值。</p>
<p><strong>二、final 方法</strong>
所有被 final 标注的方法都是不能被继承、更改的，所以对于 final 方法使用的第一个原因就是方法锁定，以防止任何子类来对它的修改。至于第二个原因就是效率问题，鄙人对这个效率问题理解的不是很清楚，在网上摘抄这段话：</p>
<p>在 Java 的早期实现中，如果将一个方法指明为 final，就是同意编译器将针对该方法的所有调用都转为内嵌调用。当编译器发现一个 final 方法调用命令时，它会根据自己的谨慎判断，跳过插入程序代码这种正常的调用方式而执行方法调用机制（将参数压入栈，跳至方法代码处执行，然后跳回并清理栈中的参数，处理返回值），并且以方法体中的实际代码的副本来代替方法调用。这将消除方法调用的开销。当然，如果一个方法很大，你的程序代码会膨胀，因而可能看不到内嵌所带来的性能上的提高，因为所带来的性能会花费于方法内的时间量而被缩减。
对这段话理解我不是很懂就照搬了，那位 Java 牛人可以解释解释下！！</p>
<p>父类的 final 方法是不能被子类所覆盖的，也就是说子类是不能够存在和父类一模一样的方法的。</p>
<pre><code>public class Custom extends Person{
    public void method1(){
        System.out.println(&quot;Person's  method1....&quot;);
    }

//    Cannot override the final method from person：子类不能覆盖父类的final方法
//    public void method2(){
//        System.out.println(&quot;Person's method2...&quot;);
//    }
}
</code></pre>
<p><strong>三、final 类</strong></p>
<p>如果某个类用 final 修改，表明该类是最终类，它不希望也不允许其他来继承它。在程序设计中处于安全或者其他原因，我们不允许该类存在任何变化，也不希望它有子类，这个时候就可以使用 final 来修饰该类了。</p>
<p>对于 final 修饰的类来说，它的成员变量可以为 final，也可以为非 final。如果定义为 final，那么 final 数据的规则同样适合它。而它的方法则会自动的加上 final，因为 final 类是无法被继承，所以这个是默认的。</p>
<p><strong>四、final 参数</strong></p>
<p>在实际应用中，我们除了可以用 final 修饰成员变量、成员方法、类，还可以修饰参数、若某个参数被 final 修饰了，则代表了该参数是不可改变的。</p>
<p>如果在方法中我们修改了该参数，则编译器会提示你：The final local variable i cannot be assigned. It must be blank and not using a compound assignment。</p>
<pre><code>public class Custom {
    public void test(final int i){
        //i++;     ---final参数不可改变
        System.out.println(i);
    }

    public void test(final Person p){
     //p = new Person();    --final参数不可变
     p.setName(&quot;chenssy&quot;);
    }
}
</code></pre>
<p>同 final 修饰参数在内部类中是非常有用的，在匿名内部类中，为了保持参数的一致性，若所在的方法的形参需要被内部类里面使用时，该形参必须为 final。详情参看：<a href="http://www.cnblogs.com/chenssy/p/3390871.html" target="_blank" rel="external">链接</a>。</p>
<p><strong>五、final 与 static</strong></p>
<p>final 和 static 在一起使用就会发生神奇的化学反应，他们同时使用时即可修饰成员变量，也可修饰成员方法。</p>
<p>对于成员变量，该变量一旦赋值就不能改变，我们称它为“全局常量”。可以通过类名直接访问。</p>
<p>对于成员方法，则是不可继承和改变。可以通过类名直接访问。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/02/Java/Java相关名词概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/02/Java/Java相关名词概念/" itemprop="url">Java移位运算</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-02T19:05:34+08:00">
                2018-02-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java里面有很多名词，刚入门的新手肯定有很多名词不知道其意，这里简要总结，详细阐述见其它博客。</p>
<p><strong>J2EE</strong>
全称Java 2 Enterprise Edition，是Java的一种企业版，用于企业级应用开发。</p>
<p><strong>J2SE</strong>
全称Java 2 Standard Edition，是Java的标准版，用于标准应用开发，也是Java基础版本。</p>
<p><strong>J2ME</strong>
全称Java 2 Micro Edition，是Java的微型版，用于手机、PDA等嵌入式开发，针对手机开发，还有专门的J2ME Wireless Toolkit免费套件提供。</p>
<p>总而言之，J2EE,J2SE,J2ME是java针对不同使用范畴提供不同的服务，也就是提供不同类型的类库。针对企业应用的J2EE（Java 2 Enterprise Edition）、针对普通PC应用的J2SE（Java 2 Standard Edition）和针对嵌入式设备及消费类电器的J2ME（Java 2 Micro Edition）三个版本。</p>
<p><strong>EJB</strong>
EJB是sun的JavaEE服务器端组件模型，设计目标与核心应用是部署分布式应用程序。简单来说就是把已经编写好的程序（即：类）打包放在服务器上执行。凭借java跨平台的优势，用EJB技术部署的分布式系统可以不限于特定的平台。EJB (Enterprise JavaBean)是J2EE(javaEE)的一部分，定义了一个用于开发基于组件的企业多重应用程序的标准。</p>
<p><strong>SDK</strong>
全称Software Develop Kit，软件开发工具包，用于帮助开发人员提高开发效率。各种不同类型的软件开发，都可以有自己的SDK。Windows有Windows SDK，DirectX 有 DirectX 9 SDK，.NET开发也有Microsoft .NET Framework SDK。JAVA开发当然也有自己的Java SDK。</p>
<p><strong>JDK</strong>
全称Java development toolkit，相当于是Java的库函数，是编译、运行java程序的工具包，是一切java应用程序的基础,所有java应用程序是构建在这个之上的。它是一组API，也可以说是一些java Class。JDK作为Java开发工具包，主要用于构建在Java平台上运行的应用程序、Applet 和组件等，目前ORACLE官网介绍看，JDK属于SDK的一部分，JDK和SDK一起发行的。</p>
<p><strong>JRE</strong>
全称Java Runtime Environment，Java运行环境，也就是Java平台。所有的Java程序都要在JRE下才能运行。JDK的工具也是Java程序，也需要JRE才能运行。为了保持JDK的独立性和完整性，在JDK的安装过程中，JRE也是安装的一部分。所以，目前ORACLE官网介绍看，JRE则属于JDK的一部分，如果不想开发，只是想跑跑JAVA程序，官网可以下载到单独的JRE包，但如果要开发，还是需安装上面的JDK。</p>
<p><strong>JVM</strong>
全称Java Virtual Machine，Java虚拟机，是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完 善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。JAVA虚拟机JVM是属于JRE的，而现在我们安装JDK时也附带安装了JRE（当然也可以单独安装JRE）。</p>
<p><strong>IoC</strong>
控制反转（Inversion of Control，英文缩写为IoC）把创建对象的权利交给框架,是框架的重要特征，并非面向对象编程的专用术语。它包括依赖注入（Dependency Injection，简称DI）和依赖查找（Dependency Lookup）。IoC不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</p>
<p><strong>AOP</strong>
在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<p><strong>JavaBean</strong>
JavaBean 是一种JAVA语言写成的可重用组件。为写成JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性，set和get方法获取。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/31/Java/Java移位运算符/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/31/Java/Java移位运算符/" itemprop="url">Java移位运算</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-31T11:30:45+08:00">
                2018-01-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JAVA 中有以上三种移位符号，那么下面的输出是什么呢？</p>
<pre><code>System.out.println(0xff &gt;&gt;&gt; 7);

System.out.println((((byte) 0xff) &gt;&gt;&gt; 7));

System.out.println((byte) (((byte) 0xff) &gt;&gt;&gt; 7));
</code></pre>
<p>1、三种移位符号的意义是什么？</p>
<pre><code>&gt;&gt; 是带符号右移，若左操作数是正数，则高位补“0”，若左操作数是负数，则高位补“1”.
&lt;&lt; 将左操作数向左边移动，并且在低位补0.
&gt;&gt;&gt; 是无符号右移，无论左操作数是正数还是负数，在高位都补“0”
</code></pre>
<p>2、三种移位符号作用的左操作数有五种：long,int,short,byte,char,但是在作用不同的操作数类型时，其具体过程不同, 遵循一下几个原则：</p>
<p>a : int移位时，左边的操作数是32位的，此时的移位符号作用在32位bit上。如：1 &gt;&gt; 3, 是将00000000 00000000 00000000 00000001这32位向右边移动3位。</p>
<p>b: long 移位时，左边的操作数是64位的，此时移位符号作用在64位bit上。如：1L &gt;&gt; 3。</p>
<p>c: short, byte,char 在移位之前首先将数据转换为int，然后再移位，此时移位符号作用在32为bit上。如：(byte)0xff &gt;&gt;&gt; 7, 是将11111111 11111111 11111111 11111111向右边移动7位，得到00000001 11111111 11111111 11111111, 所以结果不是你所期望的1，呵呵。</p>
<p>3、有1,2可知，当左操作数是long时，移位之后得到的类型是long，当左操作数是其它四中类型时，移位之后得到的类型是int，所以如果做操作数是byte,char,short 时，你用　&gt;&gt;=,&gt;&gt;&gt;=, &lt;&lt;= 其实是将得到的int 做低位截取得到的数值。这里往往容易犯错。</p>
<p>４、三种移位符号除了对做操作数有操作规则外，其实对右操作数也有操作规则。如果左操作数（转换之后的）是int,那么右操作数只有低５位有效，为什么?因为int 总共就32位，如：23 &gt;&gt; 33, 结果与23 &gt;&gt;1是一样的，都是11；同理，如果左边操作数是long，那么右边操作数只有低6位有效。</p>
<pre><code>System.out.println(0xff &gt;&gt;&gt; 7);
</code></pre>
<p>0xff 本身就是一个int，其bits为：00000000 00000000 00000000 11111111，无符号向右移动7位， 得到的bits当然为：00000000 00000000 00000000 00000001，</p>
<pre><code>System.out.println((((byte) 0xff) &gt;&gt;&gt; 7));
</code></pre>
<p>(byte)0xff 是一个byte，bits为： 11111111， 首先转换为int，其bits为：11111111 11111111 11111111 11111111， 向右边无符号移动7为，得到的结果bits是：00000001 11111111 11111111 11111111。</p>
<pre><code>System.out.println((byte) (((byte) 0xff) &gt;&gt;&gt; 7));
</code></pre>
<p>(byte) 0xff 是一个byte，bits为： 11111111， 首先转换为int，其bits为：11111111 11111111 11111111 11111111，向右边无符号移动7为，得到的结果bits是：00000001 11111111 11111111 11111111，然后转换为byte，低位截取得到bits: 11111111, 在输出的时候转换为int， 其bits为：11111111 11111111 11111111 11111111.</p>
<p>上面三个的结果是：</p>
<pre><code>1
33554431
-1</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/30/Java/final关键字用法1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/30/Java/final关键字用法1/" itemprop="url">final关键字用法1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-30T23:52:32+08:00">
                2018-01-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.修饰数据</p>
<p>在java中，用final关键字修饰的变量，只能进行一次赋值操作，并且在生存期内不可以改变它的值。在针对基本类型和引用类型时，final关键字的效果存在细微差别。例子：</p>
<pre><code>class Value {
    int v;
    public Value(int v) {
        this.v = v;
    }
}

public class FinalTest {
    
    final int f1 = 1;
    final int f2;
    public FinalTest() {
        f2 = 2;
    }

    public static void main(String[] args) {
        final int value1 = 1;
        // value1 = 4;
        final double value2;
        value2 = 2.0;
        final Value value3 = new Value(1);
        value3.v = 4;
    }
}
</code></pre>
<p>给value1赋初始值之后，我们无法再对value1的值进行修改，final关键字起到了常量的作用;从value2我们可以看到，final修饰的变量可以不在声明时赋值，即可以先声明，后赋值;value3时一个引用变量，final修饰引用变量时，只是限定了引用变量的引用不可改变，即不能将value3再次引用另一个Value对象，但是引用的对象的值是可以改变的。</p>
<p>引用变量的值实际上是它所引用的对象的地址，该地址的值是不可改变的，实际引用的对象实际上是不受final关键字的影响的，所以它的值是可以改变的。因为final修饰的数据的值是不可改变的，所以我们必须确保在使用前就已经对成员变量赋值了。因此对于final修饰的成员变量，我们有且只有两个地方可以给它赋值，一个是声明该成员时赋值，另一个是在构造方法中赋值。</p>
<p>2.修饰方法参数</p>
<p>编写方法时，可以在参数前面添加final关键字，它表示在整个方法中，不能改变参数的值：</p>
<pre><code>public class FinalTest {

    /* ... */

    public void finalFunc(final int i, final Value value) {
        // i = 5; 不能改变i的值
        // v = new Value(); 不能改变v的值
        value.v = 5; // 可以改变引用对象的值
    }
}
</code></pre>
<p>3.修饰方法</p>
<p>第三种方式，即用final关键字修饰方法，它表示该方法不能被覆盖。关于private和final关键字还有一点联系，这就是类中所有的private方法都隐式地指定为是final的，由于无法在类外使用private方法，所以也就无法覆盖它。</p>
<p>4.修饰类</p>
<p>用final修饰的类是无法被继承的。</p>
<p>总结</p>
<p>final关键字是我们经常使用的关键字之一，它的主要用法有以下四种：</p>
<ul>
<li>用来修饰数据，包括成员变量和局部变量，该变量只能被赋值一次且它的值无法被改变。对于成员变量来讲，我们必须在声明时或者构造方法中对它赋值；</li>
<li>用来修饰方法参数，表示在变量的生存期中它的值不能被改变；</li>
<li>修饰方法，表示该方法无法被重写；</li>
<li>修饰类，表示该类无法被继承。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/29/Nginx/Nginx基本概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/29/Nginx/Nginx基本概念/" itemprop="url">nginx基础概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-29T20:23:42+08:00">
                2018-01-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3>connection</h3>
<p>在nginx中connection就是对tcp连接的封装，其中包括连接的socket，读事件，写事件。nginx连接上限与系统对fd的限制不一样。nginx在实现时，是通过一个连接池来管理的，每个worker进程都有一个独立的连接池，连接池的大小是worker_connections。连接池里面保存的其实不是真实的连接，它只是一个worker_connections大小的一个ngx_connection_t结构的数组。nginx会通过一个链表free_connections来保存所有的空闲ngx_connection_t，每次获取一个连接时，就从空闲连接链表中获取一个，用完后，再放回空闲连接链表里面。（worker_connections表示每个worker进程所能建立连接的最大值）</p>
<h3>request</h3>
<p>nginx指的是http请求，具体到nginx中的数据结构是ngx_http_request_t，是对一个http请求的封装。处理流程图：
<img src="http://tengine.taobao.org/book/_images/chapter-2-2.PNG" alt=""></p>
<h3>请求相关的概念</h3>
<h3>keepalive</h3>
<p>http请求是基于TCP协议之上的，客户端在发起请求前，需要先与服务端建立TCP连接，需要三次握手来确定的，三次交互也会带来网络流量。http请求是请求应答式的，如果能知道每个请求头与响应体的长度，可以在一个连接上面执行多个请求的，这就是长连接。</p>
<h3>http协议中关于响应body长度的确定：</h3>
<p>对于http1.0协议，如果响应头中有content-length头，则以content-length的长度就可以知道body的长度了，客户端在接收body时，就可以依照这个长度来接收数据。而如果没有content-length头，则客户端会一直接收数据，直到服务端主动断开连接，才表示body接收完了。
对于http1.1协议，如果响应头中的Transfer-encoding为chunked传输，则表示body是流式输出，body会被分成多个块，每块的开始会标识出当前块的长度，此时，body不需要通过长度来指定。如果是非chunked传输，而且有content-length，则按照content-length来接收数据。否则，如果是非chunked，并且没有content-length，则客户端接收数据，直到服务端主动断开连接。</p>
<p>当服务端在输出完body之后，会可以考虑使用长连接。如果客户端的请求头中的connection为close，则表示客户端需要关掉长连接；如果为keep-alive，则客户端需要打开长连接；如果客户端的请求中没有connection这个头，那么根据协议，http1.0默认为close，http1.1默认为keep-alive。如果结果为keepalive，nginx在输出完响应体后，会设置当前连接的keepalive属性，然后等待客户端下一次请求。当然，nginx不可能一直等待下去，当nginx设置了keepalive等待下一次的请求时，同时也会设置一个最大等待时间，这个时间是通过选项keepalive_timeout来配置的，如果配置为0，则表示关掉keepalive，强制为close。</p>
<h3>pipe</h3>
<p>在http1.1中，引入了一种新的特性，即pipeline。它可以看作为keepalive的一种升华，因为pipeline也是基于长连接的，目的就是利用一个连接做多次请求。如果客户端要提交多个请求，对keepalive来说，第二个请求必须要等到第一个请求的响应接收完全后，才能发起，这和TCP的停止等待协议是一样的，得到两个响应的时间至少为2<em>RTT。对pipeline来说，客户端不必等到第一个请求处理完后，就可以马上发起第二个请求，得到两个响应的时间可能能够达到1</em>RTT。
nginx对pipeline中的多个请求的处理却不是并行的，依然是一个请求接一个请求的处理，只是在处理第一个请求的时候，客户端就可以发起第二个请求。nginx利用pipeline减少了处理完一个请求后等待第二个请求的请求头数据的时间。nginx在读取数据时，会将读取的数据放到一个buffer里面，如果nginx在处理完前一个请求后，如果发现buffer里面还有数据，就认为剩下的数据是下一个请求的开始，然后就接下来处理下一个请求，否则就设置keepalive。</p>
<h3>lingering_close</h3>
<p>lingering_close就是延迟关闭，当nginx要关闭连接时，并非立即关闭连接，而是先关闭tcp连接的写，再等待一段时间后再关掉连接的读。考虑以下场景：nginx在接收客户端的请求时，可能由于客户端或服务端出错了，要立即响应错误信息给客户端，而nginx在响应错误信息后，大分部情况下是需要关闭当前连接。nginx执行完write()系统调用把错误信息发送给客户端，write()系统调用返回成功并不表示数据已经发送到客户端，有可能还在tcp连接的write buffer里。接着如果直接执行close()系统调用关闭tcp连接，内核会首先检查tcp的read buffer里有没有客户端发送过来的数据留在内核态没有被用户态进程读取，如果有则发送给客户端RST报文来关闭tcp连接丢弃write buffer里的数据，如果没有则等待write buffer里的数据发送完毕，然后再经过正常的4次分手报文断开连接。所以,当在某些场景下出现tcp write buffer里的数据在write()系统调用之后到close()系统调用执行之前没有发送完毕，且tcp read buffer里面还有数据没有读，close()系统调用会导致客户端收到RST报文且不会拿到服务端发送过来的错误信息数据。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/29/Nginx/Nginx架构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/29/Nginx/Nginx架构/" itemprop="url">nginx架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-29T20:18:27+08:00">
                2018-01-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>nginx在启动后，在unix系统中会以daemon的方式在后台运行，后台进程包含一个master进程和多个worker进程。</p>
<p>nginx进程模型图：
<img src="http://tengine.taobao.org/book/_images/chapter-2-1.PNG" alt=""></p>
<p>master进程接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。而基本的网络事件，则是放在worker进程中来处理了。多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。</p>
<p>每个worker进程都是从master进程fork过来，在master进程里面，先建立好需要listen的socket（listenfd）之后，然后再fork出多个worker进程。所有worker进程的listenfd会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有worker进程在注册listenfd读事件前抢accept_mutex，抢到互斥锁的那个进程注册listenfd读事件，在读事件里调用accept接受该连接。当一个worker进程在accept这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，一个请求，只在一个worker进程中处理。</p>
<p>进程模型好处：对于每个worker进程来说，独立的进程，不需要加锁；采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断；worker进程的异常退出，会导致当前worker上的所有请求失败，不会影响到所有请求，降低了风险。</p>
<p>nginx采用了异步非阻塞的方式来处理请求，即利用select|poll|epoll|kqueue这样的库函数。它们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回，当读写返回EAGAIN时，我们将它再次加入到epoll里面（以epoll为例）。</p>
<p>为什么要推荐设置worker的个数为cpu的核数？更多的worker数，只会导致进程来竞争cpu资源了，从而带来不必要的上下文切换。nginx提供了cpu亲缘性的绑定选项,不会因为进程的切换带来cache的失效。</p>
<p>对于一个基本的web服务器来说，事件通常有三种类型，网络事件、信号、定时器。首先，信号的处理，如果nginx正在等待事件（epoll_wait时），如果程序收到信号，在信号处理函数处理完后，epoll_wait会返回错误，然后程序可再次进入epoll_wait调用。定时器的处理，由于epoll_wait等函数在调用的时候是可以设置一个超时时间的，所以nginx借助这个超时时间来实现定时器。nginx里面的定时器事件是放在一颗维护定时器的红黑树里面，每次在进入epoll_wait前，先从该红黑树里面拿到所有定时器事件的最小时间，在计算出epoll_wait的超时时间后进入epoll_wait。所以，当没有事件产生，也没有中断信号时，epoll_wait会超时，定时器事件到了，nginx会检查所有的超时事件，将他们的状态设置为超时，然后再去处理网络事件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/29/Nginx/Nginx代码风格/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/29/Nginx/Nginx代码风格/" itemprop="url">Nginx代码风格</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-29T16:20:48+08:00">
                2018-01-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>一、基本原则</strong></p>
<ul>
<li>K&amp;R编码风格（偏BSD子类）。</li>
<li>每行不能超过80列。</li>
<li>不用TAB对齐，用空格。</li>
<li>默认对齐单元是4个空格。</li>
<li>除宏定义外，字母均为小写，单词间用下划线_间隔。</li>
<li>使用C方式的注释，不得使用//形式注释。</li>
<li>中缀运算符的前后须空一格，如3 + 2以及a &gt; 3。</li>
<li>逗号后须空一格，如foo(a, b, c);</li>
</ul>
<p><strong>二、风格图示</strong></p>
<p><img src="http://tengine.taobao.org/book/_images/code-style-1.JPG" alt="">
1、	if/while/for/switch语句的左花括号和关键字在同一行上，和括号之间空一个空格。
2、	else关键字和两个花括号在同一行上。
<img src="http://tengine.taobao.org/book/_images/code-style-2.JPG" alt="">
3、	文件开始的注释空一行。
4、	较为完整的代码块间的距离为空两行。如函数声明、函数定义之间等。
5、	函数声明或定义若一行显示不下，则函数原型空4个空格。
6、	结构体数组的花括号和内容之间空一个空格。
<img src="http://tengine.taobao.org/book/_images/code-style-3.JPG" alt="">
7、	结构体数组的左花括号放在同一行上。
8、	较大的结构体数组元素最开始空一行。
9、	元素内容上下对齐。
<img src="http://tengine.taobao.org/book/_images/code-style-4.JPG" alt="">
10、注释上下对齐。
<img src="http://tengine.taobao.org/book/_images/code-style-5.JPG" alt="">
11、函数调用折行时，参数上下对齐。
<img src="http://tengine.taobao.org/book/_images/code-style-6.JPG" alt="">
12、函数定义时，类型单独一行。
13、变量声明的类型上下排列按照从短到长的顺序。注意，最下面的变量的类型和名称间的空格为2-3个。一般情况下为2个，这是Nginx中最小的变量声明中类型和名称的距离。
14、变量名称上下对齐——字母对齐，不包括指针的*号。
<img src="http://tengine.taobao.org/book/_images/code-style-7.JPG" alt="">
15、结构体内变量上下对齐（字母，不包括指针的的*号）。
<img src="http://tengine.taobao.org/book/_images/code-style-8.JPG" alt="">
16、单行注释格式为/* something */
<img src="http://tengine.taobao.org/book/_images/code-style-9.JPG" alt="">
17、多行注释的格式为：</p>
<pre><code>/*
 * something
 */
</code></pre>
<p><img src="http://tengine.taobao.org/book/_images/code-style-10.JPG" alt="">
18、函数定义的左花括号独占一行。
19、switch语句中，switch和case关键字上下对齐。
<img src="http://tengine.taobao.org/book/_images/code-style-11.JPG" alt="">
20、当条件表达式过长需要折行时，关系运算符须位于下一行的行首，并与上一行的条件表达式的第一个字符对齐，同时右花括号须位于单独的一行，并与if/while等关键字对齐。
<img src="http://tengine.taobao.org/book/_images/code-style-12.JPG" alt="">
21、 else语句之前须空出一行。
<img src="http://tengine.taobao.org/book/_images/code-style-13.JPG" alt="">
22、在函数中，相同类型的变量声明放在一行上。</p>
<hr>
<p><strong>参考链接：</strong></p>
<ul>
<li><a href="http://tengine.taobao.org/book/appendix_a.html" target="_blank" rel="external">编码风格</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/29/OS/栈空间和堆空间/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/29/OS/栈空间和堆空间/" itemprop="url">栈空间和堆空间</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-29T22:15:16+08:00">
                2017-10-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一个由C/C++编译的程序占用的内存分为以下几个部分：</p>
<p>1、栈区（stack）：又编译器自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构的栈。</p>
<p>2、堆区（heap）：一般是由程序员分配释放，若程序员不释放的话，程序结束时可能由OS回收，值得注意的是他与数据结构的堆是两回事，分配方式倒是类似于数据结构的链表。</p>
<p>3、全局区（static）：也叫静态数据内存空间，存储全局变量和静态变量，全局变量和静态变量的存储是放一块的，初始化的全局变量和静态变量放一块区域，没有初始化的在相邻的另一块区域，程序结束后由系统释放。</p>
<p>4、文字常量区：常量字符串就是放在这里，程序结束后由系统释放。</p>
<p>5、程序代码区：存放函数体的二进制代码。</p>
<p><strong>堆和栈的区别：</strong></p>
<p>1、由以上综述就可以得知，他们程序的内存分配方式不同。</p>
<p>2、申请和响应不同：</p>
<p>（1）申请方式：</p>
<p>stack由系统自动分配，系统收回；heap需要程序员自己申请，C中用函数malloc分配空间，用free释放，C++用new分配，用delete释放。</p>
<p>（2）申请后系统的响应：</p>
<p>栈：只要栈的剩余空间大于所申请的空间，体统将为程序提供内存，否则将报异常提示栈溢出。</p>
<p>堆：首先应该知道操作系统有一个记录内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请的空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete或free语句就能够正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会将多余的那部分重新放入空闲链表中。</p>
<p>3、申请的大小限制不同：</p>
<p>栈：在windows下，栈是向低地址扩展的数据结构，是一块连续的内存区域，栈顶的地址和栈的最大容量是系统预先规定好的，能从栈获得的空间较小。</p>
<p>堆：堆是向高地址扩展的数据结构，是不连续的内存区域，这是由于系统是由链表在存储空闲内存地址，自然堆就是不连续的内存区域，且链表的遍历也是从低地址向高地址遍历的，堆得大小受限于计算机系统的有效虚拟内存空间，由此空间，堆获得的空间比较灵活，也比较大。</p>
<p>4、申请的效率不同：</p>
<p>栈：栈由系统自动分配，速度快，但是程序员无法控制。</p>
<p>堆：堆是有程序员自己分配，速度较慢，容易产生碎片，不过用起来方便。</p>
<p>5、堆和栈的存储内容不同：</p>
<p>栈：在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令的地址，然后是函数的各个参数，在大多数的C编译器中，参数是从右往左入栈的，当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令。</p>
<p>堆：一般是在堆得头部用一个字节存放堆得大小，具体内容由程序员安排</p>
<hr>
<p><strong>参考链接：</strong></p>
<ul>
<li><a href="http://www.cnblogs.com/kevinGaoblog/archive/2012/03/23/2413102.html" target="_blank" rel="external">参考1</a></li>
<li><a href="http://www.jianshu.com/p/2a06728d583c" target="_blank" rel="external">参考2</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/Life/to be continued/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/08/Life/to be continued/" itemprop="url">To be continued ...</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T13:47:40+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p><strong>历史的进程还在继续...<br>
Life is continuing...</strong></p>
<h6>2018/1/29 16:01:07</h6>
<p>我说过，这个博客我会一直写下去，好久不见，这个学期本来就比较繁忙，有经历了一些事情，前段时间历经网络Final作业和考试周的洗礼，现在终于放假了。It's show Time :)</p>
<h6>2017/10/22 11:22:57</h6>
<p>不要强迫症，没有最完美的东西，绝对没有；
知识和技能的学习才是根本目的，但也要和作业区分开来。</p>
<h6>2017/10/14 13:40:18</h6>
<p>一周一晃又过了，大部分时间都在这上边了，如何节约时间呢？本周总结几点：先易后难，先大部分再小细节，先重要后次要；有时卡壳个别题目可以先留着，有时候前后呼应，有所启发，理解的也深入一些；不要着急写文档，先可以写个60分的草稿。</p>
<h6>2017/10/9 17:20:18</h6>
<p>听课后的小结</p>
<ol>
<li>在实际操作时，多想一下本质总是好的，比如安装Linux虚拟机时NAT模式、bridge、host only模式的区别是什么，选择任意模式连接虚拟机和宿主机时出现问题不懂，光看一些教程即使当时可能正确了，但是按部就班是没有任何收获的，多思考、多尝试非常重要。</li>
<li>很多教程知识并不是完全适用你所在的环境的，比如Linux下有很多版本，光RedHat版本就有几种，同一系列下系统的一些配置命令、文件不同，还有MySQL与MariaDB等类似兼容软件名字不同等等，所以，要学会思考关键词，搜索才会有效率。</li>
<li>对于未知的东西，都应该问为什么，思考、猜测、多尝试才会有收获，不要做一遍之后什么都忘得一干二净。</li>
</ol>
<h6>2017/10/8 13:57:49</h6>
<p>今天算是我的个人博客的开篇吧，其实从小学、初中、高中、大学以来我都没有记笔记或者写作等等习惯，除了高中时期会有一些个人总结、心得感悟之类。一年以前这个博客已经搭建好，也是在国庆期间，发了三遍一般性文章就没有再怎么用到Hexo、GitHub等工具，一直搁到现在...</p>
<p>这一年中，大部分时间其实都在刷数据结构和算法题，以前想写点什么，总是觉得没什么好写，其实完全可以把这一年做的大大小小的算法题目及解题心得放在博客上的，目前只是把部分的题解放在了GitHub中，等有时间回味和复习的时候，把一些比较好的题目整理再推送吧。</p>
<p>希望能够把这个博客写下去，BaiJia Come on !</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/Test/MarkDown Test1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/08/Test/MarkDown Test1/" itemprop="url">MarkDown 语法测试1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T10:07:49+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1>MarkDown 语法测试</h1>
<hr>
<p><strong>粗体</strong></p>
<p><em>斜体</em></p>
<blockquote>
<p>引用</p>
</blockquote>
<p><code>代码块</code></p>
<h1>标题1</h1>
<h2>标题2</h2>
<p><a href="http://BaiJiazm.github.io" title="超链接" target="_blank" rel="external">超链接 http://BaiJiazm.github.io</a></p>
<ul>
<li>1</li>
<li>2</li>
<li>3</li>
</ul>
<ol>
<li>1</li>
<li>2</li>
<li>3</li>
</ol>
<hr>
<p>水平标尺</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/Test/Markdown Test2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/08/Test/Markdown Test2/" itemprop="url">MarkDown 语法测试2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T10:07:49+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<h2>心心念念的Markdown</h2>
<ol>
<li>这是第一行列表项。</li>
<li>这是第二行列表项。</li>
</ol>
<p>给出一些例子代码：</p>
<pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);
</code></pre>
</blockquote>
<blockquote>
<p>This is the first level of quoting.</p>
<blockquote>
<p>This is nested blockquote.</p>
</blockquote>
<p>Back to the first level.</p>
</blockquote>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
<p>Here is an example of AppleScript:</p>
<pre><code>tell application &quot;Foo&quot;
    beep
end tell
</code></pre>
<hr>
<hr>
<hr>
<hr>
<hr>
<p>A single backtick in a code span: <code>`</code></p>
<p>A backtick-delimited string in a code span: <code>`foo`</code></p>
<p>Please don't use any <code>&lt;blink&gt;</code> tags.</p>
<p>I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank" rel="external">Google</a> than from
<a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="external">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="external">MSN</a>.</p>
<p><a href="http://example.com/" target="_blank" rel="external">http://example.com/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/07/Other/命令行语法格式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/07/Other/命令行语法格式/" itemprop="url">命令行语法格式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-07T00:27:04+08:00">
                2016-10-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>各系统在描述命令行格式时各有区别，具体可参考具体文档说明，一般采用的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">命令 &lt;必选参数1|必选参数2&gt; [-option &#123;必选参数1|必选参数2|必选参数3&#125;] [可选参数...] &#123;(默认参数)|参数|参数&#125;</div></pre></td></tr></table></figure>
<p>命令格式中常用的几个符号含义如下：</p>
<p>尖括号&lt; &gt;：必选参数，使用时应将其替换为所指含义的参数</p>
<p>大括号{ }：必选参数，系统定义的参数，包含此处允许使用的参数</p>
<p>方括号[ ]：可选参数，系统定义的参数，在命令中根据需要加以取舍</p>
<p>小括号( )：指明参数的默认值，只用于{ }中</p>
<p>竖线|：用于分隔多个互斥参数，含义为“或”，使用时只能选择一个。</p>
<p>省略号...：以此类推前面，任意多个参数。</p>
<hr>
<p><strong>参考链接：</strong></p>
<ul>
<li><a href="http://man.chinaunix.net/linux/mandrake/101/zh_cn/Command-Line.html/convention.html#id2535998" target="_blank" rel="external">China Unix</a></li>
<li><a href="http://www.dewassoc.com/support/msdos/dos_commands.html" target="_blank" rel="external">MS-DOS Commands</a></li>
<li><a href="http://lavasoft.blog.51cto.com/62575/533131" target="_blank" rel="external">Linux命令格式</a></li>
<li><a href="https://support.ca.com/cadocs/0/CA%20ARCserve%20%20Backup%20r16-CHS/Bookshelf_Files/HTML/cmndline/index.htm?toc.htmcl_cmd_line_syntax_char.htm" target="_blank" rel="external">命令行语法字符</a></li>
<li><a href="http://publib.boulder.ibm.com/tividd/td/ITCM/SC23-4706-01/zh_CN/HTML/cmmcmst17.htm" target="_blank" rel="external">命令行语法</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/07/Life/从头再来/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaiJiazm">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPhoto.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BaiJiazm">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/07/Life/从头再来/" itemprop="url">从头再来</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-07T00:18:36+08:00">
                2016-10-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><a href="http://music.163.com/song/109194/?userid=9727644" target="_blank" rel="external">《从头再来》</a></h1>
<hr>
<blockquote>
<p>演唱：刘欢
演唱：刘欢
填词：陈涛
谱曲：王晓锋
音乐风格：流行
歌曲语言：国语</p>
</blockquote>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">昨天所有的荣誉，</div><div class="line">已变成遥远的回忆。</div><div class="line">勤勤苦苦已度过半生，</div><div class="line">今夜重又走进风雨。</div><div class="line">我不能随波浮沉，</div><div class="line">为了我致爱的亲人。</div><div class="line">再苦再难也要坚强，</div><div class="line">只为那些期待眼神。</div><div class="line">心若在梦就在，</div><div class="line">天地之间还有真爱</div><div class="line">看成败人生豪迈，</div><div class="line">只不过是从头再来</div><div class="line"></div><div class="line">昨天所有的荣誉，</div><div class="line">已变成遥远的回忆。</div><div class="line">勤勤苦苦已度过半生，</div><div class="line">今夜重又走入风雨。</div><div class="line">我不能随波浮沉，</div><div class="line">为了我致爱的亲人。</div><div class="line">再苦再难也要坚强，</div><div class="line">只为那些期待眼神。</div><div class="line">心若在梦就在，</div><div class="line">天地之间还有真爱</div><div class="line">看成败人生豪迈，</div><div class="line">只不过是从头再来</div><div class="line">心若在梦就在，</div><div class="line">天地之间还有真爱</div><div class="line">看成败人生豪迈，</div><div class="line">只不过是从头再来</div><div class="line">心若在梦就在，</div><div class="line">天地之间还有真爱</div><div class="line">看成败人生豪迈，</div><div class="line">只不过是从头再来</div><div class="line">心若在梦就在，</div><div class="line">天地之间还有真爱</div><div class="line">看成败人生豪迈，</div><div class="line">只不过是从头再来</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/headPhoto.png"
                alt="BaiJiazm" />
            
              <p class="site-author-name" itemprop="name">BaiJiazm</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/BaiJiazm" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:b110011@qq.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BaiJiazm</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
